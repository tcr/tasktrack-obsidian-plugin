"use strict";
const require$$0$1 = require("obsidian");
const state = require("@codemirror/state");
const view = require("@codemirror/view");
var n$1, l$2, u$2, i$1, o$2, r$2, e$2, f$2, c$1, s$1, a$1, h$1, p$1 = {}, v$1 = [], y$1 = /acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i, d$1 = Array.isArray;
function w$2(n2, l2) {
  for (var u2 in l2) n2[u2] = l2[u2];
  return n2;
}
function g$2(n2) {
  n2 && n2.parentNode && n2.parentNode.removeChild(n2);
}
function _$1(l2, u2, t2) {
  var i2, o2, r2, e2 = {};
  for (r2 in u2) "key" == r2 ? i2 = u2[r2] : "ref" == r2 ? o2 = u2[r2] : e2[r2] = u2[r2];
  if (arguments.length > 2 && (e2.children = arguments.length > 3 ? n$1.call(arguments, 2) : t2), "function" == typeof l2 && null != l2.defaultProps) for (r2 in l2.defaultProps) void 0 === e2[r2] && (e2[r2] = l2.defaultProps[r2]);
  return m$1(l2, e2, i2, o2, null);
}
function m$1(n2, t2, i2, o2, r2) {
  var e2 = { type: n2, props: t2, key: i2, ref: o2, __k: null, __: null, __b: 0, __e: null, __c: null, constructor: void 0, __v: null == r2 ? ++u$2 : r2, __i: -1, __u: 0 };
  return null == r2 && null != l$2.vnode && l$2.vnode(e2), e2;
}
function b$1() {
  return { current: null };
}
function k$2(n2) {
  return n2.children;
}
function x$2(n2, l2) {
  this.props = n2, this.context = l2;
}
function S(n2, l2) {
  if (null == l2) return n2.__ ? S(n2.__, n2.__i + 1) : null;
  for (var u2; l2 < n2.__k.length; l2++) if (null != (u2 = n2.__k[l2]) && null != u2.__e) return u2.__e;
  return "function" == typeof n2.type ? S(n2) : null;
}
function C$2(n2) {
  var l2, u2;
  if (null != (n2 = n2.__) && null != n2.__c) {
    for (n2.__e = n2.__c.base = null, l2 = 0; l2 < n2.__k.length; l2++) if (null != (u2 = n2.__k[l2]) && null != u2.__e) {
      n2.__e = n2.__c.base = u2.__e;
      break;
    }
    return C$2(n2);
  }
}
function M$1(n2) {
  (!n2.__d && (n2.__d = true) && i$1.push(n2) && !$$1.__r++ || o$2 != l$2.debounceRendering) && ((o$2 = l$2.debounceRendering) || r$2)($$1);
}
function $$1() {
  for (var n2, u2, t2, o2, r2, f2, c2, s2 = 1; i$1.length; ) i$1.length > s2 && i$1.sort(e$2), n2 = i$1.shift(), s2 = i$1.length, n2.__d && (t2 = void 0, o2 = void 0, r2 = (o2 = (u2 = n2).__v).__e, f2 = [], c2 = [], u2.__P && ((t2 = w$2({}, o2)).__v = o2.__v + 1, l$2.vnode && l$2.vnode(t2), O$1(u2.__P, t2, o2, u2.__n, u2.__P.namespaceURI, 32 & o2.__u ? [r2] : null, f2, null == r2 ? S(o2) : r2, !!(32 & o2.__u), c2), t2.__v = o2.__v, t2.__.__k[t2.__i] = t2, N$1(f2, t2, c2), o2.__e = o2.__ = null, t2.__e != r2 && C$2(t2)));
  $$1.__r = 0;
}
function I$1(n2, l2, u2, t2, i2, o2, r2, e2, f2, c2, s2) {
  var a2, h2, y2, d2, w2, g2, _2, m2 = t2 && t2.__k || v$1, b2 = l2.length;
  for (f2 = P$2(u2, l2, m2, f2, b2), a2 = 0; a2 < b2; a2++) null != (y2 = u2.__k[a2]) && (h2 = -1 == y2.__i ? p$1 : m2[y2.__i] || p$1, y2.__i = a2, g2 = O$1(n2, y2, h2, i2, o2, r2, e2, f2, c2, s2), d2 = y2.__e, y2.ref && h2.ref != y2.ref && (h2.ref && B$2(h2.ref, null, y2), s2.push(y2.ref, y2.__c || d2, y2)), null == w2 && null != d2 && (w2 = d2), (_2 = !!(4 & y2.__u)) || h2.__k === y2.__k ? f2 = A$2(y2, f2, n2, _2) : "function" == typeof y2.type && void 0 !== g2 ? f2 = g2 : d2 && (f2 = d2.nextSibling), y2.__u &= -7);
  return u2.__e = w2, f2;
}
function P$2(n2, l2, u2, t2, i2) {
  var o2, r2, e2, f2, c2, s2 = u2.length, a2 = s2, h2 = 0;
  for (n2.__k = new Array(i2), o2 = 0; o2 < i2; o2++) null != (r2 = l2[o2]) && "boolean" != typeof r2 && "function" != typeof r2 ? ("string" == typeof r2 || "number" == typeof r2 || "bigint" == typeof r2 || r2.constructor == String ? r2 = n2.__k[o2] = m$1(null, r2, null, null, null) : d$1(r2) ? r2 = n2.__k[o2] = m$1(k$2, { children: r2 }, null, null, null) : void 0 === r2.constructor && r2.__b > 0 ? r2 = n2.__k[o2] = m$1(r2.type, r2.props, r2.key, r2.ref ? r2.ref : null, r2.__v) : n2.__k[o2] = r2, f2 = o2 + h2, r2.__ = n2, r2.__b = n2.__b + 1, e2 = null, -1 != (c2 = r2.__i = L$1(r2, u2, f2, a2)) && (a2--, (e2 = u2[c2]) && (e2.__u |= 2)), null == e2 || null == e2.__v ? (-1 == c2 && (i2 > s2 ? h2-- : i2 < s2 && h2++), "function" != typeof r2.type && (r2.__u |= 4)) : c2 != f2 && (c2 == f2 - 1 ? h2-- : c2 == f2 + 1 ? h2++ : (c2 > f2 ? h2-- : h2++, r2.__u |= 4))) : n2.__k[o2] = null;
  if (a2) for (o2 = 0; o2 < s2; o2++) null != (e2 = u2[o2]) && 0 == (2 & e2.__u) && (e2.__e == t2 && (t2 = S(e2)), D$2(e2, e2));
  return t2;
}
function A$2(n2, l2, u2, t2) {
  var i2, o2;
  if ("function" == typeof n2.type) {
    for (i2 = n2.__k, o2 = 0; i2 && o2 < i2.length; o2++) i2[o2] && (i2[o2].__ = n2, l2 = A$2(i2[o2], l2, u2, t2));
    return l2;
  }
  n2.__e != l2 && (t2 && (l2 && n2.type && !l2.parentNode && (l2 = S(n2)), u2.insertBefore(n2.__e, l2 || null)), l2 = n2.__e);
  do {
    l2 = l2 && l2.nextSibling;
  } while (null != l2 && 8 == l2.nodeType);
  return l2;
}
function H$1(n2, l2) {
  return l2 = l2 || [], null == n2 || "boolean" == typeof n2 || (d$1(n2) ? n2.some(function(n3) {
    H$1(n3, l2);
  }) : l2.push(n2)), l2;
}
function L$1(n2, l2, u2, t2) {
  var i2, o2, r2, e2 = n2.key, f2 = n2.type, c2 = l2[u2], s2 = null != c2 && 0 == (2 & c2.__u);
  if (null === c2 && null == e2 || s2 && e2 == c2.key && f2 == c2.type) return u2;
  if (t2 > (s2 ? 1 : 0)) {
    for (i2 = u2 - 1, o2 = u2 + 1; i2 >= 0 || o2 < l2.length; ) if (null != (c2 = l2[r2 = i2 >= 0 ? i2-- : o2++]) && 0 == (2 & c2.__u) && e2 == c2.key && f2 == c2.type) return r2;
  }
  return -1;
}
function T$2(n2, l2, u2) {
  "-" == l2[0] ? n2.setProperty(l2, null == u2 ? "" : u2) : n2[l2] = null == u2 ? "" : "number" != typeof u2 || y$1.test(l2) ? u2 : u2 + "px";
}
function j$2(n2, l2, u2, t2, i2) {
  var o2, r2;
  n: if ("style" == l2) if ("string" == typeof u2) n2.style.cssText = u2;
  else {
    if ("string" == typeof t2 && (n2.style.cssText = t2 = ""), t2) for (l2 in t2) u2 && l2 in u2 || T$2(n2.style, l2, "");
    if (u2) for (l2 in u2) t2 && u2[l2] == t2[l2] || T$2(n2.style, l2, u2[l2]);
  }
  else if ("o" == l2[0] && "n" == l2[1]) o2 = l2 != (l2 = l2.replace(f$2, "$1")), r2 = l2.toLowerCase(), l2 = r2 in n2 || "onFocusOut" == l2 || "onFocusIn" == l2 ? r2.slice(2) : l2.slice(2), n2.l || (n2.l = {}), n2.l[l2 + o2] = u2, u2 ? t2 ? u2.u = t2.u : (u2.u = c$1, n2.addEventListener(l2, o2 ? a$1 : s$1, o2)) : n2.removeEventListener(l2, o2 ? a$1 : s$1, o2);
  else {
    if ("http://www.w3.org/2000/svg" == i2) l2 = l2.replace(/xlink(H|:h)/, "h").replace(/sName$/, "s");
    else if ("width" != l2 && "height" != l2 && "href" != l2 && "list" != l2 && "form" != l2 && "tabIndex" != l2 && "download" != l2 && "rowSpan" != l2 && "colSpan" != l2 && "role" != l2 && "popover" != l2 && l2 in n2) try {
      n2[l2] = null == u2 ? "" : u2;
      break n;
    } catch (n3) {
    }
    "function" == typeof u2 || (null == u2 || false === u2 && "-" != l2[4] ? n2.removeAttribute(l2) : n2.setAttribute(l2, "popover" == l2 && 1 == u2 ? "" : u2));
  }
}
function F$2(n2) {
  return function(u2) {
    if (this.l) {
      var t2 = this.l[u2.type + n2];
      if (null == u2.t) u2.t = c$1++;
      else if (u2.t < t2.u) return;
      return t2(l$2.event ? l$2.event(u2) : u2);
    }
  };
}
function O$1(n2, u2, t2, i2, o2, r2, e2, f2, c2, s2) {
  var a2, h2, p2, v2, y2, _2, m2, b2, S2, C2, M2, $2, P2, A2, H2, L2, T2, j2 = u2.type;
  if (void 0 !== u2.constructor) return null;
  128 & t2.__u && (c2 = !!(32 & t2.__u), r2 = [f2 = u2.__e = t2.__e]), (a2 = l$2.__b) && a2(u2);
  n: if ("function" == typeof j2) try {
    if (b2 = u2.props, S2 = "prototype" in j2 && j2.prototype.render, C2 = (a2 = j2.contextType) && i2[a2.__c], M2 = a2 ? C2 ? C2.props.value : a2.__ : i2, t2.__c ? m2 = (h2 = u2.__c = t2.__c).__ = h2.__E : (S2 ? u2.__c = h2 = new j2(b2, M2) : (u2.__c = h2 = new x$2(b2, M2), h2.constructor = j2, h2.render = E$1), C2 && C2.sub(h2), h2.state || (h2.state = {}), h2.__n = i2, p2 = h2.__d = true, h2.__h = [], h2._sb = []), S2 && null == h2.__s && (h2.__s = h2.state), S2 && null != j2.getDerivedStateFromProps && (h2.__s == h2.state && (h2.__s = w$2({}, h2.__s)), w$2(h2.__s, j2.getDerivedStateFromProps(b2, h2.__s))), v2 = h2.props, y2 = h2.state, h2.__v = u2, p2) S2 && null == j2.getDerivedStateFromProps && null != h2.componentWillMount && h2.componentWillMount(), S2 && null != h2.componentDidMount && h2.__h.push(h2.componentDidMount);
    else {
      if (S2 && null == j2.getDerivedStateFromProps && b2 !== v2 && null != h2.componentWillReceiveProps && h2.componentWillReceiveProps(b2, M2), u2.__v == t2.__v || !h2.__e && null != h2.shouldComponentUpdate && false === h2.shouldComponentUpdate(b2, h2.__s, M2)) {
        for (u2.__v != t2.__v && (h2.props = b2, h2.state = h2.__s, h2.__d = false), u2.__e = t2.__e, u2.__k = t2.__k, u2.__k.some(function(n3) {
          n3 && (n3.__ = u2);
        }), $2 = 0; $2 < h2._sb.length; $2++) h2.__h.push(h2._sb[$2]);
        h2._sb = [], h2.__h.length && e2.push(h2);
        break n;
      }
      null != h2.componentWillUpdate && h2.componentWillUpdate(b2, h2.__s, M2), S2 && null != h2.componentDidUpdate && h2.__h.push(function() {
        h2.componentDidUpdate(v2, y2, _2);
      });
    }
    if (h2.context = M2, h2.props = b2, h2.__P = n2, h2.__e = false, P2 = l$2.__r, A2 = 0, S2) {
      for (h2.state = h2.__s, h2.__d = false, P2 && P2(u2), a2 = h2.render(h2.props, h2.state, h2.context), H2 = 0; H2 < h2._sb.length; H2++) h2.__h.push(h2._sb[H2]);
      h2._sb = [];
    } else do {
      h2.__d = false, P2 && P2(u2), a2 = h2.render(h2.props, h2.state, h2.context), h2.state = h2.__s;
    } while (h2.__d && ++A2 < 25);
    h2.state = h2.__s, null != h2.getChildContext && (i2 = w$2(w$2({}, i2), h2.getChildContext())), S2 && !p2 && null != h2.getSnapshotBeforeUpdate && (_2 = h2.getSnapshotBeforeUpdate(v2, y2)), L2 = a2, null != a2 && a2.type === k$2 && null == a2.key && (L2 = V$1(a2.props.children)), f2 = I$1(n2, d$1(L2) ? L2 : [L2], u2, t2, i2, o2, r2, e2, f2, c2, s2), h2.base = u2.__e, u2.__u &= -161, h2.__h.length && e2.push(h2), m2 && (h2.__E = h2.__ = null);
  } catch (n3) {
    if (u2.__v = null, c2 || null != r2) if (n3.then) {
      for (u2.__u |= c2 ? 160 : 128; f2 && 8 == f2.nodeType && f2.nextSibling; ) f2 = f2.nextSibling;
      r2[r2.indexOf(f2)] = null, u2.__e = f2;
    } else {
      for (T2 = r2.length; T2--; ) g$2(r2[T2]);
      z$2(u2);
    }
    else u2.__e = t2.__e, u2.__k = t2.__k, n3.then || z$2(u2);
    l$2.__e(n3, u2, t2);
  }
  else null == r2 && u2.__v == t2.__v ? (u2.__k = t2.__k, u2.__e = t2.__e) : f2 = u2.__e = q$2(t2.__e, u2, t2, i2, o2, r2, e2, c2, s2);
  return (a2 = l$2.diffed) && a2(u2), 128 & u2.__u ? void 0 : f2;
}
function z$2(n2) {
  n2 && n2.__c && (n2.__c.__e = true), n2 && n2.__k && n2.__k.forEach(z$2);
}
function N$1(n2, u2, t2) {
  for (var i2 = 0; i2 < t2.length; i2++) B$2(t2[i2], t2[++i2], t2[++i2]);
  l$2.__c && l$2.__c(u2, n2), n2.some(function(u3) {
    try {
      n2 = u3.__h, u3.__h = [], n2.some(function(n3) {
        n3.call(u3);
      });
    } catch (n3) {
      l$2.__e(n3, u3.__v);
    }
  });
}
function V$1(n2) {
  return "object" != typeof n2 || null == n2 || n2.__b && n2.__b > 0 ? n2 : d$1(n2) ? n2.map(V$1) : w$2({}, n2);
}
function q$2(u2, t2, i2, o2, r2, e2, f2, c2, s2) {
  var a2, h2, v2, y2, w2, _2, m2, b2 = i2.props || p$1, k2 = t2.props, x2 = t2.type;
  if ("svg" == x2 ? r2 = "http://www.w3.org/2000/svg" : "math" == x2 ? r2 = "http://www.w3.org/1998/Math/MathML" : r2 || (r2 = "http://www.w3.org/1999/xhtml"), null != e2) {
    for (a2 = 0; a2 < e2.length; a2++) if ((w2 = e2[a2]) && "setAttribute" in w2 == !!x2 && (x2 ? w2.localName == x2 : 3 == w2.nodeType)) {
      u2 = w2, e2[a2] = null;
      break;
    }
  }
  if (null == u2) {
    if (null == x2) return document.createTextNode(k2);
    u2 = document.createElementNS(r2, x2, k2.is && k2), c2 && (l$2.__m && l$2.__m(t2, e2), c2 = false), e2 = null;
  }
  if (null == x2) b2 === k2 || c2 && u2.data == k2 || (u2.data = k2);
  else {
    if (e2 = e2 && n$1.call(u2.childNodes), !c2 && null != e2) for (b2 = {}, a2 = 0; a2 < u2.attributes.length; a2++) b2[(w2 = u2.attributes[a2]).name] = w2.value;
    for (a2 in b2) if (w2 = b2[a2], "children" == a2) ;
    else if ("dangerouslySetInnerHTML" == a2) v2 = w2;
    else if (!(a2 in k2)) {
      if ("value" == a2 && "defaultValue" in k2 || "checked" == a2 && "defaultChecked" in k2) continue;
      j$2(u2, a2, null, w2, r2);
    }
    for (a2 in k2) w2 = k2[a2], "children" == a2 ? y2 = w2 : "dangerouslySetInnerHTML" == a2 ? h2 = w2 : "value" == a2 ? _2 = w2 : "checked" == a2 ? m2 = w2 : c2 && "function" != typeof w2 || b2[a2] === w2 || j$2(u2, a2, w2, b2[a2], r2);
    if (h2) c2 || v2 && (h2.__html == v2.__html || h2.__html == u2.innerHTML) || (u2.innerHTML = h2.__html), t2.__k = [];
    else if (v2 && (u2.innerHTML = ""), I$1("template" == t2.type ? u2.content : u2, d$1(y2) ? y2 : [y2], t2, i2, o2, "foreignObject" == x2 ? "http://www.w3.org/1999/xhtml" : r2, e2, f2, e2 ? e2[0] : i2.__k && S(i2, 0), c2, s2), null != e2) for (a2 = e2.length; a2--; ) g$2(e2[a2]);
    c2 || (a2 = "value", "progress" == x2 && null == _2 ? u2.removeAttribute("value") : null != _2 && (_2 !== u2[a2] || "progress" == x2 && !_2 || "option" == x2 && _2 != b2[a2]) && j$2(u2, a2, _2, b2[a2], r2), a2 = "checked", null != m2 && m2 != u2[a2] && j$2(u2, a2, m2, b2[a2], r2));
  }
  return u2;
}
function B$2(n2, u2, t2) {
  try {
    if ("function" == typeof n2) {
      var i2 = "function" == typeof n2.__u;
      i2 && n2.__u(), i2 && null == u2 || (n2.__u = n2(u2));
    } else n2.current = u2;
  } catch (n3) {
    l$2.__e(n3, t2);
  }
}
function D$2(n2, u2, t2) {
  var i2, o2;
  if (l$2.unmount && l$2.unmount(n2), (i2 = n2.ref) && (i2.current && i2.current != n2.__e || B$2(i2, null, u2)), null != (i2 = n2.__c)) {
    if (i2.componentWillUnmount) try {
      i2.componentWillUnmount();
    } catch (n3) {
      l$2.__e(n3, u2);
    }
    i2.base = i2.__P = null;
  }
  if (i2 = n2.__k) for (o2 = 0; o2 < i2.length; o2++) i2[o2] && D$2(i2[o2], u2, t2 || "function" != typeof n2.type);
  t2 || g$2(n2.__e), n2.__c = n2.__ = n2.__e = void 0;
}
function E$1(n2, l2, u2) {
  return this.constructor(n2, u2);
}
function G$1(u2, t2, i2) {
  var o2, r2, e2, f2;
  t2 == document && (t2 = document.documentElement), l$2.__ && l$2.__(u2, t2), r2 = (o2 = "function" == typeof i2) ? null : i2 && i2.__k || t2.__k, e2 = [], f2 = [], O$1(t2, u2 = (!o2 && i2 || t2).__k = _$1(k$2, null, [u2]), r2 || p$1, p$1, t2.namespaceURI, !o2 && i2 ? [i2] : r2 ? null : t2.firstChild ? n$1.call(t2.childNodes) : null, e2, !o2 && i2 ? i2 : r2 ? r2.__e : t2.firstChild, o2, f2), N$1(e2, u2, f2);
}
function J$1(n2, l2) {
  G$1(n2, l2, J$1);
}
function K$1(l2, u2, t2) {
  var i2, o2, r2, e2, f2 = w$2({}, l2.props);
  for (r2 in l2.type && l2.type.defaultProps && (e2 = l2.type.defaultProps), u2) "key" == r2 ? i2 = u2[r2] : "ref" == r2 ? o2 = u2[r2] : f2[r2] = void 0 === u2[r2] && null != e2 ? e2[r2] : u2[r2];
  return arguments.length > 2 && (f2.children = arguments.length > 3 ? n$1.call(arguments, 2) : t2), m$1(l2.type, f2, i2 || l2.key, o2 || l2.ref, null);
}
function Q$1(n2) {
  function l2(n3) {
    var u2, t2;
    return this.getChildContext || (u2 = /* @__PURE__ */ new Set(), (t2 = {})[l2.__c] = this, this.getChildContext = function() {
      return t2;
    }, this.componentWillUnmount = function() {
      u2 = null;
    }, this.shouldComponentUpdate = function(n4) {
      this.props.value != n4.value && u2.forEach(function(n5) {
        n5.__e = true, M$1(n5);
      });
    }, this.sub = function(n4) {
      u2.add(n4);
      var l3 = n4.componentWillUnmount;
      n4.componentWillUnmount = function() {
        u2 && u2.delete(n4), l3 && l3.call(n4);
      };
    }), n3.children;
  }
  return l2.__c = "__cC" + h$1++, l2.__ = n2, l2.Provider = l2.__l = (l2.Consumer = function(n3, l3) {
    return n3.children(l3);
  }).contextType = l2, l2;
}
n$1 = v$1.slice, l$2 = { __e: function(n2, l2, u2, t2) {
  for (var i2, o2, r2; l2 = l2.__; ) if ((i2 = l2.__c) && !i2.__) try {
    if ((o2 = i2.constructor) && null != o2.getDerivedStateFromError && (i2.setState(o2.getDerivedStateFromError(n2)), r2 = i2.__d), null != i2.componentDidCatch && (i2.componentDidCatch(n2, t2 || {}), r2 = i2.__d), r2) return i2.__E = i2;
  } catch (l3) {
    n2 = l3;
  }
  throw n2;
} }, u$2 = 0, x$2.prototype.setState = function(n2, l2) {
  var u2;
  u2 = null != this.__s && this.__s != this.state ? this.__s : this.__s = w$2({}, this.state), "function" == typeof n2 && (n2 = n2(w$2({}, u2), this.props)), n2 && w$2(u2, n2), null != n2 && this.__v && (l2 && this._sb.push(l2), M$1(this));
}, x$2.prototype.forceUpdate = function(n2) {
  this.__v && (this.__e = true, n2 && this.__h.push(n2), M$1(this));
}, x$2.prototype.render = k$2, i$1 = [], r$2 = "function" == typeof Promise ? Promise.prototype.then.bind(Promise.resolve()) : setTimeout, e$2 = function(n2, l2) {
  return n2.__v.__b - l2.__v.__b;
}, $$1.__r = 0, f$2 = /(PointerCapture)$|Capture$/i, c$1 = 0, s$1 = F$2(false), a$1 = F$2(true), h$1 = 0;
var f$1 = 0;
function u$1(e2, t2, n2, o2, i2, u2) {
  t2 || (t2 = {});
  var a2, c2, p2 = t2;
  if ("ref" in p2) for (c2 in p2 = {}, t2) "ref" == c2 ? a2 = t2[c2] : p2[c2] = t2[c2];
  var l2 = { type: e2, props: p2, key: n2, ref: a2, __k: null, __: null, __b: 0, __e: null, __c: null, constructor: void 0, __v: --f$1, __i: -1, __u: 0, __source: i2, __self: u2 };
  if ("function" == typeof e2 && (a2 = e2.defaultProps)) for (c2 in a2) void 0 === p2[c2] && (p2[c2] = a2[c2]);
  return l$2.vnode && l$2.vnode(l2), l2;
}
var t$1, r$1, u, i, o$1 = 0, f = [], c = l$2, e$1 = c.__b, a = c.__r, v = c.diffed, l$1 = c.__c, m = c.unmount, s = c.__;
function p(n2, t2) {
  c.__h && c.__h(r$1, n2, o$1 || t2), o$1 = 0;
  var u2 = r$1.__H || (r$1.__H = { __: [], __h: [] });
  return n2 >= u2.__.length && u2.__.push({}), u2.__[n2];
}
function d(n2) {
  return o$1 = 1, h(D$1, n2);
}
function h(n2, u2, i2) {
  var o2 = p(t$1++, 2);
  if (o2.t = n2, !o2.__c && (o2.__ = [i2 ? i2(u2) : D$1(void 0, u2), function(n3) {
    var t2 = o2.__N ? o2.__N[0] : o2.__[0], r2 = o2.t(t2, n3);
    t2 !== r2 && (o2.__N = [r2, o2.__[1]], o2.__c.setState({}));
  }], o2.__c = r$1, !r$1.__f)) {
    var f2 = function(n3, t2, r2) {
      if (!o2.__c.__H) return true;
      var u3 = o2.__c.__H.__.filter(function(n4) {
        return !!n4.__c;
      });
      if (u3.every(function(n4) {
        return !n4.__N;
      })) return !c2 || c2.call(this, n3, t2, r2);
      var i3 = o2.__c.props !== n3;
      return u3.forEach(function(n4) {
        if (n4.__N) {
          var t3 = n4.__[0];
          n4.__ = n4.__N, n4.__N = void 0, t3 !== n4.__[0] && (i3 = true);
        }
      }), c2 && c2.call(this, n3, t2, r2) || i3;
    };
    r$1.__f = true;
    var c2 = r$1.shouldComponentUpdate, e2 = r$1.componentWillUpdate;
    r$1.componentWillUpdate = function(n3, t2, r2) {
      if (this.__e) {
        var u3 = c2;
        c2 = void 0, f2(n3, t2, r2), c2 = u3;
      }
      e2 && e2.call(this, n3, t2, r2);
    }, r$1.shouldComponentUpdate = f2;
  }
  return o2.__N || o2.__;
}
function y(n2, u2) {
  var i2 = p(t$1++, 3);
  !c.__s && C$1(i2.__H, u2) && (i2.__ = n2, i2.u = u2, r$1.__H.__h.push(i2));
}
function _(n2, u2) {
  var i2 = p(t$1++, 4);
  !c.__s && C$1(i2.__H, u2) && (i2.__ = n2, i2.u = u2, r$1.__h.push(i2));
}
function A$1(n2) {
  return o$1 = 5, T$1(function() {
    return { current: n2 };
  }, []);
}
function F$1(n2, t2, r2) {
  o$1 = 6, _(function() {
    if ("function" == typeof n2) {
      var r3 = n2(t2());
      return function() {
        n2(null), r3 && "function" == typeof r3 && r3();
      };
    }
    if (n2) return n2.current = t2(), function() {
      return n2.current = null;
    };
  }, null == r2 ? r2 : r2.concat(n2));
}
function T$1(n2, r2) {
  var u2 = p(t$1++, 7);
  return C$1(u2.__H, r2) && (u2.__ = n2(), u2.__H = r2, u2.__h = n2), u2.__;
}
function q$1(n2, t2) {
  return o$1 = 8, T$1(function() {
    return n2;
  }, t2);
}
function x$1(n2) {
  var u2 = r$1.context[n2.__c], i2 = p(t$1++, 9);
  return i2.c = n2, u2 ? (null == i2.__ && (i2.__ = true, u2.sub(r$1)), u2.props.value) : n2.__;
}
function P$1(n2, t2) {
  c.useDebugValue && c.useDebugValue(t2 ? t2(n2) : n2);
}
function b(n2) {
  var u2 = p(t$1++, 10), i2 = d();
  return u2.__ = n2, r$1.componentDidCatch || (r$1.componentDidCatch = function(n3, t2) {
    u2.__ && u2.__(n3, t2), i2[1](n3);
  }), [i2[0], function() {
    i2[1](void 0);
  }];
}
function g$1() {
  var n2 = p(t$1++, 11);
  if (!n2.__) {
    for (var u2 = r$1.__v; null !== u2 && !u2.__m && null !== u2.__; ) u2 = u2.__;
    var i2 = u2.__m || (u2.__m = [0, 0]);
    n2.__ = "P" + i2[0] + "-" + i2[1]++;
  }
  return n2.__;
}
function j$1() {
  for (var n2; n2 = f.shift(); ) if (n2.__P && n2.__H) try {
    n2.__H.__h.forEach(z$1), n2.__H.__h.forEach(B$1), n2.__H.__h = [];
  } catch (t2) {
    n2.__H.__h = [], c.__e(t2, n2.__v);
  }
}
c.__b = function(n2) {
  r$1 = null, e$1 && e$1(n2);
}, c.__ = function(n2, t2) {
  n2 && t2.__k && t2.__k.__m && (n2.__m = t2.__k.__m), s && s(n2, t2);
}, c.__r = function(n2) {
  a && a(n2), t$1 = 0;
  var i2 = (r$1 = n2.__c).__H;
  i2 && (u === r$1 ? (i2.__h = [], r$1.__h = [], i2.__.forEach(function(n3) {
    n3.__N && (n3.__ = n3.__N), n3.u = n3.__N = void 0;
  })) : (i2.__h.forEach(z$1), i2.__h.forEach(B$1), i2.__h = [], t$1 = 0)), u = r$1;
}, c.diffed = function(n2) {
  v && v(n2);
  var t2 = n2.__c;
  t2 && t2.__H && (t2.__H.__h.length && (1 !== f.push(t2) && i === c.requestAnimationFrame || ((i = c.requestAnimationFrame) || w$1)(j$1)), t2.__H.__.forEach(function(n3) {
    n3.u && (n3.__H = n3.u), n3.u = void 0;
  })), u = r$1 = null;
}, c.__c = function(n2, t2) {
  t2.some(function(n3) {
    try {
      n3.__h.forEach(z$1), n3.__h = n3.__h.filter(function(n4) {
        return !n4.__ || B$1(n4);
      });
    } catch (r2) {
      t2.some(function(n4) {
        n4.__h && (n4.__h = []);
      }), t2 = [], c.__e(r2, n3.__v);
    }
  }), l$1 && l$1(n2, t2);
}, c.unmount = function(n2) {
  m && m(n2);
  var t2, r2 = n2.__c;
  r2 && r2.__H && (r2.__H.__.forEach(function(n3) {
    try {
      z$1(n3);
    } catch (n4) {
      t2 = n4;
    }
  }), r2.__H = void 0, t2 && c.__e(t2, r2.__v));
};
var k$1 = "function" == typeof requestAnimationFrame;
function w$1(n2) {
  var t2, r2 = function() {
    clearTimeout(u2), k$1 && cancelAnimationFrame(t2), setTimeout(n2);
  }, u2 = setTimeout(r2, 35);
  k$1 && (t2 = requestAnimationFrame(r2));
}
function z$1(n2) {
  var t2 = r$1, u2 = n2.__c;
  "function" == typeof u2 && (n2.__c = void 0, u2()), r$1 = t2;
}
function B$1(n2) {
  var t2 = r$1;
  n2.__c = n2.__(), r$1 = t2;
}
function C$1(n2, t2) {
  return !n2 || n2.length !== t2.length || t2.some(function(t3, r2) {
    return t3 !== n2[r2];
  });
}
function D$1(n2, t2) {
  return "function" == typeof t2 ? t2(n2) : t2;
}
function Icon({
  icon,
  className = ""
}) {
  const ref = A$1(null);
  y(() => {
    if (!ref.current) return;
    require$$0$1.setIcon(ref.current, icon);
  }, [icon]);
  return /* @__PURE__ */ u$1("div", { className: "w-4.5 h-4.5 " + className, ref });
}
const OPEN_STATUSES = [
  "none",
  "planned",
  "in-progress",
  "review"
];
const CLOSED_STATUSES = ["abandoned", "closed"];
const taskStatusFormat = {
  none: [" "],
  planned: ["?"],
  "in-progress": [">", "/"],
  review: ["="],
  abandoned: ["-"],
  closed: ["x", "X"]
};
function toTaskStatusMarker(input) {
  return taskStatusFormat[input][0];
}
function parseTaskStatus(input) {
  return Object.keys(taskStatusFormat).map((key) => key).find((key) => key === input) ?? null;
}
function extractTaskDetails(task) {
  return {
    title: task.title,
    description: task.description,
    marker: task.marker,
    status: task.status,
    priority: task.priority,
    project: task.project,
    section: task.section,
    assignee: task.assignee,
    dueDate: task.dueDate,
    createdAt: task.createdAt,
    updatedAt: task.updatedAt,
    completedAt: task.completedAt,
    subtasks: task.subtasks,
    dependencies: task.dependencies,
    tags: task.tags
  };
}
class MetadataPillWidget extends view.WidgetType {
  key;
  value;
  constructor(key, value, _2) {
    super();
    this.key = key;
    this.value = value;
  }
  toDOM(view2) {
    const root = view2.dom.ownerDocument.createElement("div");
    let span;
    const text2 = `${this.key}:${this.value}`;
    G$1(
      /* @__PURE__ */ u$1(
        "span",
        {
          className: "\n        metadata-pill inline-flex items-center\n        h-lh\n        bg-blue-100 text-blue-800 px-2 rounded-lg text-sm mx-1",
          children: [
            /* @__PURE__ */ u$1("span", { children: text2 }),
            /* @__PURE__ */ u$1(
              "span",
              {
                className: "ml-1 text-blue-600 hover:text-blue-800 text-xs touchable cursor-pointer",
                onClick: (e2) => {
                  e2.stopPropagation();
                  const start = view2.posAtDOM(span);
                  const end = start + text2.length;
                  view2.dispatch(
                    view2.state.update({
                      changes: { from: start, to: end },
                      userEvent: "remove.metadata"
                    })
                  );
                },
                children: "Ã—"
              }
            )
          ]
        }
      ),
      root
    );
    span = root.firstElementChild;
    span.remove();
    return span;
  }
  eq(other) {
    return other.key === this.key && other.value === this.value;
  }
}
class PillsPlugin {
  decorations;
  constructor(view2) {
    this.decorations = this.generate(view2);
  }
  generate(view$1) {
    const doc = view$1.state.doc;
    const text2 = doc.toString();
    const decorations = [];
    let match;
    let regex = view$1.hasFocus ? /\b(\w+):(\S+)(?=\s)/g : /\b(\w+):(\S+)(?=\s|$)/g;
    while ((match = regex.exec(text2)) !== null) {
      const start = match.index;
      const end = match.index + match[0].length;
      const key = match[1];
      const value = match[2];
      decorations.push(
        view.Decoration.replace({
          widget: new MetadataPillWidget(key, value, view$1),
          key: `metadata-pill-${start}-${end}`
        }).range(start, end)
      );
    }
    return view.Decoration.set(decorations);
  }
  update(update) {
    if (update.docChanged || update.viewportChanged || update.focusChanged)
      this.decorations = this.generate(update.view);
  }
}
function searchToFilters(newSearchTerm) {
  const filters = {
    statuses: [],
    keywords: [],
    files: []
  };
  const tokens = newSearchTerm.match(/\S+/g) || [];
  filters.keywords = tokens.filter((token) => !/\w:/.test(token));
  for (const token of tokens.filter((token2) => /\w:/.test(token2))) {
    const [key, value] = token.split(":", 2);
    switch (key) {
      case "is":
        switch (value) {
          case "open":
            filters.statuses = [...filters.statuses, ...OPEN_STATUSES];
            break;
          case "closed":
            filters.statuses = [...filters.statuses, ...CLOSED_STATUSES];
            break;
        }
        break;
      case "status": {
        const status = parseTaskStatus(value);
        if (status) {
          filters.statuses = [...filters.statuses, status];
        }
        break;
      }
      case "file":
        if (value) {
          filters.files = [...filters.files, value];
        }
        break;
    }
  }
  return filters;
}
function SearchInput({
  value,
  onChangeFilters,
  placeholder = "Search tasks..."
}) {
  const rootRef = A$1(null);
  const ref = A$1(null);
  const viewRef = A$1(null);
  const [focused, setFocused] = d(false);
  const [xcoord, setXcoord] = d(0);
  const [showSuggestions, setShowSuggestions] = d(false);
  const focusEffectHandler = q$1(
    (state2, focusing) => {
      const cursorOffset = state2.selection.main.head;
      const localCoords = viewRef.current?.coordsAtPos(cursorOffset);
      const viewCoords = rootRef.current?.getBoundingClientRect();
      if (localCoords && viewCoords) {
        setXcoord(localCoords.left - viewCoords.left);
      }
      setFocused(focusing);
      viewRef.current?.dispatch({});
      return null;
    },
    []
  );
  const handleUpdate = q$1(
    (update) => {
      if (update.docChanged) {
        onChangeFilters(searchToFilters(update.state.doc.toString()));
        const cursorOffset = update.state.selection.main.head;
        const docText = update.state.doc.toString();
        if (cursorOffset > 0 && docText[cursorOffset - 1].trim() !== "") {
          setShowSuggestions(true);
        }
      }
      if (update.selectionSet) {
        const cursorOffset = update.state.selection.main.head;
        const localCoords = update.view.coordsAtPos(cursorOffset);
        const viewCoords = rootRef.current?.getBoundingClientRect();
        if (localCoords && viewCoords) {
          setXcoord(localCoords.left - viewCoords.left);
        }
      }
    },
    [onChangeFilters]
  );
  y(() => {
    if (!ref.current) return;
    const extensions = [
      view.placeholder(placeholder),
      view.ViewPlugin.fromClass(PillsPlugin, {
        decorations: (v2) => v2.decorations
      }),
      view.keymap.of([
        { key: "Enter", preventDefault: true, run: () => false },
        { key: "ArrowUp", preventDefault: true, run: () => false },
        {
          key: "ArrowDown",
          preventDefault: true,
          run: () => {
            setShowSuggestions(true);
            return false;
          }
        },
        {
          key: "Escape",
          stopPropagation: true,
          preventDefault: true,
          run: () => {
            viewRef.current?.dom.blur();
            return true;
          }
        }
      ]),
      view.EditorView.theme({
        ".cm-content": {
          fontFamily: "var(--font-sans), Arial, sans-serif",
          caretColor: "var(--text-normal)"
        }
      }),
      view.EditorView.updateListener.of(handleUpdate),
      view.EditorView.focusChangeEffect.of(focusEffectHandler)
    ];
    const view$1 = new view.EditorView({
      parent: ref.current,
      state: state.EditorState.create({
        doc: value,
        extensions: [...extensions]
      })
    });
    viewRef.current = view$1;
    view$1.focus();
    view$1.dispatch({
      selection: {
        anchor: view$1.state.doc.length,
        head: view$1.state.doc.length
      }
    });
    return () => {
      viewRef.current = null;
      view$1.destroy();
    };
  }, []);
  return /* @__PURE__ */ u$1("div", { className: "relative", ref: rootRef, children: /* @__PURE__ */ u$1(
    "div",
    {
      className: "\n        w-full h-10 rounded-lg\n        border-solid border-(--background-modifier-border) border-width-(--input-border-width)\n        px-3 py-2 shadow-sm focus-within:shadow-outline\n        flex flex-row items-center\n        ",
      style: {
        boxShadow: "0 0 0 var(--input-border-width-focus) var(--background-modifier-border-focus)"
      },
      children: [
        /* @__PURE__ */ u$1(Icon, { icon: "search", className: "text-(--search-clear-button-color)" }),
        /* @__PURE__ */ u$1("div", { ref, className: "grow ml-1" }),
        /* @__PURE__ */ u$1(
          "div",
          {
            className: [
              "text-(--search-clear-button-color) hover:text-(--text-normal) ml-1",
              value.length ? "" : "hidden"
            ].join(" "),
            onClick: () => viewRef.current?.dispatch({
              changes: {
                from: 0,
                to: viewRef.current?.state.doc.toString().length,
                insert: ""
              }
            }),
            children: /* @__PURE__ */ u$1(Icon, { icon: "tasktrack-search-clear" })
          }
        ),
        focused && showSuggestions && /* @__PURE__ */ u$1(SearchBarSuggest, { left: xcoord })
      ]
    }
  ) });
}
function SearchBarSuggest({ left }) {
  const [collapsed, setCollapsed] = d(true);
  const suggestions = [
    {
      label: "path:",
      description: "match path of the file"
    },
    {
      label: "file:",
      description: "match file name"
    },
    {
      label: "tag:",
      description: "search for tags"
    },
    {
      label: "is:open, is:closed",
      description: "match completion state"
    },
    {
      label: "status:",
      description: "search by status"
    },
    {
      label: "priority:",
      description: "search by priority"
    },
    {
      label: "note:",
      description: "search by notes content"
    }
  ];
  const currentActiveLabel = "path:";
  return /* @__PURE__ */ u$1(
    "div",
    {
      className: "suggestion-container mod-search-suggestion absolute top-11 w-75 shadow-lg!",
      style: {
        left: left - 14
      },
      children: /* @__PURE__ */ u$1("div", { className: "overflow-y-auto p-(--size-2-3)", children: [
        /* @__PURE__ */ u$1("div", { className: "suggestion-item mod-complex search-suggest-item mod-group", children: [
          /* @__PURE__ */ u$1("div", { className: "suggestion-content", children: /* @__PURE__ */ u$1("div", { className: "suggestion-title list-item-part mod-extended", children: /* @__PURE__ */ u$1("span", { children: "Search options" }) }) }),
          /* @__PURE__ */ u$1("div", { className: "suggestion-aux", children: /* @__PURE__ */ u$1(
            "div",
            {
              className: "list-item-part search-suggest-icon clickable-icon",
              "aria-label": "Expand options",
              onMouseDown: (e2) => {
                setCollapsed(!collapsed);
                e2.preventDefault();
              },
              children: /* @__PURE__ */ u$1(
                Icon,
                {
                  icon: collapsed ? "circle-chevron-down" : "circle-chevron-up"
                }
              )
            }
          ) })
        ] }),
        !collapsed && /* @__PURE__ */ u$1(k$2, { children: suggestions.map((suggestion, index) => /* @__PURE__ */ u$1(
          "div",
          {
            className: `suggestion-item mod-complex search-suggest-item ${suggestion.label === currentActiveLabel ? "is-selected" : ""}`,
            children: [
              /* @__PURE__ */ u$1("div", { className: "suggestion-content", children: /* @__PURE__ */ u$1("div", { className: "suggestion-title", children: [
                /* @__PURE__ */ u$1("span", { children: suggestion.label }),
                /* @__PURE__ */ u$1("span", { className: "search-suggest-info-text", children: suggestion.description })
              ] }) }),
              /* @__PURE__ */ u$1("div", { className: "suggestion-aux" })
            ]
          },
          index
        )) })
      ] })
    }
  );
}
function VerticalTabContentContainer({
  children,
  className = ""
}) {
  return /* @__PURE__ */ u$1("div", { className: "vertical-tab-content-container " + className, children });
}
function around(obj, factories) {
  const removers = Object.keys(factories).map((key) => around1(obj, key, factories[key]));
  return removers.length === 1 ? removers[0] : function() {
    removers.forEach((r2) => r2());
  };
}
function around1(obj, method, createWrapper) {
  const inherited = obj[method], hadOwn = obj.hasOwnProperty(method), original = hadOwn ? inherited : function() {
    return Object.getPrototypeOf(obj)[method].apply(this, arguments);
  };
  let current = createWrapper(original);
  if (inherited)
    Object.setPrototypeOf(current, inherited);
  Object.setPrototypeOf(wrapper, current);
  obj[method] = wrapper;
  return remove2;
  function wrapper(...args) {
    if (current === original && obj[method] === wrapper)
      remove2();
    return current.apply(this, args);
  }
  function remove2() {
    if (obj[method] === wrapper) {
      if (hadOwn)
        obj[method] = original;
      else
        delete obj[method];
    }
    if (current === original)
      return;
    current = original;
    Object.setPrototypeOf(wrapper, inherited || Function);
  }
}
function createEmbeddableMarkdownEditor(app, container, options) {
  const EditorClass = resolveEditorPrototype(app);
  return new EmbeddableMarkdownEditor(app, EditorClass, container, options);
}
function resolveEditorPrototype(app) {
  const widgetEditorView = app.embedRegistry.embedByExtension.md(
    {
      app,
      containerEl: app.dom.appContainerEl.ownerDocument.createElement("div")
    },
    null,
    ""
  );
  widgetEditorView.editable = true;
  widgetEditorView.showEditor();
  const editModePrototype = Object.getPrototypeOf(
    widgetEditorView.editMode
  );
  const MarkdownEditor2 = Object.getPrototypeOf(editModePrototype);
  widgetEditorView.unload();
  return MarkdownEditor2.constructor;
}
const defaultProperties = {
  cursorLocation: { anchor: 0, head: 0 },
  value: "",
  singleLine: false,
  cssText: "",
  placeholder: "",
  onEnter: () => false,
  onEscape: () => {
  },
  onSubmit: () => {
  },
  // NOTE: Blur takes precedence over Escape (this can be changed)
  onBlur: () => {
  },
  onPaste: () => {
  },
  onChange: () => {
  }
};
class EmbeddableMarkdownEditor {
  options;
  initial_value;
  scope;
  editor;
  // Expose commonly accessed properties
  get editorEl() {
    return this.editor.editorEl;
  }
  get containerEl() {
    return this.editor.containerEl;
  }
  get activeCM() {
    return this.editor.activeCM;
  }
  get app() {
    return this.editor.app;
  }
  get owner() {
    return this.editor.owner;
  }
  get _loaded() {
    return this.editor._loaded;
  }
  /**
   * Construct the editor
   * @param app - Reference to App instance
   * @param EditorClass - The editor class constructor
   * @param container - Container element to add the editor to
   * @param options - Options for controlling the initial state of the editor
   */
  constructor(app, EditorClass, container, options) {
    this.options = { ...defaultProperties, ...options };
    this.initial_value = this.options.value;
    this.scope = new require$$0$1.Scope(app.scope);
    this.scope.register(["Mod"], "Enter", () => true);
    const self2 = this;
    const uninstaller = around(EditorClass.prototype, {
      buildLocalExtensions: (originalMethod) => function() {
        const extensions = originalMethod.call(this);
        if (this === self2.editor) {
          if (self2.options.placeholder) {
            extensions.push(view.placeholder(self2.options.placeholder));
          }
          extensions.push(
            view.EditorView.domEventHandlers({
              paste: (event) => {
                self2.options.onPaste(event, self2);
              },
              blur: () => {
                app.keymap.popScope(self2.scope);
                if (self2.options.onBlur) {
                  self2.options.onBlur(self2);
                }
              },
              focusin: () => {
                app.keymap.pushScope(self2.scope);
                app.workspace.activeEditor = self2.owner;
              }
            })
          );
          const keyBindings = [
            {
              key: "Enter",
              run: () => {
                return self2.options.onEnter(self2, false, false);
              },
              shift: () => self2.options.onEnter(self2, false, true)
            },
            {
              key: "Mod-Enter",
              run: () => self2.options.onEnter(self2, true, false),
              shift: () => self2.options.onEnter(self2, true, true)
            },
            {
              key: "Escape",
              run: () => {
                self2.options.onEscape(self2);
                return true;
              },
              preventDefault: true
            }
          ];
          if (self2.options.singleLine) {
            keyBindings[0] = {
              key: "Enter",
              run: () => {
                return self2.options.onEnter(self2, false, false);
              },
              shift: () => {
                return self2.options.onEnter(self2, false, true);
              }
            };
          }
          extensions.push(state.Prec.highest(view.keymap.of(keyBindings)));
        }
        return extensions;
      }
    });
    this.editor = new EditorClass(app, container, {
      app,
      // This mocks the MarkdownView functions, required for proper scrolling
      onMarkdownScroll: () => {
      },
      getMode: () => "source"
    });
    this.register(uninstaller);
    if (this.owner) {
      this.owner.editMode = this;
      this.owner.editor = this.editor.editor;
    }
    this.set(options.value || "", false);
    this.register(
      around(app.workspace, {
        setActiveLeaf: (oldMethod) => (leaf, ...args) => {
          if (!this.activeCM?.hasFocus) {
            oldMethod.call(app.workspace, leaf, ...args);
          }
        }
      })
    );
    if (options.cssText && this.editorEl) {
      this.editorEl.style.cssText = options.cssText;
    }
    if (options.cursorLocation && this.editor.editor?.cm) {
      this.editor.editor.cm.dispatch({
        selection: state.EditorSelection.range(
          options.cursorLocation.anchor,
          options.cursorLocation.head
        )
      });
    }
    const originalOnUpdate = this.editor.onUpdate.bind(this.editor);
    this.editor.onUpdate = ((update, changed) => {
      originalOnUpdate(update, changed);
      if (changed) this.options.onChange(update, this);
    });
  }
  // Get the current editor value
  get value() {
    return this.editor.editor?.cm?.state.doc.toString() || "";
  }
  // Set content in the editor
  set(content, focus = false) {
    this.editor.set(content, focus);
  }
  // Register cleanup callback
  register(cb) {
    this.editor.register(cb);
  }
  // Clean up method that ensures proper destruction
  destroy() {
    if (this._loaded && typeof this.editor.unload === "function") {
      this.editor.unload();
    }
    this.app.keymap.popScope(this.scope);
    this.app.workspace.activeEditor = null;
    this.containerEl.empty();
    this.editor.destroy();
  }
  // Unload handler
  onunload() {
    if (typeof this.editor.onunload === "function") {
      this.editor.onunload();
    }
    this.destroy();
  }
  // Required method for MarkdownScrollableEditView compatibility
  unload() {
    if (typeof this.editor.unload === "function") {
      this.editor.unload();
    }
  }
}
const Logger = {
  log(...args) {
    console.log(...args);
  },
  info(...args) {
    console.info(...args);
  },
  warn(...args) {
    console.warn(...args);
  },
  error(...args) {
    console.error(...args);
  },
  debug(...args) {
    console.debug(...args);
  },
  trace(...args) {
    console.trace(...args);
  },
  assert(condition, ...args) {
    console.assert(condition, ...args);
  }
};
const ExternalChange = state.Annotation.define();
function MarkdownEditor({
  app,
  value,
  onChange,
  cssText
}) {
  const ref = A$1(null);
  const editorRef = A$1(null);
  y(() => {
    if (!ref.current) return;
    ref.current.empty();
    editorRef.current = createEmbeddableMarkdownEditor(app, ref.current, {
      value: value.value,
      onChange,
      cssText
    });
  }, [app, onChange, cssText]);
  y(() => {
    if (!editorRef.current) return;
    const view2 = editorRef.current.activeCM;
    if (view2 && value.source == "react" && value.value !== view2.state.doc.toString()) {
      Logger.info("[TaskTrack][MarkdownEditor.tsx:30]", "HARD REFRESH");
      view2.dispatch({
        changes: {
          from: 0,
          to: view2.state.doc.toString().length,
          insert: value.value
        },
        annotations: [ExternalChange.of(true)]
      });
    }
  }, [value]);
  return /* @__PURE__ */ u$1("div", { ref, className: "flex flex-col grow" });
}
function PriorityBadge({ priority }) {
  const priorityColors = {
    wish: { color: "var(--color-cyan)", label: "Wish" },
    low: { color: "var(--color-blue)", label: "Low" },
    none: { color: "gray", label: "None" },
    medium: { color: "var(--color-green)", label: "Medium" },
    high: { color: "var(--color-yellow)", label: "High" },
    critical: { color: "var(--color-red)", label: "Critical" }
  };
  return /* @__PURE__ */ u$1(
    "span",
    {
      className: "text-xs px-2 py-1 rounded-full text-black",
      style: { backgroundColor: priorityColors[priority].color },
      children: priorityColors[priority].label
    }
  );
}
const PluginContext = Q$1(void 0);
function PluginProvider({
  plugin,
  children
}) {
  return /* @__PURE__ */ u$1(PluginContext.Provider, { value: { plugin }, children });
}
function usePlugin() {
  const context = x$1(PluginContext);
  if (context === void 0) {
    throw new Error("usePlugin must be used within a PluginProvider");
  }
  return context.plugin;
}
function _objectWithoutPropertiesLoose(r2, e2) {
  if (null == r2) return {};
  var t2 = {};
  for (var n2 in r2) if ({}.hasOwnProperty.call(r2, n2)) {
    if (-1 !== e2.indexOf(n2)) continue;
    t2[n2] = r2[n2];
  }
  return t2;
}
function _extends() {
  return _extends = Object.assign ? Object.assign.bind() : function(n2) {
    for (var e2 = 1; e2 < arguments.length; e2++) {
      var t2 = arguments[e2];
      for (var r2 in t2) ({}).hasOwnProperty.call(t2, r2) && (n2[r2] = t2[r2]);
    }
    return n2;
  }, _extends.apply(null, arguments);
}
function _setPrototypeOf(t2, e2) {
  return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t3, e3) {
    return t3.__proto__ = e3, t3;
  }, _setPrototypeOf(t2, e2);
}
function _inheritsLoose(t2, o2) {
  t2.prototype = Object.create(o2.prototype), t2.prototype.constructor = t2, _setPrototypeOf(t2, o2);
}
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function getDefaultExportFromCjs(x2) {
  return x2 && x2.__esModule && Object.prototype.hasOwnProperty.call(x2, "default") ? x2["default"] : x2;
}
function getAugmentedNamespace(n2) {
  if (Object.prototype.hasOwnProperty.call(n2, "__esModule")) return n2;
  var f2 = n2.default;
  if (typeof f2 == "function") {
    var a2 = function a3() {
      var isInstance = false;
      try {
        isInstance = this instanceof a3;
      } catch {
      }
      if (isInstance) {
        return Reflect.construct(f2, arguments, this.constructor);
      }
      return f2.apply(this, arguments);
    };
    a2.prototype = f2.prototype;
  } else a2 = {};
  Object.defineProperty(a2, "__esModule", { value: true });
  Object.keys(n2).forEach(function(k2) {
    var d2 = Object.getOwnPropertyDescriptor(n2, k2);
    Object.defineProperty(a2, k2, d2.get ? d2 : {
      enumerable: true,
      get: function() {
        return n2[k2];
      }
    });
  });
  return a2;
}
var propTypes$1 = { exports: {} };
var reactIs$1 = { exports: {} };
var reactIs_production_min$1 = {};
var hasRequiredReactIs_production_min$1;
function requireReactIs_production_min$1() {
  if (hasRequiredReactIs_production_min$1) return reactIs_production_min$1;
  hasRequiredReactIs_production_min$1 = 1;
  var b2 = "function" === typeof Symbol && Symbol.for, c2 = b2 ? /* @__PURE__ */ Symbol.for("react.element") : 60103, d2 = b2 ? /* @__PURE__ */ Symbol.for("react.portal") : 60106, e2 = b2 ? /* @__PURE__ */ Symbol.for("react.fragment") : 60107, f2 = b2 ? /* @__PURE__ */ Symbol.for("react.strict_mode") : 60108, g2 = b2 ? /* @__PURE__ */ Symbol.for("react.profiler") : 60114, h2 = b2 ? /* @__PURE__ */ Symbol.for("react.provider") : 60109, k2 = b2 ? /* @__PURE__ */ Symbol.for("react.context") : 60110, l2 = b2 ? /* @__PURE__ */ Symbol.for("react.async_mode") : 60111, m2 = b2 ? /* @__PURE__ */ Symbol.for("react.concurrent_mode") : 60111, n2 = b2 ? /* @__PURE__ */ Symbol.for("react.forward_ref") : 60112, p2 = b2 ? /* @__PURE__ */ Symbol.for("react.suspense") : 60113, q2 = b2 ? /* @__PURE__ */ Symbol.for("react.suspense_list") : 60120, r2 = b2 ? /* @__PURE__ */ Symbol.for("react.memo") : 60115, t2 = b2 ? /* @__PURE__ */ Symbol.for("react.lazy") : 60116, v2 = b2 ? /* @__PURE__ */ Symbol.for("react.block") : 60121, w2 = b2 ? /* @__PURE__ */ Symbol.for("react.fundamental") : 60117, x2 = b2 ? /* @__PURE__ */ Symbol.for("react.responder") : 60118, y2 = b2 ? /* @__PURE__ */ Symbol.for("react.scope") : 60119;
  function z2(a2) {
    if ("object" === typeof a2 && null !== a2) {
      var u2 = a2.$$typeof;
      switch (u2) {
        case c2:
          switch (a2 = a2.type, a2) {
            case l2:
            case m2:
            case e2:
            case g2:
            case f2:
            case p2:
              return a2;
            default:
              switch (a2 = a2 && a2.$$typeof, a2) {
                case k2:
                case n2:
                case t2:
                case r2:
                case h2:
                  return a2;
                default:
                  return u2;
              }
          }
        case d2:
          return u2;
      }
    }
  }
  function A2(a2) {
    return z2(a2) === m2;
  }
  reactIs_production_min$1.AsyncMode = l2;
  reactIs_production_min$1.ConcurrentMode = m2;
  reactIs_production_min$1.ContextConsumer = k2;
  reactIs_production_min$1.ContextProvider = h2;
  reactIs_production_min$1.Element = c2;
  reactIs_production_min$1.ForwardRef = n2;
  reactIs_production_min$1.Fragment = e2;
  reactIs_production_min$1.Lazy = t2;
  reactIs_production_min$1.Memo = r2;
  reactIs_production_min$1.Portal = d2;
  reactIs_production_min$1.Profiler = g2;
  reactIs_production_min$1.StrictMode = f2;
  reactIs_production_min$1.Suspense = p2;
  reactIs_production_min$1.isAsyncMode = function(a2) {
    return A2(a2) || z2(a2) === l2;
  };
  reactIs_production_min$1.isConcurrentMode = A2;
  reactIs_production_min$1.isContextConsumer = function(a2) {
    return z2(a2) === k2;
  };
  reactIs_production_min$1.isContextProvider = function(a2) {
    return z2(a2) === h2;
  };
  reactIs_production_min$1.isElement = function(a2) {
    return "object" === typeof a2 && null !== a2 && a2.$$typeof === c2;
  };
  reactIs_production_min$1.isForwardRef = function(a2) {
    return z2(a2) === n2;
  };
  reactIs_production_min$1.isFragment = function(a2) {
    return z2(a2) === e2;
  };
  reactIs_production_min$1.isLazy = function(a2) {
    return z2(a2) === t2;
  };
  reactIs_production_min$1.isMemo = function(a2) {
    return z2(a2) === r2;
  };
  reactIs_production_min$1.isPortal = function(a2) {
    return z2(a2) === d2;
  };
  reactIs_production_min$1.isProfiler = function(a2) {
    return z2(a2) === g2;
  };
  reactIs_production_min$1.isStrictMode = function(a2) {
    return z2(a2) === f2;
  };
  reactIs_production_min$1.isSuspense = function(a2) {
    return z2(a2) === p2;
  };
  reactIs_production_min$1.isValidElementType = function(a2) {
    return "string" === typeof a2 || "function" === typeof a2 || a2 === e2 || a2 === m2 || a2 === g2 || a2 === f2 || a2 === p2 || a2 === q2 || "object" === typeof a2 && null !== a2 && (a2.$$typeof === t2 || a2.$$typeof === r2 || a2.$$typeof === h2 || a2.$$typeof === k2 || a2.$$typeof === n2 || a2.$$typeof === w2 || a2.$$typeof === x2 || a2.$$typeof === y2 || a2.$$typeof === v2);
  };
  reactIs_production_min$1.typeOf = z2;
  return reactIs_production_min$1;
}
var reactIs_development$1 = {};
var hasRequiredReactIs_development$1;
function requireReactIs_development$1() {
  if (hasRequiredReactIs_development$1) return reactIs_development$1;
  hasRequiredReactIs_development$1 = 1;
  if (process.env.NODE_ENV !== "production") {
    (function() {
      var hasSymbol = typeof Symbol === "function" && Symbol.for;
      var REACT_ELEMENT_TYPE = hasSymbol ? /* @__PURE__ */ Symbol.for("react.element") : 60103;
      var REACT_PORTAL_TYPE = hasSymbol ? /* @__PURE__ */ Symbol.for("react.portal") : 60106;
      var REACT_FRAGMENT_TYPE = hasSymbol ? /* @__PURE__ */ Symbol.for("react.fragment") : 60107;
      var REACT_STRICT_MODE_TYPE = hasSymbol ? /* @__PURE__ */ Symbol.for("react.strict_mode") : 60108;
      var REACT_PROFILER_TYPE = hasSymbol ? /* @__PURE__ */ Symbol.for("react.profiler") : 60114;
      var REACT_PROVIDER_TYPE = hasSymbol ? /* @__PURE__ */ Symbol.for("react.provider") : 60109;
      var REACT_CONTEXT_TYPE = hasSymbol ? /* @__PURE__ */ Symbol.for("react.context") : 60110;
      var REACT_ASYNC_MODE_TYPE = hasSymbol ? /* @__PURE__ */ Symbol.for("react.async_mode") : 60111;
      var REACT_CONCURRENT_MODE_TYPE = hasSymbol ? /* @__PURE__ */ Symbol.for("react.concurrent_mode") : 60111;
      var REACT_FORWARD_REF_TYPE = hasSymbol ? /* @__PURE__ */ Symbol.for("react.forward_ref") : 60112;
      var REACT_SUSPENSE_TYPE = hasSymbol ? /* @__PURE__ */ Symbol.for("react.suspense") : 60113;
      var REACT_SUSPENSE_LIST_TYPE = hasSymbol ? /* @__PURE__ */ Symbol.for("react.suspense_list") : 60120;
      var REACT_MEMO_TYPE = hasSymbol ? /* @__PURE__ */ Symbol.for("react.memo") : 60115;
      var REACT_LAZY_TYPE = hasSymbol ? /* @__PURE__ */ Symbol.for("react.lazy") : 60116;
      var REACT_BLOCK_TYPE = hasSymbol ? /* @__PURE__ */ Symbol.for("react.block") : 60121;
      var REACT_FUNDAMENTAL_TYPE = hasSymbol ? /* @__PURE__ */ Symbol.for("react.fundamental") : 60117;
      var REACT_RESPONDER_TYPE = hasSymbol ? /* @__PURE__ */ Symbol.for("react.responder") : 60118;
      var REACT_SCOPE_TYPE = hasSymbol ? /* @__PURE__ */ Symbol.for("react.scope") : 60119;
      function isValidElementType(type) {
        return typeof type === "string" || typeof type === "function" || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
        type === REACT_FRAGMENT_TYPE || type === REACT_CONCURRENT_MODE_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || typeof type === "object" && type !== null && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_RESPONDER_TYPE || type.$$typeof === REACT_SCOPE_TYPE || type.$$typeof === REACT_BLOCK_TYPE);
      }
      function typeOf(object) {
        if (typeof object === "object" && object !== null) {
          var $$typeof = object.$$typeof;
          switch ($$typeof) {
            case REACT_ELEMENT_TYPE:
              var type = object.type;
              switch (type) {
                case REACT_ASYNC_MODE_TYPE:
                case REACT_CONCURRENT_MODE_TYPE:
                case REACT_FRAGMENT_TYPE:
                case REACT_PROFILER_TYPE:
                case REACT_STRICT_MODE_TYPE:
                case REACT_SUSPENSE_TYPE:
                  return type;
                default:
                  var $$typeofType = type && type.$$typeof;
                  switch ($$typeofType) {
                    case REACT_CONTEXT_TYPE:
                    case REACT_FORWARD_REF_TYPE:
                    case REACT_LAZY_TYPE:
                    case REACT_MEMO_TYPE:
                    case REACT_PROVIDER_TYPE:
                      return $$typeofType;
                    default:
                      return $$typeof;
                  }
              }
            case REACT_PORTAL_TYPE:
              return $$typeof;
          }
        }
        return void 0;
      }
      var AsyncMode = REACT_ASYNC_MODE_TYPE;
      var ConcurrentMode = REACT_CONCURRENT_MODE_TYPE;
      var ContextConsumer = REACT_CONTEXT_TYPE;
      var ContextProvider = REACT_PROVIDER_TYPE;
      var Element2 = REACT_ELEMENT_TYPE;
      var ForwardRef = REACT_FORWARD_REF_TYPE;
      var Fragment = REACT_FRAGMENT_TYPE;
      var Lazy = REACT_LAZY_TYPE;
      var Memo = REACT_MEMO_TYPE;
      var Portal = REACT_PORTAL_TYPE;
      var Profiler = REACT_PROFILER_TYPE;
      var StrictMode = REACT_STRICT_MODE_TYPE;
      var Suspense = REACT_SUSPENSE_TYPE;
      var hasWarnedAboutDeprecatedIsAsyncMode = false;
      function isAsyncMode(object) {
        {
          if (!hasWarnedAboutDeprecatedIsAsyncMode) {
            hasWarnedAboutDeprecatedIsAsyncMode = true;
            console["warn"]("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.");
          }
        }
        return isConcurrentMode(object) || typeOf(object) === REACT_ASYNC_MODE_TYPE;
      }
      function isConcurrentMode(object) {
        return typeOf(object) === REACT_CONCURRENT_MODE_TYPE;
      }
      function isContextConsumer(object) {
        return typeOf(object) === REACT_CONTEXT_TYPE;
      }
      function isContextProvider(object) {
        return typeOf(object) === REACT_PROVIDER_TYPE;
      }
      function isElement(object) {
        return typeof object === "object" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
      }
      function isForwardRef(object) {
        return typeOf(object) === REACT_FORWARD_REF_TYPE;
      }
      function isFragment(object) {
        return typeOf(object) === REACT_FRAGMENT_TYPE;
      }
      function isLazy(object) {
        return typeOf(object) === REACT_LAZY_TYPE;
      }
      function isMemo(object) {
        return typeOf(object) === REACT_MEMO_TYPE;
      }
      function isPortal(object) {
        return typeOf(object) === REACT_PORTAL_TYPE;
      }
      function isProfiler(object) {
        return typeOf(object) === REACT_PROFILER_TYPE;
      }
      function isStrictMode(object) {
        return typeOf(object) === REACT_STRICT_MODE_TYPE;
      }
      function isSuspense(object) {
        return typeOf(object) === REACT_SUSPENSE_TYPE;
      }
      reactIs_development$1.AsyncMode = AsyncMode;
      reactIs_development$1.ConcurrentMode = ConcurrentMode;
      reactIs_development$1.ContextConsumer = ContextConsumer;
      reactIs_development$1.ContextProvider = ContextProvider;
      reactIs_development$1.Element = Element2;
      reactIs_development$1.ForwardRef = ForwardRef;
      reactIs_development$1.Fragment = Fragment;
      reactIs_development$1.Lazy = Lazy;
      reactIs_development$1.Memo = Memo;
      reactIs_development$1.Portal = Portal;
      reactIs_development$1.Profiler = Profiler;
      reactIs_development$1.StrictMode = StrictMode;
      reactIs_development$1.Suspense = Suspense;
      reactIs_development$1.isAsyncMode = isAsyncMode;
      reactIs_development$1.isConcurrentMode = isConcurrentMode;
      reactIs_development$1.isContextConsumer = isContextConsumer;
      reactIs_development$1.isContextProvider = isContextProvider;
      reactIs_development$1.isElement = isElement;
      reactIs_development$1.isForwardRef = isForwardRef;
      reactIs_development$1.isFragment = isFragment;
      reactIs_development$1.isLazy = isLazy;
      reactIs_development$1.isMemo = isMemo;
      reactIs_development$1.isPortal = isPortal;
      reactIs_development$1.isProfiler = isProfiler;
      reactIs_development$1.isStrictMode = isStrictMode;
      reactIs_development$1.isSuspense = isSuspense;
      reactIs_development$1.isValidElementType = isValidElementType;
      reactIs_development$1.typeOf = typeOf;
    })();
  }
  return reactIs_development$1;
}
var hasRequiredReactIs$1;
function requireReactIs$1() {
  if (hasRequiredReactIs$1) return reactIs$1.exports;
  hasRequiredReactIs$1 = 1;
  if (process.env.NODE_ENV === "production") {
    reactIs$1.exports = requireReactIs_production_min$1();
  } else {
    reactIs$1.exports = requireReactIs_development$1();
  }
  return reactIs$1.exports;
}
var objectAssign;
var hasRequiredObjectAssign;
function requireObjectAssign() {
  if (hasRequiredObjectAssign) return objectAssign;
  hasRequiredObjectAssign = 1;
  var getOwnPropertySymbols = Object.getOwnPropertySymbols;
  var hasOwnProperty = Object.prototype.hasOwnProperty;
  var propIsEnumerable = Object.prototype.propertyIsEnumerable;
  function toObject(val) {
    if (val === null || val === void 0) {
      throw new TypeError("Object.assign cannot be called with null or undefined");
    }
    return Object(val);
  }
  function shouldUseNative() {
    try {
      if (!Object.assign) {
        return false;
      }
      var test1 = new String("abc");
      test1[5] = "de";
      if (Object.getOwnPropertyNames(test1)[0] === "5") {
        return false;
      }
      var test2 = {};
      for (var i2 = 0; i2 < 10; i2++) {
        test2["_" + String.fromCharCode(i2)] = i2;
      }
      var order2 = Object.getOwnPropertyNames(test2).map(function(n2) {
        return test2[n2];
      });
      if (order2.join("") !== "0123456789") {
        return false;
      }
      var test3 = {};
      "abcdefghijklmnopqrst".split("").forEach(function(letter) {
        test3[letter] = letter;
      });
      if (Object.keys(Object.assign({}, test3)).join("") !== "abcdefghijklmnopqrst") {
        return false;
      }
      return true;
    } catch (err) {
      return false;
    }
  }
  objectAssign = shouldUseNative() ? Object.assign : function(target, source) {
    var from;
    var to = toObject(target);
    var symbols;
    for (var s2 = 1; s2 < arguments.length; s2++) {
      from = Object(arguments[s2]);
      for (var key in from) {
        if (hasOwnProperty.call(from, key)) {
          to[key] = from[key];
        }
      }
      if (getOwnPropertySymbols) {
        symbols = getOwnPropertySymbols(from);
        for (var i2 = 0; i2 < symbols.length; i2++) {
          if (propIsEnumerable.call(from, symbols[i2])) {
            to[symbols[i2]] = from[symbols[i2]];
          }
        }
      }
    }
    return to;
  };
  return objectAssign;
}
var ReactPropTypesSecret_1;
var hasRequiredReactPropTypesSecret;
function requireReactPropTypesSecret() {
  if (hasRequiredReactPropTypesSecret) return ReactPropTypesSecret_1;
  hasRequiredReactPropTypesSecret = 1;
  var ReactPropTypesSecret = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
  ReactPropTypesSecret_1 = ReactPropTypesSecret;
  return ReactPropTypesSecret_1;
}
var has;
var hasRequiredHas;
function requireHas() {
  if (hasRequiredHas) return has;
  hasRequiredHas = 1;
  has = Function.call.bind(Object.prototype.hasOwnProperty);
  return has;
}
var checkPropTypes_1;
var hasRequiredCheckPropTypes;
function requireCheckPropTypes() {
  if (hasRequiredCheckPropTypes) return checkPropTypes_1;
  hasRequiredCheckPropTypes = 1;
  var printWarning = function() {
  };
  if (process.env.NODE_ENV !== "production") {
    var ReactPropTypesSecret = /* @__PURE__ */ requireReactPropTypesSecret();
    var loggedTypeFailures = {};
    var has2 = /* @__PURE__ */ requireHas();
    printWarning = function(text2) {
      var message = "Warning: " + text2;
      if (typeof console !== "undefined") {
        console.error(message);
      }
      try {
        throw new Error(message);
      } catch (x2) {
      }
    };
  }
  function checkPropTypes(typeSpecs, values, location2, componentName, getStack) {
    if (process.env.NODE_ENV !== "production") {
      for (var typeSpecName in typeSpecs) {
        if (has2(typeSpecs, typeSpecName)) {
          var error;
          try {
            if (typeof typeSpecs[typeSpecName] !== "function") {
              var err = Error(
                (componentName || "React class") + ": " + location2 + " type `" + typeSpecName + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof typeSpecs[typeSpecName] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`."
              );
              err.name = "Invariant Violation";
              throw err;
            }
            error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location2, null, ReactPropTypesSecret);
          } catch (ex) {
            error = ex;
          }
          if (error && !(error instanceof Error)) {
            printWarning(
              (componentName || "React class") + ": type specification of " + location2 + " `" + typeSpecName + "` is invalid; the type checker function must return `null` or an `Error` but returned a " + typeof error + ". You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument)."
            );
          }
          if (error instanceof Error && !(error.message in loggedTypeFailures)) {
            loggedTypeFailures[error.message] = true;
            var stack = getStack ? getStack() : "";
            printWarning(
              "Failed " + location2 + " type: " + error.message + (stack != null ? stack : "")
            );
          }
        }
      }
    }
  }
  checkPropTypes.resetWarningCache = function() {
    if (process.env.NODE_ENV !== "production") {
      loggedTypeFailures = {};
    }
  };
  checkPropTypes_1 = checkPropTypes;
  return checkPropTypes_1;
}
var factoryWithTypeCheckers;
var hasRequiredFactoryWithTypeCheckers;
function requireFactoryWithTypeCheckers() {
  if (hasRequiredFactoryWithTypeCheckers) return factoryWithTypeCheckers;
  hasRequiredFactoryWithTypeCheckers = 1;
  var ReactIs = requireReactIs$1();
  var assign = requireObjectAssign();
  var ReactPropTypesSecret = /* @__PURE__ */ requireReactPropTypesSecret();
  var has2 = /* @__PURE__ */ requireHas();
  var checkPropTypes = /* @__PURE__ */ requireCheckPropTypes();
  var printWarning = function() {
  };
  if (process.env.NODE_ENV !== "production") {
    printWarning = function(text2) {
      var message = "Warning: " + text2;
      if (typeof console !== "undefined") {
        console.error(message);
      }
      try {
        throw new Error(message);
      } catch (x2) {
      }
    };
  }
  function emptyFunctionThatReturnsNull() {
    return null;
  }
  factoryWithTypeCheckers = function(isValidElement, throwOnDirectAccess) {
    var ITERATOR_SYMBOL = typeof Symbol === "function" && Symbol.iterator;
    var FAUX_ITERATOR_SYMBOL = "@@iterator";
    function getIteratorFn(maybeIterable) {
      var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
      if (typeof iteratorFn === "function") {
        return iteratorFn;
      }
    }
    var ANONYMOUS = "<<anonymous>>";
    var ReactPropTypes = {
      array: createPrimitiveTypeChecker("array"),
      bigint: createPrimitiveTypeChecker("bigint"),
      bool: createPrimitiveTypeChecker("boolean"),
      func: createPrimitiveTypeChecker("function"),
      number: createPrimitiveTypeChecker("number"),
      object: createPrimitiveTypeChecker("object"),
      string: createPrimitiveTypeChecker("string"),
      symbol: createPrimitiveTypeChecker("symbol"),
      any: createAnyTypeChecker(),
      arrayOf: createArrayOfTypeChecker,
      element: createElementTypeChecker(),
      elementType: createElementTypeTypeChecker(),
      instanceOf: createInstanceTypeChecker,
      node: createNodeChecker(),
      objectOf: createObjectOfTypeChecker,
      oneOf: createEnumTypeChecker,
      oneOfType: createUnionTypeChecker,
      shape: createShapeTypeChecker,
      exact: createStrictShapeTypeChecker
    };
    function is(x2, y2) {
      if (x2 === y2) {
        return x2 !== 0 || 1 / x2 === 1 / y2;
      } else {
        return x2 !== x2 && y2 !== y2;
      }
    }
    function PropTypeError(message, data) {
      this.message = message;
      this.data = data && typeof data === "object" ? data : {};
      this.stack = "";
    }
    PropTypeError.prototype = Error.prototype;
    function createChainableTypeChecker(validate) {
      if (process.env.NODE_ENV !== "production") {
        var manualPropTypeCallCache = {};
        var manualPropTypeWarningCount = 0;
      }
      function checkType(isRequired, props, propName, componentName, location2, propFullName, secret) {
        componentName = componentName || ANONYMOUS;
        propFullName = propFullName || propName;
        if (secret !== ReactPropTypesSecret) {
          if (throwOnDirectAccess) {
            var err = new Error(
              "Calling PropTypes validators directly is not supported by the `prop-types` package. Use `PropTypes.checkPropTypes()` to call them. Read more at http://fb.me/use-check-prop-types"
            );
            err.name = "Invariant Violation";
            throw err;
          } else if (process.env.NODE_ENV !== "production" && typeof console !== "undefined") {
            var cacheKey = componentName + ":" + propName;
            if (!manualPropTypeCallCache[cacheKey] && // Avoid spamming the console because they are often not actionable except for lib authors
            manualPropTypeWarningCount < 3) {
              printWarning(
                "You are manually calling a React.PropTypes validation function for the `" + propFullName + "` prop on `" + componentName + "`. This is deprecated and will throw in the standalone `prop-types` package. You may be seeing this warning due to a third-party PropTypes library. See https://fb.me/react-warning-dont-call-proptypes for details."
              );
              manualPropTypeCallCache[cacheKey] = true;
              manualPropTypeWarningCount++;
            }
          }
        }
        if (props[propName] == null) {
          if (isRequired) {
            if (props[propName] === null) {
              return new PropTypeError("The " + location2 + " `" + propFullName + "` is marked as required " + ("in `" + componentName + "`, but its value is `null`."));
            }
            return new PropTypeError("The " + location2 + " `" + propFullName + "` is marked as required in " + ("`" + componentName + "`, but its value is `undefined`."));
          }
          return null;
        } else {
          return validate(props, propName, componentName, location2, propFullName);
        }
      }
      var chainedCheckType = checkType.bind(null, false);
      chainedCheckType.isRequired = checkType.bind(null, true);
      return chainedCheckType;
    }
    function createPrimitiveTypeChecker(expectedType) {
      function validate(props, propName, componentName, location2, propFullName, secret) {
        var propValue = props[propName];
        var propType = getPropType(propValue);
        if (propType !== expectedType) {
          var preciseType = getPreciseType(propValue);
          return new PropTypeError(
            "Invalid " + location2 + " `" + propFullName + "` of type " + ("`" + preciseType + "` supplied to `" + componentName + "`, expected ") + ("`" + expectedType + "`."),
            { expectedType }
          );
        }
        return null;
      }
      return createChainableTypeChecker(validate);
    }
    function createAnyTypeChecker() {
      return createChainableTypeChecker(emptyFunctionThatReturnsNull);
    }
    function createArrayOfTypeChecker(typeChecker) {
      function validate(props, propName, componentName, location2, propFullName) {
        if (typeof typeChecker !== "function") {
          return new PropTypeError("Property `" + propFullName + "` of component `" + componentName + "` has invalid PropType notation inside arrayOf.");
        }
        var propValue = props[propName];
        if (!Array.isArray(propValue)) {
          var propType = getPropType(propValue);
          return new PropTypeError("Invalid " + location2 + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected an array."));
        }
        for (var i2 = 0; i2 < propValue.length; i2++) {
          var error = typeChecker(propValue, i2, componentName, location2, propFullName + "[" + i2 + "]", ReactPropTypesSecret);
          if (error instanceof Error) {
            return error;
          }
        }
        return null;
      }
      return createChainableTypeChecker(validate);
    }
    function createElementTypeChecker() {
      function validate(props, propName, componentName, location2, propFullName) {
        var propValue = props[propName];
        if (!isValidElement(propValue)) {
          var propType = getPropType(propValue);
          return new PropTypeError("Invalid " + location2 + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected a single ReactElement."));
        }
        return null;
      }
      return createChainableTypeChecker(validate);
    }
    function createElementTypeTypeChecker() {
      function validate(props, propName, componentName, location2, propFullName) {
        var propValue = props[propName];
        if (!ReactIs.isValidElementType(propValue)) {
          var propType = getPropType(propValue);
          return new PropTypeError("Invalid " + location2 + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected a single ReactElement type."));
        }
        return null;
      }
      return createChainableTypeChecker(validate);
    }
    function createInstanceTypeChecker(expectedClass) {
      function validate(props, propName, componentName, location2, propFullName) {
        if (!(props[propName] instanceof expectedClass)) {
          var expectedClassName = expectedClass.name || ANONYMOUS;
          var actualClassName = getClassName(props[propName]);
          return new PropTypeError("Invalid " + location2 + " `" + propFullName + "` of type " + ("`" + actualClassName + "` supplied to `" + componentName + "`, expected ") + ("instance of `" + expectedClassName + "`."));
        }
        return null;
      }
      return createChainableTypeChecker(validate);
    }
    function createEnumTypeChecker(expectedValues) {
      if (!Array.isArray(expectedValues)) {
        if (process.env.NODE_ENV !== "production") {
          if (arguments.length > 1) {
            printWarning(
              "Invalid arguments supplied to oneOf, expected an array, got " + arguments.length + " arguments. A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z])."
            );
          } else {
            printWarning("Invalid argument supplied to oneOf, expected an array.");
          }
        }
        return emptyFunctionThatReturnsNull;
      }
      function validate(props, propName, componentName, location2, propFullName) {
        var propValue = props[propName];
        for (var i2 = 0; i2 < expectedValues.length; i2++) {
          if (is(propValue, expectedValues[i2])) {
            return null;
          }
        }
        var valuesString = JSON.stringify(expectedValues, function replacer(key, value) {
          var type = getPreciseType(value);
          if (type === "symbol") {
            return String(value);
          }
          return value;
        });
        return new PropTypeError("Invalid " + location2 + " `" + propFullName + "` of value `" + String(propValue) + "` " + ("supplied to `" + componentName + "`, expected one of " + valuesString + "."));
      }
      return createChainableTypeChecker(validate);
    }
    function createObjectOfTypeChecker(typeChecker) {
      function validate(props, propName, componentName, location2, propFullName) {
        if (typeof typeChecker !== "function") {
          return new PropTypeError("Property `" + propFullName + "` of component `" + componentName + "` has invalid PropType notation inside objectOf.");
        }
        var propValue = props[propName];
        var propType = getPropType(propValue);
        if (propType !== "object") {
          return new PropTypeError("Invalid " + location2 + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected an object."));
        }
        for (var key in propValue) {
          if (has2(propValue, key)) {
            var error = typeChecker(propValue, key, componentName, location2, propFullName + "." + key, ReactPropTypesSecret);
            if (error instanceof Error) {
              return error;
            }
          }
        }
        return null;
      }
      return createChainableTypeChecker(validate);
    }
    function createUnionTypeChecker(arrayOfTypeCheckers) {
      if (!Array.isArray(arrayOfTypeCheckers)) {
        process.env.NODE_ENV !== "production" ? printWarning("Invalid argument supplied to oneOfType, expected an instance of array.") : void 0;
        return emptyFunctionThatReturnsNull;
      }
      for (var i2 = 0; i2 < arrayOfTypeCheckers.length; i2++) {
        var checker = arrayOfTypeCheckers[i2];
        if (typeof checker !== "function") {
          printWarning(
            "Invalid argument supplied to oneOfType. Expected an array of check functions, but received " + getPostfixForTypeWarning(checker) + " at index " + i2 + "."
          );
          return emptyFunctionThatReturnsNull;
        }
      }
      function validate(props, propName, componentName, location2, propFullName) {
        var expectedTypes = [];
        for (var i3 = 0; i3 < arrayOfTypeCheckers.length; i3++) {
          var checker2 = arrayOfTypeCheckers[i3];
          var checkerResult = checker2(props, propName, componentName, location2, propFullName, ReactPropTypesSecret);
          if (checkerResult == null) {
            return null;
          }
          if (checkerResult.data && has2(checkerResult.data, "expectedType")) {
            expectedTypes.push(checkerResult.data.expectedType);
          }
        }
        var expectedTypesMessage = expectedTypes.length > 0 ? ", expected one of type [" + expectedTypes.join(", ") + "]" : "";
        return new PropTypeError("Invalid " + location2 + " `" + propFullName + "` supplied to " + ("`" + componentName + "`" + expectedTypesMessage + "."));
      }
      return createChainableTypeChecker(validate);
    }
    function createNodeChecker() {
      function validate(props, propName, componentName, location2, propFullName) {
        if (!isNode(props[propName])) {
          return new PropTypeError("Invalid " + location2 + " `" + propFullName + "` supplied to " + ("`" + componentName + "`, expected a ReactNode."));
        }
        return null;
      }
      return createChainableTypeChecker(validate);
    }
    function invalidValidatorError(componentName, location2, propFullName, key, type) {
      return new PropTypeError(
        (componentName || "React class") + ": " + location2 + " type `" + propFullName + "." + key + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + type + "`."
      );
    }
    function createShapeTypeChecker(shapeTypes) {
      function validate(props, propName, componentName, location2, propFullName) {
        var propValue = props[propName];
        var propType = getPropType(propValue);
        if (propType !== "object") {
          return new PropTypeError("Invalid " + location2 + " `" + propFullName + "` of type `" + propType + "` " + ("supplied to `" + componentName + "`, expected `object`."));
        }
        for (var key in shapeTypes) {
          var checker = shapeTypes[key];
          if (typeof checker !== "function") {
            return invalidValidatorError(componentName, location2, propFullName, key, getPreciseType(checker));
          }
          var error = checker(propValue, key, componentName, location2, propFullName + "." + key, ReactPropTypesSecret);
          if (error) {
            return error;
          }
        }
        return null;
      }
      return createChainableTypeChecker(validate);
    }
    function createStrictShapeTypeChecker(shapeTypes) {
      function validate(props, propName, componentName, location2, propFullName) {
        var propValue = props[propName];
        var propType = getPropType(propValue);
        if (propType !== "object") {
          return new PropTypeError("Invalid " + location2 + " `" + propFullName + "` of type `" + propType + "` " + ("supplied to `" + componentName + "`, expected `object`."));
        }
        var allKeys = assign({}, props[propName], shapeTypes);
        for (var key in allKeys) {
          var checker = shapeTypes[key];
          if (has2(shapeTypes, key) && typeof checker !== "function") {
            return invalidValidatorError(componentName, location2, propFullName, key, getPreciseType(checker));
          }
          if (!checker) {
            return new PropTypeError(
              "Invalid " + location2 + " `" + propFullName + "` key `" + key + "` supplied to `" + componentName + "`.\nBad object: " + JSON.stringify(props[propName], null, "  ") + "\nValid keys: " + JSON.stringify(Object.keys(shapeTypes), null, "  ")
            );
          }
          var error = checker(propValue, key, componentName, location2, propFullName + "." + key, ReactPropTypesSecret);
          if (error) {
            return error;
          }
        }
        return null;
      }
      return createChainableTypeChecker(validate);
    }
    function isNode(propValue) {
      switch (typeof propValue) {
        case "number":
        case "string":
        case "undefined":
          return true;
        case "boolean":
          return !propValue;
        case "object":
          if (Array.isArray(propValue)) {
            return propValue.every(isNode);
          }
          if (propValue === null || isValidElement(propValue)) {
            return true;
          }
          var iteratorFn = getIteratorFn(propValue);
          if (iteratorFn) {
            var iterator2 = iteratorFn.call(propValue);
            var step;
            if (iteratorFn !== propValue.entries) {
              while (!(step = iterator2.next()).done) {
                if (!isNode(step.value)) {
                  return false;
                }
              }
            } else {
              while (!(step = iterator2.next()).done) {
                var entry = step.value;
                if (entry) {
                  if (!isNode(entry[1])) {
                    return false;
                  }
                }
              }
            }
          } else {
            return false;
          }
          return true;
        default:
          return false;
      }
    }
    function isSymbol(propType, propValue) {
      if (propType === "symbol") {
        return true;
      }
      if (!propValue) {
        return false;
      }
      if (propValue["@@toStringTag"] === "Symbol") {
        return true;
      }
      if (typeof Symbol === "function" && propValue instanceof Symbol) {
        return true;
      }
      return false;
    }
    function getPropType(propValue) {
      var propType = typeof propValue;
      if (Array.isArray(propValue)) {
        return "array";
      }
      if (propValue instanceof RegExp) {
        return "object";
      }
      if (isSymbol(propType, propValue)) {
        return "symbol";
      }
      return propType;
    }
    function getPreciseType(propValue) {
      if (typeof propValue === "undefined" || propValue === null) {
        return "" + propValue;
      }
      var propType = getPropType(propValue);
      if (propType === "object") {
        if (propValue instanceof Date) {
          return "date";
        } else if (propValue instanceof RegExp) {
          return "regexp";
        }
      }
      return propType;
    }
    function getPostfixForTypeWarning(value) {
      var type = getPreciseType(value);
      switch (type) {
        case "array":
        case "object":
          return "an " + type;
        case "boolean":
        case "date":
        case "regexp":
          return "a " + type;
        default:
          return type;
      }
    }
    function getClassName(propValue) {
      if (!propValue.constructor || !propValue.constructor.name) {
        return ANONYMOUS;
      }
      return propValue.constructor.name;
    }
    ReactPropTypes.checkPropTypes = checkPropTypes;
    ReactPropTypes.resetWarningCache = checkPropTypes.resetWarningCache;
    ReactPropTypes.PropTypes = ReactPropTypes;
    return ReactPropTypes;
  };
  return factoryWithTypeCheckers;
}
var factoryWithThrowingShims;
var hasRequiredFactoryWithThrowingShims;
function requireFactoryWithThrowingShims() {
  if (hasRequiredFactoryWithThrowingShims) return factoryWithThrowingShims;
  hasRequiredFactoryWithThrowingShims = 1;
  var ReactPropTypesSecret = /* @__PURE__ */ requireReactPropTypesSecret();
  function emptyFunction() {
  }
  function emptyFunctionWithReset() {
  }
  emptyFunctionWithReset.resetWarningCache = emptyFunction;
  factoryWithThrowingShims = function() {
    function shim(props, propName, componentName, location2, propFullName, secret) {
      if (secret === ReactPropTypesSecret) {
        return;
      }
      var err = new Error(
        "Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"
      );
      err.name = "Invariant Violation";
      throw err;
    }
    shim.isRequired = shim;
    function getShim() {
      return shim;
    }
    var ReactPropTypes = {
      array: shim,
      bigint: shim,
      bool: shim,
      func: shim,
      number: shim,
      object: shim,
      string: shim,
      symbol: shim,
      any: shim,
      arrayOf: getShim,
      element: shim,
      elementType: shim,
      instanceOf: getShim,
      node: shim,
      objectOf: getShim,
      oneOf: getShim,
      oneOfType: getShim,
      shape: getShim,
      exact: getShim,
      checkPropTypes: emptyFunctionWithReset,
      resetWarningCache: emptyFunction
    };
    ReactPropTypes.PropTypes = ReactPropTypes;
    return ReactPropTypes;
  };
  return factoryWithThrowingShims;
}
var hasRequiredPropTypes$1;
function requirePropTypes$1() {
  if (hasRequiredPropTypes$1) return propTypes$1.exports;
  hasRequiredPropTypes$1 = 1;
  if (process.env.NODE_ENV !== "production") {
    var ReactIs = requireReactIs$1();
    var throwOnDirectAccess = true;
    propTypes$1.exports = /* @__PURE__ */ requireFactoryWithTypeCheckers()(ReactIs.isElement, throwOnDirectAccess);
  } else {
    propTypes$1.exports = /* @__PURE__ */ requireFactoryWithThrowingShims()();
  }
  return propTypes$1.exports;
}
var propTypesExports = /* @__PURE__ */ requirePropTypes$1();
const PropTypes = /* @__PURE__ */ getDefaultExportFromCjs(propTypesExports);
function g(n2, t2) {
  for (var e2 in t2) n2[e2] = t2[e2];
  return n2;
}
function E(n2, t2) {
  for (var e2 in n2) if ("__source" !== e2 && !(e2 in t2)) return true;
  for (var r2 in t2) if ("__source" !== r2 && n2[r2] !== t2[r2]) return true;
  return false;
}
function C(n2, t2) {
  var e2 = t2(), r2 = d({ t: { __: e2, u: t2 } }), u2 = r2[0].t, o2 = r2[1];
  return _(function() {
    u2.__ = e2, u2.u = t2, x(u2) && o2({ t: u2 });
  }, [n2, e2, t2]), y(function() {
    return x(u2) && o2({ t: u2 }), n2(function() {
      x(u2) && o2({ t: u2 });
    });
  }, [n2]), e2;
}
function x(n2) {
  var t2, e2, r2 = n2.u, u2 = n2.__;
  try {
    var o2 = r2();
    return !((t2 = u2) === (e2 = o2) && (0 !== t2 || 1 / t2 == 1 / e2) || t2 != t2 && e2 != e2);
  } catch (n3) {
    return true;
  }
}
function R(n2) {
  n2();
}
function w(n2) {
  return n2;
}
function k() {
  return [false, R];
}
var I = _;
function N(n2, t2) {
  this.props = n2, this.context = t2;
}
function M(n2, e2) {
  function r2(n3) {
    var t2 = this.props.ref, r3 = t2 == n3.ref;
    return !r3 && t2 && (t2.call ? t2(null) : t2.current = null), e2 ? !e2(this.props, n3) || !r3 : E(this.props, n3);
  }
  function u2(e3) {
    return this.shouldComponentUpdate = r2, _$1(n2, e3);
  }
  return u2.displayName = "Memo(" + (n2.displayName || n2.name) + ")", u2.prototype.isReactComponent = true, u2.__f = true, u2.type = n2, u2;
}
(N.prototype = new x$2()).isPureReactComponent = true, N.prototype.shouldComponentUpdate = function(n2, t2) {
  return E(this.props, n2) || E(this.state, t2);
};
var T = l$2.__b;
l$2.__b = function(n2) {
  n2.type && n2.type.__f && n2.ref && (n2.props.ref = n2.ref, n2.ref = null), T && T(n2);
};
var A = "undefined" != typeof Symbol && Symbol.for && /* @__PURE__ */ Symbol.for("react.forward_ref") || 3911;
function D(n2) {
  function t2(t3) {
    var e2 = g({}, t3);
    return delete e2.ref, n2(e2, t3.ref || null);
  }
  return t2.$$typeof = A, t2.render = n2, t2.prototype.isReactComponent = t2.__f = true, t2.displayName = "ForwardRef(" + (n2.displayName || n2.name) + ")", t2;
}
var L = function(n2, t2) {
  return null == n2 ? null : H$1(H$1(n2).map(t2));
}, O = { map: L, forEach: L, count: function(n2) {
  return n2 ? H$1(n2).length : 0;
}, only: function(n2) {
  var t2 = H$1(n2);
  if (1 !== t2.length) throw "Children.only";
  return t2[0];
}, toArray: H$1 }, F = l$2.__e;
l$2.__e = function(n2, t2, e2, r2) {
  if (n2.then) {
    for (var u2, o2 = t2; o2 = o2.__; ) if ((u2 = o2.__c) && u2.__c) return null == t2.__e && (t2.__e = e2.__e, t2.__k = e2.__k), u2.__c(n2, t2);
  }
  F(n2, t2, e2, r2);
};
var U = l$2.unmount;
function V(n2, t2, e2) {
  return n2 && (n2.__c && n2.__c.__H && (n2.__c.__H.__.forEach(function(n3) {
    "function" == typeof n3.__c && n3.__c();
  }), n2.__c.__H = null), null != (n2 = g({}, n2)).__c && (n2.__c.__P === e2 && (n2.__c.__P = t2), n2.__c.__e = true, n2.__c = null), n2.__k = n2.__k && n2.__k.map(function(n3) {
    return V(n3, t2, e2);
  })), n2;
}
function W(n2, t2, e2) {
  return n2 && e2 && (n2.__v = null, n2.__k = n2.__k && n2.__k.map(function(n3) {
    return W(n3, t2, e2);
  }), n2.__c && n2.__c.__P === t2 && (n2.__e && e2.appendChild(n2.__e), n2.__c.__e = true, n2.__c.__P = e2)), n2;
}
function P() {
  this.__u = 0, this.o = null, this.__b = null;
}
function j(n2) {
  var t2 = n2.__.__c;
  return t2 && t2.__a && t2.__a(n2);
}
function z(n2) {
  var e2, r2, u2, o2 = null;
  function i2(i3) {
    if (e2 || (e2 = n2()).then(function(n3) {
      n3 && (o2 = n3.default || n3), u2 = true;
    }, function(n3) {
      r2 = n3, u2 = true;
    }), r2) throw r2;
    if (!u2) throw e2;
    return o2 ? _$1(o2, i3) : null;
  }
  return i2.displayName = "Lazy", i2.__f = true, i2;
}
function B() {
  this.i = null, this.l = null;
}
l$2.unmount = function(n2) {
  var t2 = n2.__c;
  t2 && t2.__R && t2.__R(), t2 && 32 & n2.__u && (n2.type = null), U && U(n2);
}, (P.prototype = new x$2()).__c = function(n2, t2) {
  var e2 = t2.__c, r2 = this;
  null == r2.o && (r2.o = []), r2.o.push(e2);
  var u2 = j(r2.__v), o2 = false, i2 = function() {
    o2 || (o2 = true, e2.__R = null, u2 ? u2(l2) : l2());
  };
  e2.__R = i2;
  var l2 = function() {
    if (!--r2.__u) {
      if (r2.state.__a) {
        var n3 = r2.state.__a;
        r2.__v.__k[0] = W(n3, n3.__c.__P, n3.__c.__O);
      }
      var t3;
      for (r2.setState({ __a: r2.__b = null }); t3 = r2.o.pop(); ) t3.forceUpdate();
    }
  };
  r2.__u++ || 32 & t2.__u || r2.setState({ __a: r2.__b = r2.__v.__k[0] }), n2.then(i2, i2);
}, P.prototype.componentWillUnmount = function() {
  this.o = [];
}, P.prototype.render = function(n2, e2) {
  if (this.__b) {
    if (this.__v.__k) {
      var r2 = document.createElement("div"), o2 = this.__v.__k[0].__c;
      this.__v.__k[0] = V(this.__b, r2, o2.__O = o2.__P);
    }
    this.__b = null;
  }
  var i2 = e2.__a && _$1(k$2, null, n2.fallback);
  return i2 && (i2.__u &= -33), [_$1(k$2, null, e2.__a ? null : n2.children), i2];
};
var H = function(n2, t2, e2) {
  if (++e2[1] === e2[0] && n2.l.delete(t2), n2.props.revealOrder && ("t" !== n2.props.revealOrder[0] || !n2.l.size)) for (e2 = n2.i; e2; ) {
    for (; e2.length > 3; ) e2.pop()();
    if (e2[1] < e2[0]) break;
    n2.i = e2 = e2[2];
  }
};
function Z(n2) {
  return this.getChildContext = function() {
    return n2.context;
  }, n2.children;
}
function Y(n2) {
  var e2 = this, r2 = n2.h;
  if (e2.componentWillUnmount = function() {
    G$1(null, e2.v), e2.v = null, e2.h = null;
  }, e2.h && e2.h !== r2 && e2.componentWillUnmount(), !e2.v) {
    for (var u2 = e2.__v; null !== u2 && !u2.__m && null !== u2.__; ) u2 = u2.__;
    e2.h = r2, e2.v = { nodeType: 1, parentNode: r2, childNodes: [], __k: { __m: u2.__m }, contains: function() {
      return true;
    }, insertBefore: function(n3, t2) {
      this.childNodes.push(n3), e2.h.insertBefore(n3, t2);
    }, removeChild: function(n3) {
      this.childNodes.splice(this.childNodes.indexOf(n3) >>> 1, 1), e2.h.removeChild(n3);
    } };
  }
  G$1(_$1(Z, { context: e2.context }, n2.__v), e2.v);
}
function $(n2, e2) {
  var r2 = _$1(Y, { __v: n2, h: e2 });
  return r2.containerInfo = e2, r2;
}
(B.prototype = new x$2()).__a = function(n2) {
  var t2 = this, e2 = j(t2.__v), r2 = t2.l.get(n2);
  return r2[0]++, function(u2) {
    var o2 = function() {
      t2.props.revealOrder ? (r2.push(u2), H(t2, n2, r2)) : u2();
    };
    e2 ? e2(o2) : o2();
  };
}, B.prototype.render = function(n2) {
  this.i = null, this.l = /* @__PURE__ */ new Map();
  var t2 = H$1(n2.children);
  n2.revealOrder && "b" === n2.revealOrder[0] && t2.reverse();
  for (var e2 = t2.length; e2--; ) this.l.set(t2[e2], this.i = [1, 0, this.i]);
  return n2.children;
}, B.prototype.componentDidUpdate = B.prototype.componentDidMount = function() {
  var n2 = this;
  this.l.forEach(function(t2, e2) {
    H(n2, e2, t2);
  });
};
var q = "undefined" != typeof Symbol && Symbol.for && /* @__PURE__ */ Symbol.for("react.element") || 60103, G = /^(?:accent|alignment|arabic|baseline|cap|clip(?!PathU)|color|dominant|fill|flood|font|glyph(?!R)|horiz|image(!S)|letter|lighting|marker(?!H|W|U)|overline|paint|pointer|shape|stop|strikethrough|stroke|text(?!L)|transform|underline|unicode|units|v|vector|vert|word|writing|x(?!C))[A-Z]/, J = /^on(Ani|Tra|Tou|BeforeInp|Compo)/, K = /[A-Z0-9]/g, Q = "undefined" != typeof document, X = function(n2) {
  return ("undefined" != typeof Symbol && "symbol" == typeof /* @__PURE__ */ Symbol() ? /fil|che|rad/ : /fil|che|ra/).test(n2);
};
function nn(n2, t2, e2) {
  return null == t2.__k && (t2.textContent = ""), G$1(n2, t2), "function" == typeof e2 && e2(), n2 ? n2.__c : null;
}
function tn(n2, t2, e2) {
  return J$1(n2, t2), "function" == typeof e2 && e2(), n2 ? n2.__c : null;
}
x$2.prototype.isReactComponent = {}, ["componentWillMount", "componentWillReceiveProps", "componentWillUpdate"].forEach(function(t2) {
  Object.defineProperty(x$2.prototype, t2, { configurable: true, get: function() {
    return this["UNSAFE_" + t2];
  }, set: function(n2) {
    Object.defineProperty(this, t2, { configurable: true, writable: true, value: n2 });
  } });
});
var en = l$2.event;
function rn() {
}
function un() {
  return this.cancelBubble;
}
function on() {
  return this.defaultPrevented;
}
l$2.event = function(n2) {
  return en && (n2 = en(n2)), n2.persist = rn, n2.isPropagationStopped = un, n2.isDefaultPrevented = on, n2.nativeEvent = n2;
};
var ln, cn = { enumerable: false, configurable: true, get: function() {
  return this.class;
} }, fn = l$2.vnode;
l$2.vnode = function(n2) {
  "string" == typeof n2.type && (function(n3) {
    var t2 = n3.props, e2 = n3.type, u2 = {}, o2 = -1 === e2.indexOf("-");
    for (var i2 in t2) {
      var l2 = t2[i2];
      if (!("value" === i2 && "defaultValue" in t2 && null == l2 || Q && "children" === i2 && "noscript" === e2 || "class" === i2 || "className" === i2)) {
        var c2 = i2.toLowerCase();
        "defaultValue" === i2 && "value" in t2 && null == t2.value ? i2 = "value" : "download" === i2 && true === l2 ? l2 = "" : "translate" === c2 && "no" === l2 ? l2 = false : "o" === c2[0] && "n" === c2[1] ? "ondoubleclick" === c2 ? i2 = "ondblclick" : "onchange" !== c2 || "input" !== e2 && "textarea" !== e2 || X(t2.type) ? "onfocus" === c2 ? i2 = "onfocusin" : "onblur" === c2 ? i2 = "onfocusout" : J.test(i2) && (i2 = c2) : c2 = i2 = "oninput" : o2 && G.test(i2) ? i2 = i2.replace(K, "-$&").toLowerCase() : null === l2 && (l2 = void 0), "oninput" === c2 && u2[i2 = c2] && (i2 = "oninputCapture"), u2[i2] = l2;
      }
    }
    "select" == e2 && u2.multiple && Array.isArray(u2.value) && (u2.value = H$1(t2.children).forEach(function(n4) {
      n4.props.selected = -1 != u2.value.indexOf(n4.props.value);
    })), "select" == e2 && null != u2.defaultValue && (u2.value = H$1(t2.children).forEach(function(n4) {
      n4.props.selected = u2.multiple ? -1 != u2.defaultValue.indexOf(n4.props.value) : u2.defaultValue == n4.props.value;
    })), t2.class && !t2.className ? (u2.class = t2.class, Object.defineProperty(u2, "className", cn)) : (t2.className && !t2.class || t2.class && t2.className) && (u2.class = u2.className = t2.className), n3.props = u2;
  })(n2), n2.$$typeof = q, fn && fn(n2);
};
var an = l$2.__r;
l$2.__r = function(n2) {
  an && an(n2), ln = n2.__c;
};
var sn = l$2.diffed;
l$2.diffed = function(n2) {
  sn && sn(n2);
  var t2 = n2.props, e2 = n2.__e;
  null != e2 && "textarea" === n2.type && "value" in t2 && t2.value !== e2.value && (e2.value = null == t2.value ? "" : t2.value), ln = null;
};
var hn = { ReactCurrentDispatcher: { current: { readContext: function(n2) {
  return ln.__n[n2.__c].props.value;
}, useCallback: q$1, useContext: x$1, useDebugValue: P$1, useDeferredValue: w, useEffect: y, useId: g$1, useImperativeHandle: F$1, useInsertionEffect: I, useLayoutEffect: _, useMemo: T$1, useReducer: h, useRef: A$1, useState: d, useSyncExternalStore: C, useTransition: k } } }, vn = "18.3.1";
function dn(n2) {
  return _$1.bind(null, n2);
}
function mn(n2) {
  return !!n2 && n2.$$typeof === q;
}
function pn(n2) {
  return mn(n2) && n2.type === k$2;
}
function yn(n2) {
  return !!n2 && !!n2.displayName && ("string" == typeof n2.displayName || n2.displayName instanceof String) && n2.displayName.startsWith("Memo(");
}
function _n(n2) {
  return mn(n2) ? K$1.apply(null, arguments) : n2;
}
function bn(n2) {
  return !!n2.__k && (G$1(null, n2), true);
}
function Sn(n2) {
  return n2 && (n2.base || 1 === n2.nodeType && n2) || null;
}
var gn = function(n2, t2) {
  return n2(t2);
}, En = function(n2, t2) {
  return n2(t2);
}, Cn = k$2, xn = mn, Rn = { useState: d, useId: g$1, useReducer: h, useEffect: y, useLayoutEffect: _, useInsertionEffect: I, useTransition: k, useDeferredValue: w, useSyncExternalStore: C, startTransition: R, useRef: A$1, useImperativeHandle: F$1, useMemo: T$1, useCallback: q$1, useContext: x$1, useDebugValue: P$1, version: "18.3.1", Children: O, render: nn, hydrate: tn, unmountComponentAtNode: bn, createPortal: $, createElement: _$1, createContext: Q$1, createFactory: dn, cloneElement: _n, createRef: b$1, Fragment: k$2, isValidElement: mn, isElement: xn, isFragment: pn, isMemo: yn, findDOMNode: Sn, Component: x$2, PureComponent: N, memo: M, forwardRef: D, flushSync: En, unstable_batchedUpdates: gn, StrictMode: Cn, Suspense: P, SuspenseList: B, lazy: z, __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED: hn };
const compat_module = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Children: O,
  Component: x$2,
  Fragment: k$2,
  PureComponent: N,
  StrictMode: Cn,
  Suspense: P,
  SuspenseList: B,
  __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED: hn,
  cloneElement: _n,
  createContext: Q$1,
  createElement: _$1,
  createFactory: dn,
  createPortal: $,
  createRef: b$1,
  default: Rn,
  findDOMNode: Sn,
  flushSync: En,
  forwardRef: D,
  hydrate: tn,
  isElement: xn,
  isFragment: pn,
  isMemo: yn,
  isValidElement: mn,
  lazy: z,
  memo: M,
  render: nn,
  startTransition: R,
  unmountComponentAtNode: bn,
  unstable_batchedUpdates: gn,
  useCallback: q$1,
  useContext: x$1,
  useDebugValue: P$1,
  useDeferredValue: w,
  useEffect: y,
  useErrorBoundary: b,
  useId: g$1,
  useImperativeHandle: F$1,
  useInsertionEffect: I,
  useLayoutEffect: _,
  useMemo: T$1,
  useReducer: h,
  useRef: A$1,
  useState: d,
  useSyncExternalStore: C,
  useTransition: k,
  version: vn
}, Symbol.toStringTag, { value: "Module" }));
var reactIs = { exports: {} };
var reactIs_production_min = {};
var hasRequiredReactIs_production_min;
function requireReactIs_production_min() {
  if (hasRequiredReactIs_production_min) return reactIs_production_min;
  hasRequiredReactIs_production_min = 1;
  var b2 = /* @__PURE__ */ Symbol.for("react.element"), c2 = /* @__PURE__ */ Symbol.for("react.portal"), d2 = /* @__PURE__ */ Symbol.for("react.fragment"), e2 = /* @__PURE__ */ Symbol.for("react.strict_mode"), f2 = /* @__PURE__ */ Symbol.for("react.profiler"), g2 = /* @__PURE__ */ Symbol.for("react.provider"), h2 = /* @__PURE__ */ Symbol.for("react.context"), k2 = /* @__PURE__ */ Symbol.for("react.server_context"), l2 = /* @__PURE__ */ Symbol.for("react.forward_ref"), m2 = /* @__PURE__ */ Symbol.for("react.suspense"), n2 = /* @__PURE__ */ Symbol.for("react.suspense_list"), p2 = /* @__PURE__ */ Symbol.for("react.memo"), q2 = /* @__PURE__ */ Symbol.for("react.lazy"), t2 = /* @__PURE__ */ Symbol.for("react.offscreen"), u2;
  u2 = /* @__PURE__ */ Symbol.for("react.module.reference");
  function v2(a2) {
    if ("object" === typeof a2 && null !== a2) {
      var r2 = a2.$$typeof;
      switch (r2) {
        case b2:
          switch (a2 = a2.type, a2) {
            case d2:
            case f2:
            case e2:
            case m2:
            case n2:
              return a2;
            default:
              switch (a2 = a2 && a2.$$typeof, a2) {
                case k2:
                case h2:
                case l2:
                case q2:
                case p2:
                case g2:
                  return a2;
                default:
                  return r2;
              }
          }
        case c2:
          return r2;
      }
    }
  }
  reactIs_production_min.ContextConsumer = h2;
  reactIs_production_min.ContextProvider = g2;
  reactIs_production_min.Element = b2;
  reactIs_production_min.ForwardRef = l2;
  reactIs_production_min.Fragment = d2;
  reactIs_production_min.Lazy = q2;
  reactIs_production_min.Memo = p2;
  reactIs_production_min.Portal = c2;
  reactIs_production_min.Profiler = f2;
  reactIs_production_min.StrictMode = e2;
  reactIs_production_min.Suspense = m2;
  reactIs_production_min.SuspenseList = n2;
  reactIs_production_min.isAsyncMode = function() {
    return false;
  };
  reactIs_production_min.isConcurrentMode = function() {
    return false;
  };
  reactIs_production_min.isContextConsumer = function(a2) {
    return v2(a2) === h2;
  };
  reactIs_production_min.isContextProvider = function(a2) {
    return v2(a2) === g2;
  };
  reactIs_production_min.isElement = function(a2) {
    return "object" === typeof a2 && null !== a2 && a2.$$typeof === b2;
  };
  reactIs_production_min.isForwardRef = function(a2) {
    return v2(a2) === l2;
  };
  reactIs_production_min.isFragment = function(a2) {
    return v2(a2) === d2;
  };
  reactIs_production_min.isLazy = function(a2) {
    return v2(a2) === q2;
  };
  reactIs_production_min.isMemo = function(a2) {
    return v2(a2) === p2;
  };
  reactIs_production_min.isPortal = function(a2) {
    return v2(a2) === c2;
  };
  reactIs_production_min.isProfiler = function(a2) {
    return v2(a2) === f2;
  };
  reactIs_production_min.isStrictMode = function(a2) {
    return v2(a2) === e2;
  };
  reactIs_production_min.isSuspense = function(a2) {
    return v2(a2) === m2;
  };
  reactIs_production_min.isSuspenseList = function(a2) {
    return v2(a2) === n2;
  };
  reactIs_production_min.isValidElementType = function(a2) {
    return "string" === typeof a2 || "function" === typeof a2 || a2 === d2 || a2 === f2 || a2 === e2 || a2 === m2 || a2 === n2 || a2 === t2 || "object" === typeof a2 && null !== a2 && (a2.$$typeof === q2 || a2.$$typeof === p2 || a2.$$typeof === g2 || a2.$$typeof === h2 || a2.$$typeof === l2 || a2.$$typeof === u2 || void 0 !== a2.getModuleId) ? true : false;
  };
  reactIs_production_min.typeOf = v2;
  return reactIs_production_min;
}
var reactIs_development = {};
var hasRequiredReactIs_development;
function requireReactIs_development() {
  if (hasRequiredReactIs_development) return reactIs_development;
  hasRequiredReactIs_development = 1;
  if (process.env.NODE_ENV !== "production") {
    (function() {
      var REACT_ELEMENT_TYPE = /* @__PURE__ */ Symbol.for("react.element");
      var REACT_PORTAL_TYPE = /* @__PURE__ */ Symbol.for("react.portal");
      var REACT_FRAGMENT_TYPE = /* @__PURE__ */ Symbol.for("react.fragment");
      var REACT_STRICT_MODE_TYPE = /* @__PURE__ */ Symbol.for("react.strict_mode");
      var REACT_PROFILER_TYPE = /* @__PURE__ */ Symbol.for("react.profiler");
      var REACT_PROVIDER_TYPE = /* @__PURE__ */ Symbol.for("react.provider");
      var REACT_CONTEXT_TYPE = /* @__PURE__ */ Symbol.for("react.context");
      var REACT_SERVER_CONTEXT_TYPE = /* @__PURE__ */ Symbol.for("react.server_context");
      var REACT_FORWARD_REF_TYPE = /* @__PURE__ */ Symbol.for("react.forward_ref");
      var REACT_SUSPENSE_TYPE = /* @__PURE__ */ Symbol.for("react.suspense");
      var REACT_SUSPENSE_LIST_TYPE = /* @__PURE__ */ Symbol.for("react.suspense_list");
      var REACT_MEMO_TYPE = /* @__PURE__ */ Symbol.for("react.memo");
      var REACT_LAZY_TYPE = /* @__PURE__ */ Symbol.for("react.lazy");
      var REACT_OFFSCREEN_TYPE = /* @__PURE__ */ Symbol.for("react.offscreen");
      var enableScopeAPI = false;
      var enableCacheElement = false;
      var enableTransitionTracing = false;
      var enableLegacyHidden = false;
      var enableDebugTracing = false;
      var REACT_MODULE_REFERENCE;
      {
        REACT_MODULE_REFERENCE = /* @__PURE__ */ Symbol.for("react.module.reference");
      }
      function isValidElementType(type) {
        if (typeof type === "string" || typeof type === "function") {
          return true;
        }
        if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || enableDebugTracing || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden || type === REACT_OFFSCREEN_TYPE || enableScopeAPI || enableCacheElement || enableTransitionTracing) {
          return true;
        }
        if (typeof type === "object" && type !== null) {
          if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || // This needs to include all possible module reference object
          // types supported by any Flight configuration anywhere since
          // we don't know which Flight build this will end up being used
          // with.
          type.$$typeof === REACT_MODULE_REFERENCE || type.getModuleId !== void 0) {
            return true;
          }
        }
        return false;
      }
      function typeOf(object) {
        if (typeof object === "object" && object !== null) {
          var $$typeof = object.$$typeof;
          switch ($$typeof) {
            case REACT_ELEMENT_TYPE:
              var type = object.type;
              switch (type) {
                case REACT_FRAGMENT_TYPE:
                case REACT_PROFILER_TYPE:
                case REACT_STRICT_MODE_TYPE:
                case REACT_SUSPENSE_TYPE:
                case REACT_SUSPENSE_LIST_TYPE:
                  return type;
                default:
                  var $$typeofType = type && type.$$typeof;
                  switch ($$typeofType) {
                    case REACT_SERVER_CONTEXT_TYPE:
                    case REACT_CONTEXT_TYPE:
                    case REACT_FORWARD_REF_TYPE:
                    case REACT_LAZY_TYPE:
                    case REACT_MEMO_TYPE:
                    case REACT_PROVIDER_TYPE:
                      return $$typeofType;
                    default:
                      return $$typeof;
                  }
              }
            case REACT_PORTAL_TYPE:
              return $$typeof;
          }
        }
        return void 0;
      }
      var ContextConsumer = REACT_CONTEXT_TYPE;
      var ContextProvider = REACT_PROVIDER_TYPE;
      var Element2 = REACT_ELEMENT_TYPE;
      var ForwardRef = REACT_FORWARD_REF_TYPE;
      var Fragment = REACT_FRAGMENT_TYPE;
      var Lazy = REACT_LAZY_TYPE;
      var Memo = REACT_MEMO_TYPE;
      var Portal = REACT_PORTAL_TYPE;
      var Profiler = REACT_PROFILER_TYPE;
      var StrictMode = REACT_STRICT_MODE_TYPE;
      var Suspense = REACT_SUSPENSE_TYPE;
      var SuspenseList = REACT_SUSPENSE_LIST_TYPE;
      var hasWarnedAboutDeprecatedIsAsyncMode = false;
      var hasWarnedAboutDeprecatedIsConcurrentMode = false;
      function isAsyncMode(object) {
        {
          if (!hasWarnedAboutDeprecatedIsAsyncMode) {
            hasWarnedAboutDeprecatedIsAsyncMode = true;
            console["warn"]("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 18+.");
          }
        }
        return false;
      }
      function isConcurrentMode(object) {
        {
          if (!hasWarnedAboutDeprecatedIsConcurrentMode) {
            hasWarnedAboutDeprecatedIsConcurrentMode = true;
            console["warn"]("The ReactIs.isConcurrentMode() alias has been deprecated, and will be removed in React 18+.");
          }
        }
        return false;
      }
      function isContextConsumer(object) {
        return typeOf(object) === REACT_CONTEXT_TYPE;
      }
      function isContextProvider(object) {
        return typeOf(object) === REACT_PROVIDER_TYPE;
      }
      function isElement(object) {
        return typeof object === "object" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
      }
      function isForwardRef(object) {
        return typeOf(object) === REACT_FORWARD_REF_TYPE;
      }
      function isFragment(object) {
        return typeOf(object) === REACT_FRAGMENT_TYPE;
      }
      function isLazy(object) {
        return typeOf(object) === REACT_LAZY_TYPE;
      }
      function isMemo(object) {
        return typeOf(object) === REACT_MEMO_TYPE;
      }
      function isPortal(object) {
        return typeOf(object) === REACT_PORTAL_TYPE;
      }
      function isProfiler(object) {
        return typeOf(object) === REACT_PROFILER_TYPE;
      }
      function isStrictMode(object) {
        return typeOf(object) === REACT_STRICT_MODE_TYPE;
      }
      function isSuspense(object) {
        return typeOf(object) === REACT_SUSPENSE_TYPE;
      }
      function isSuspenseList(object) {
        return typeOf(object) === REACT_SUSPENSE_LIST_TYPE;
      }
      reactIs_development.ContextConsumer = ContextConsumer;
      reactIs_development.ContextProvider = ContextProvider;
      reactIs_development.Element = Element2;
      reactIs_development.ForwardRef = ForwardRef;
      reactIs_development.Fragment = Fragment;
      reactIs_development.Lazy = Lazy;
      reactIs_development.Memo = Memo;
      reactIs_development.Portal = Portal;
      reactIs_development.Profiler = Profiler;
      reactIs_development.StrictMode = StrictMode;
      reactIs_development.Suspense = Suspense;
      reactIs_development.SuspenseList = SuspenseList;
      reactIs_development.isAsyncMode = isAsyncMode;
      reactIs_development.isConcurrentMode = isConcurrentMode;
      reactIs_development.isContextConsumer = isContextConsumer;
      reactIs_development.isContextProvider = isContextProvider;
      reactIs_development.isElement = isElement;
      reactIs_development.isForwardRef = isForwardRef;
      reactIs_development.isFragment = isFragment;
      reactIs_development.isLazy = isLazy;
      reactIs_development.isMemo = isMemo;
      reactIs_development.isPortal = isPortal;
      reactIs_development.isProfiler = isProfiler;
      reactIs_development.isStrictMode = isStrictMode;
      reactIs_development.isSuspense = isSuspense;
      reactIs_development.isSuspenseList = isSuspenseList;
      reactIs_development.isValidElementType = isValidElementType;
      reactIs_development.typeOf = typeOf;
    })();
  }
  return reactIs_development;
}
var hasRequiredReactIs;
function requireReactIs() {
  if (hasRequiredReactIs) return reactIs.exports;
  hasRequiredReactIs = 1;
  if (process.env.NODE_ENV === "production") {
    reactIs.exports = requireReactIs_production_min();
  } else {
    reactIs.exports = requireReactIs_development();
  }
  return reactIs.exports;
}
var reactIsExports = requireReactIs();
const t = (t2) => "object" == typeof t2 && null != t2 && 1 === t2.nodeType, e = (t2, e2) => (!e2 || "hidden" !== t2) && ("visible" !== t2 && "clip" !== t2), n = (t2, n2) => {
  if (t2.clientHeight < t2.scrollHeight || t2.clientWidth < t2.scrollWidth) {
    const o2 = getComputedStyle(t2, null);
    return e(o2.overflowY, n2) || e(o2.overflowX, n2) || ((t3) => {
      const e2 = ((t4) => {
        if (!t4.ownerDocument || !t4.ownerDocument.defaultView) return null;
        try {
          return t4.ownerDocument.defaultView.frameElement;
        } catch (t5) {
          return null;
        }
      })(t3);
      return !!e2 && (e2.clientHeight < t3.scrollHeight || e2.clientWidth < t3.scrollWidth);
    })(t2);
  }
  return false;
}, o = (t2, e2, n2, o2, l2, r2, i2, s2) => r2 < t2 && i2 > e2 || r2 > t2 && i2 < e2 ? 0 : r2 <= t2 && s2 <= n2 || i2 >= e2 && s2 >= n2 ? r2 - t2 - o2 : i2 > e2 && s2 < n2 || r2 < t2 && s2 > n2 ? i2 - e2 + l2 : 0, l = (t2) => {
  const e2 = t2.parentElement;
  return null == e2 ? t2.getRootNode().host || null : e2;
}, r = (e2, r2) => {
  var i2, s2, d2, h2;
  if ("undefined" == typeof document) return [];
  const { inline: u2, boundary: a2, skipOverflowHiddenElements: g2 } = r2, p2 = "function" == typeof a2 ? a2 : (t2) => t2 !== a2;
  if (!t(e2)) throw new TypeError("Invalid target");
  const m2 = document.scrollingElement || document.documentElement, w2 = [];
  let W2 = e2;
  for (; t(W2) && p2(W2); ) {
    if (W2 = l(W2), W2 === m2) {
      w2.push(W2);
      break;
    }
    null != W2 && W2 === document.body && n(W2) && !n(document.documentElement) || null != W2 && n(W2, g2) && w2.push(W2);
  }
  const b2 = null != (s2 = null == (i2 = window.visualViewport) ? void 0 : i2.width) ? s2 : innerWidth, H2 = null != (h2 = null == (d2 = window.visualViewport) ? void 0 : d2.height) ? h2 : innerHeight, { scrollX: y2, scrollY: M2 } = window, { height: v2, width: E2, top: x2, right: C2, bottom: I2, left: R2 } = e2.getBoundingClientRect(), { top: T2, right: B2, left: V2 } = ((t2) => {
    const e3 = window.getComputedStyle(t2);
    return { top: parseFloat(e3.scrollMarginTop) || 0, right: parseFloat(e3.scrollMarginRight) || 0, bottom: parseFloat(e3.scrollMarginBottom) || 0, left: parseFloat(e3.scrollMarginLeft) || 0 };
  })(e2);
  let k2 = x2 - T2, D2 = "center" === u2 ? R2 + E2 / 2 - V2 + B2 : "end" === u2 ? C2 + B2 : R2 - V2;
  const L2 = [];
  for (let t2 = 0; t2 < w2.length; t2++) {
    const e3 = w2[t2], { height: l2, width: r3, top: i3, right: s3, bottom: d3, left: h3 } = e3.getBoundingClientRect();
    if (x2 >= 0 && R2 >= 0 && I2 <= H2 && C2 <= b2 && (e3 === m2 && !n(e3) || x2 >= i3 && I2 <= d3 && R2 >= h3 && C2 <= s3)) return L2;
    const a3 = getComputedStyle(e3), g3 = parseInt(a3.borderLeftWidth, 10), p3 = parseInt(a3.borderTopWidth, 10), W3 = parseInt(a3.borderRightWidth, 10), T3 = parseInt(a3.borderBottomWidth, 10);
    let B3 = 0, F2 = 0;
    const V3 = "offsetWidth" in e3 ? e3.offsetWidth - e3.clientWidth - g3 - W3 : 0, S2 = "offsetHeight" in e3 ? e3.offsetHeight - e3.clientHeight - p3 - T3 : 0, X2 = "offsetWidth" in e3 ? 0 === e3.offsetWidth ? 0 : r3 / e3.offsetWidth : 0, Y2 = "offsetHeight" in e3 ? 0 === e3.offsetHeight ? 0 : l2 / e3.offsetHeight : 0;
    if (m2 === e3) B3 = o(M2, M2 + H2, H2, p3, T3, M2 + k2, M2 + k2 + v2, v2), F2 = "start" === u2 ? D2 : "center" === u2 ? D2 - b2 / 2 : "end" === u2 ? D2 - b2 : o(y2, y2 + b2, b2, g3, W3, y2 + D2, y2 + D2 + E2, E2), B3 = Math.max(0, B3 + M2), F2 = Math.max(0, F2 + y2);
    else {
      B3 = o(i3, d3, l2, p3, T3 + S2, k2, k2 + v2, v2), F2 = "start" === u2 ? D2 - h3 - g3 : "center" === u2 ? D2 - (h3 + r3 / 2) + V3 / 2 : "end" === u2 ? D2 - s3 + W3 + V3 : o(h3, s3, r3, g3, W3 + V3, D2, D2 + E2, E2);
      const { scrollLeft: t3, scrollTop: n2 } = e3;
      B3 = 0 === Y2 ? 0 : Math.max(0, Math.min(n2 + B3 / Y2, e3.scrollHeight - l2 / Y2 + S2)), F2 = 0 === X2 ? 0 : Math.max(0, Math.min(t3 + F2 / X2, e3.scrollWidth - r3 / X2 + V3)), k2 += n2 - B3, D2 += t3 - F2;
    }
    L2.push({ el: e3, top: B3, left: F2 });
  }
  return L2;
};
var __assign = function() {
  __assign = Object.assign || function __assign2(t2) {
    for (var s2, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
      s2 = arguments[i2];
      for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2)) t2[p2] = s2[p2];
    }
    return t2;
  };
  return __assign.apply(this, arguments);
};
typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message) {
  var e2 = new Error(message);
  return e2.name = "SuppressedError", e2.error = error, e2.suppressed = suppressed, e2;
};
var idCounter = 0;
function cbToCb(cb) {
  return typeof cb === "function" ? cb : noop;
}
function noop() {
}
function scrollIntoView(node, menuNode) {
  if (!node) {
    return;
  }
  var actions = r(node, {
    boundary: menuNode
  });
  actions.forEach(function(_ref) {
    var el = _ref.el, top = _ref.top, left = _ref.left;
    el.scrollTop = top;
    el.scrollLeft = left;
  });
}
function isOrContainsNode(parent, child, environment) {
  var result = parent === child || child instanceof environment.Node && parent.contains && parent.contains(child);
  return result;
}
function debounce(fn2, time) {
  var timeoutId;
  function cancel() {
    if (timeoutId) {
      clearTimeout(timeoutId);
    }
  }
  function wrapper() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    cancel();
    timeoutId = setTimeout(function() {
      timeoutId = null;
      fn2.apply(void 0, args);
    }, time);
  }
  wrapper.cancel = cancel;
  return wrapper;
}
function callAllEventHandlers() {
  for (var _len2 = arguments.length, fns = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
    fns[_key2] = arguments[_key2];
  }
  return function(event) {
    for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
      args[_key3 - 1] = arguments[_key3];
    }
    return fns.some(function(fn2) {
      if (fn2) {
        fn2.apply(void 0, [event].concat(args));
      }
      return event.preventDownshiftDefault || event.hasOwnProperty("nativeEvent") && event.nativeEvent.preventDownshiftDefault;
    });
  };
}
function handleRefs() {
  for (var _len4 = arguments.length, refs = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
    refs[_key4] = arguments[_key4];
  }
  return function(node) {
    refs.forEach(function(ref) {
      if (typeof ref === "function") {
        ref(node);
      } else if (ref) {
        ref.current = node;
      }
    });
  };
}
function generateId() {
  return String(idCounter++);
}
function getA11yStatusMessage(_ref2) {
  var isOpen = _ref2.isOpen, resultCount = _ref2.resultCount, previousResultCount = _ref2.previousResultCount;
  if (!isOpen) {
    return "";
  }
  if (!resultCount) {
    return "No results are available.";
  }
  if (resultCount !== previousResultCount) {
    return resultCount + " result" + (resultCount === 1 ? " is" : "s are") + " available, use up and down arrow keys to navigate. Press Enter key to select.";
  }
  return "";
}
function unwrapArray(arg, defaultValue) {
  arg = Array.isArray(arg) ? (
    /* istanbul ignore next (preact) */
    arg[0]
  ) : arg;
  if (!arg && defaultValue) {
    return defaultValue;
  } else {
    return arg;
  }
}
function isDOMElement(element) {
  return typeof element.type === "string";
}
function getElementProps(element) {
  return element.props;
}
function requiredProp(fnName, propName) {
  console.error('The property "' + propName + '" is required in "' + fnName + '"');
}
var stateKeys = ["highlightedIndex", "inputValue", "isOpen", "selectedItem", "type"];
function pickState(state2) {
  if (state2 === void 0) {
    state2 = {};
  }
  var result = {};
  stateKeys.forEach(function(k2) {
    if (state2.hasOwnProperty(k2)) {
      result[k2] = state2[k2];
    }
  });
  return result;
}
function getState(state2, props) {
  if (!state2 || !props) {
    return state2;
  }
  return Object.keys(state2).reduce(function(prevState, key) {
    prevState[key] = isControlledProp(props, key) ? props[key] : state2[key];
    return prevState;
  }, {});
}
function isControlledProp(props, key) {
  return props[key] !== void 0;
}
function normalizeArrowKey(event) {
  var key = event.key, keyCode = event.keyCode;
  if (keyCode >= 37 && keyCode <= 40 && key.indexOf("Arrow") !== 0) {
    return "Arrow" + key;
  }
  return key;
}
function isPlainObject(obj) {
  return Object.prototype.toString.call(obj) === "[object Object]";
}
function getHighlightedIndex(start, offset, items, isItemDisabled2, circular) {
  if (circular === void 0) {
    circular = false;
  }
  var count2 = items.length;
  if (count2 === 0) {
    return -1;
  }
  var itemsLastIndex = count2 - 1;
  if (typeof start !== "number" || start < 0 || start > itemsLastIndex) {
    start = offset > 0 ? -1 : itemsLastIndex + 1;
  }
  var current = start + offset;
  if (current < 0) {
    current = circular ? itemsLastIndex : 0;
  } else if (current > itemsLastIndex) {
    current = circular ? 0 : itemsLastIndex;
  }
  var highlightedIndex = getNonDisabledIndex(current, offset < 0, items, isItemDisabled2, circular);
  if (highlightedIndex === -1) {
    return start >= count2 ? -1 : start;
  }
  return highlightedIndex;
}
function getNonDisabledIndex(start, backwards, items, isItemDisabled2, circular) {
  if (circular === void 0) {
    circular = false;
  }
  var count2 = items.length;
  if (backwards) {
    for (var index = start; index >= 0; index--) {
      if (!isItemDisabled2(items[index], index)) {
        return index;
      }
    }
  } else {
    for (var _index = start; _index < count2; _index++) {
      if (!isItemDisabled2(items[_index], _index)) {
        return _index;
      }
    }
  }
  if (circular) {
    return getNonDisabledIndex(backwards ? count2 - 1 : 0, backwards, items, isItemDisabled2);
  }
  return -1;
}
function targetWithinDownshift(target, downshiftElements, environment, checkActiveElement) {
  if (checkActiveElement === void 0) {
    checkActiveElement = true;
  }
  return environment && downshiftElements.some(function(contextNode) {
    return contextNode && (isOrContainsNode(contextNode, target, environment) || checkActiveElement && isOrContainsNode(contextNode, environment.document.activeElement, environment));
  });
}
var validateControlledUnchanged = noop;
if (process.env.NODE_ENV !== "production") {
  validateControlledUnchanged = function validateControlledUnchanged2(state2, prevProps, nextProps) {
    var warningDescription = "This prop should not switch from controlled to uncontrolled (or vice versa). Decide between using a controlled or uncontrolled Downshift element for the lifetime of the component. More info: https://github.com/downshift-js/downshift#control-props";
    Object.keys(state2).forEach(function(propKey) {
      if (prevProps[propKey] !== void 0 && nextProps[propKey] === void 0) {
        console.error('downshift: A component has changed the controlled prop "' + propKey + '" to be uncontrolled. ' + warningDescription);
      } else if (prevProps[propKey] === void 0 && nextProps[propKey] !== void 0) {
        console.error('downshift: A component has changed the uncontrolled prop "' + propKey + '" to be controlled. ' + warningDescription);
      }
    });
  };
}
var cleanupStatus = debounce(function(documentProp) {
  getStatusDiv(documentProp).textContent = "";
}, 500);
function getStatusDiv(documentProp) {
  var statusDiv = documentProp.getElementById("a11y-status-message");
  if (statusDiv) {
    return statusDiv;
  }
  statusDiv = documentProp.createElement("div");
  statusDiv.setAttribute("id", "a11y-status-message");
  statusDiv.setAttribute("role", "status");
  statusDiv.setAttribute("aria-live", "polite");
  statusDiv.setAttribute("aria-relevant", "additions text");
  Object.assign(statusDiv.style, {
    border: "0",
    clip: "rect(0 0 0 0)",
    height: "1px",
    margin: "-1px",
    overflow: "hidden",
    padding: "0",
    position: "absolute",
    width: "1px"
  });
  documentProp.body.appendChild(statusDiv);
  return statusDiv;
}
function setStatus(status, documentProp) {
  if (!status || !documentProp) {
    return;
  }
  var div = getStatusDiv(documentProp);
  div.textContent = status;
  cleanupStatus(documentProp);
}
function cleanupStatusDiv(documentProp) {
  var statusDiv = documentProp == null ? void 0 : documentProp.getElementById("a11y-status-message");
  if (statusDiv) {
    statusDiv.remove();
  }
}
var unknown = process.env.NODE_ENV !== "production" ? "__autocomplete_unknown__" : 0;
var mouseUp = process.env.NODE_ENV !== "production" ? "__autocomplete_mouseup__" : 1;
var itemMouseEnter = process.env.NODE_ENV !== "production" ? "__autocomplete_item_mouseenter__" : 2;
var keyDownArrowUp = process.env.NODE_ENV !== "production" ? "__autocomplete_keydown_arrow_up__" : 3;
var keyDownArrowDown = process.env.NODE_ENV !== "production" ? "__autocomplete_keydown_arrow_down__" : 4;
var keyDownEscape = process.env.NODE_ENV !== "production" ? "__autocomplete_keydown_escape__" : 5;
var keyDownEnter = process.env.NODE_ENV !== "production" ? "__autocomplete_keydown_enter__" : 6;
var keyDownHome = process.env.NODE_ENV !== "production" ? "__autocomplete_keydown_home__" : 7;
var keyDownEnd = process.env.NODE_ENV !== "production" ? "__autocomplete_keydown_end__" : 8;
var clickItem = process.env.NODE_ENV !== "production" ? "__autocomplete_click_item__" : 9;
var blurInput = process.env.NODE_ENV !== "production" ? "__autocomplete_blur_input__" : 10;
var changeInput = process.env.NODE_ENV !== "production" ? "__autocomplete_change_input__" : 11;
var keyDownSpaceButton = process.env.NODE_ENV !== "production" ? "__autocomplete_keydown_space_button__" : 12;
var clickButton = process.env.NODE_ENV !== "production" ? "__autocomplete_click_button__" : 13;
var blurButton = process.env.NODE_ENV !== "production" ? "__autocomplete_blur_button__" : 14;
var controlledPropUpdatedSelectedItem = process.env.NODE_ENV !== "production" ? "__autocomplete_controlled_prop_updated_selected_item__" : 15;
var touchEnd = process.env.NODE_ENV !== "production" ? "__autocomplete_touchend__" : 16;
var stateChangeTypes$3 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  blurButton,
  blurInput,
  changeInput,
  clickButton,
  clickItem,
  controlledPropUpdatedSelectedItem,
  itemMouseEnter,
  keyDownArrowDown,
  keyDownArrowUp,
  keyDownEnd,
  keyDownEnter,
  keyDownEscape,
  keyDownHome,
  keyDownSpaceButton,
  mouseUp,
  touchEnd,
  unknown
});
var _excluded$3 = ["refKey", "ref"], _excluded2$3 = ["onClick", "onPress", "onKeyDown", "onKeyUp", "onBlur"], _excluded3$2 = ["onKeyDown", "onBlur", "onChange", "onInput", "onChangeText"], _excluded4$2 = ["refKey", "ref"], _excluded5 = ["onMouseMove", "onMouseDown", "onClick", "onPress", "index", "item"];
var Downshift = /* @__PURE__ */ (function() {
  var Downshift2 = /* @__PURE__ */ (function(_Component) {
    function Downshift3(_props) {
      var _this;
      _this = _Component.call(this, _props) || this;
      _this.id = _this.props.id || "downshift-" + generateId();
      _this.menuId = _this.props.menuId || _this.id + "-menu";
      _this.labelId = _this.props.labelId || _this.id + "-label";
      _this.inputId = _this.props.inputId || _this.id + "-input";
      _this.getItemId = _this.props.getItemId || function(index) {
        return _this.id + "-item-" + index;
      };
      _this.items = [];
      _this.itemCount = null;
      _this.previousResultCount = 0;
      _this.timeoutIds = [];
      _this.internalSetTimeout = function(fn2, time) {
        var id = setTimeout(function() {
          _this.timeoutIds = _this.timeoutIds.filter(function(i2) {
            return i2 !== id;
          });
          fn2();
        }, time);
        _this.timeoutIds.push(id);
      };
      _this.setItemCount = function(count2) {
        _this.itemCount = count2;
      };
      _this.unsetItemCount = function() {
        _this.itemCount = null;
      };
      _this.isItemDisabled = function(_item, index) {
        var currentElementNode = _this.getItemNodeFromIndex(index);
        return currentElementNode && currentElementNode.hasAttribute("disabled");
      };
      _this.setHighlightedIndex = function(highlightedIndex, otherStateToSet) {
        if (highlightedIndex === void 0) {
          highlightedIndex = _this.props.defaultHighlightedIndex;
        }
        if (otherStateToSet === void 0) {
          otherStateToSet = {};
        }
        otherStateToSet = pickState(otherStateToSet);
        _this.internalSetState(_extends({
          highlightedIndex
        }, otherStateToSet));
      };
      _this.clearSelection = function(cb) {
        _this.internalSetState({
          selectedItem: null,
          inputValue: "",
          highlightedIndex: _this.props.defaultHighlightedIndex,
          isOpen: _this.props.defaultIsOpen
        }, cb);
      };
      _this.selectItem = function(item, otherStateToSet, cb) {
        otherStateToSet = pickState(otherStateToSet);
        _this.internalSetState(_extends({
          isOpen: _this.props.defaultIsOpen,
          highlightedIndex: _this.props.defaultHighlightedIndex,
          selectedItem: item,
          inputValue: _this.props.itemToString(item)
        }, otherStateToSet), cb);
      };
      _this.selectItemAtIndex = function(itemIndex, otherStateToSet, cb) {
        var item = _this.items[itemIndex];
        if (item == null) {
          return;
        }
        _this.selectItem(item, otherStateToSet, cb);
      };
      _this.selectHighlightedItem = function(otherStateToSet, cb) {
        return _this.selectItemAtIndex(_this.getState().highlightedIndex, otherStateToSet, cb);
      };
      _this.internalSetState = function(stateToSet, cb) {
        var isItemSelected, onChangeArg;
        var onStateChangeArg = {};
        var isStateToSetFunction = typeof stateToSet === "function";
        if (!isStateToSetFunction && stateToSet.hasOwnProperty("inputValue")) {
          _this.props.onInputValueChange(stateToSet.inputValue, _extends({}, _this.getStateAndHelpers(), stateToSet));
        }
        return _this.setState(function(state2) {
          var _newStateToSet;
          state2 = _this.getState(state2);
          var newStateToSet = isStateToSetFunction ? stateToSet(state2) : stateToSet;
          newStateToSet = _this.props.stateReducer(state2, newStateToSet);
          isItemSelected = newStateToSet.hasOwnProperty("selectedItem");
          var nextState = {};
          if (isItemSelected && newStateToSet.selectedItem !== state2.selectedItem) {
            onChangeArg = newStateToSet.selectedItem;
          }
          (_newStateToSet = newStateToSet).type || (_newStateToSet.type = unknown);
          Object.keys(newStateToSet).forEach(function(key) {
            if (state2[key] !== newStateToSet[key]) {
              onStateChangeArg[key] = newStateToSet[key];
            }
            if (key === "type") {
              return;
            }
            newStateToSet[key];
            if (!isControlledProp(_this.props, key)) {
              nextState[key] = newStateToSet[key];
            }
          });
          if (isStateToSetFunction && newStateToSet.hasOwnProperty("inputValue")) {
            _this.props.onInputValueChange(newStateToSet.inputValue, _extends({}, _this.getStateAndHelpers(), newStateToSet));
          }
          return nextState;
        }, function() {
          cbToCb(cb)();
          var hasMoreStateThanType = Object.keys(onStateChangeArg).length > 1;
          if (hasMoreStateThanType) {
            _this.props.onStateChange(onStateChangeArg, _this.getStateAndHelpers());
          }
          if (isItemSelected) {
            _this.props.onSelect(stateToSet.selectedItem, _this.getStateAndHelpers());
          }
          if (onChangeArg !== void 0) {
            _this.props.onChange(onChangeArg, _this.getStateAndHelpers());
          }
          _this.props.onUserAction(onStateChangeArg, _this.getStateAndHelpers());
        });
      };
      _this.rootRef = function(node) {
        return _this._rootNode = node;
      };
      _this.getRootProps = function(_temp, _temp2) {
        var _extends2;
        var _ref = _temp === void 0 ? {} : _temp, _ref$refKey = _ref.refKey, refKey = _ref$refKey === void 0 ? "ref" : _ref$refKey, ref = _ref.ref, rest = _objectWithoutPropertiesLoose(_ref, _excluded$3);
        var _ref2 = _temp2 === void 0 ? {} : _temp2, _ref2$suppressRefErro = _ref2.suppressRefError, suppressRefError = _ref2$suppressRefErro === void 0 ? false : _ref2$suppressRefErro;
        _this.getRootProps.called = true;
        _this.getRootProps.refKey = refKey;
        _this.getRootProps.suppressRefError = suppressRefError;
        var _this$getState = _this.getState(), isOpen = _this$getState.isOpen;
        return _extends((_extends2 = {}, _extends2[refKey] = handleRefs(ref, _this.rootRef), _extends2.role = "combobox", _extends2["aria-expanded"] = isOpen, _extends2["aria-haspopup"] = "listbox", _extends2["aria-owns"] = isOpen ? _this.menuId : void 0, _extends2["aria-labelledby"] = _this.labelId, _extends2), rest);
      };
      _this.keyDownHandlers = {
        ArrowDown: function ArrowDown(event) {
          var _this2 = this;
          event.preventDefault();
          if (this.getState().isOpen) {
            var amount = event.shiftKey ? 5 : 1;
            this.moveHighlightedIndex(amount, {
              type: keyDownArrowDown
            });
          } else {
            this.internalSetState({
              isOpen: true,
              type: keyDownArrowDown
            }, function() {
              var itemCount = _this2.getItemCount();
              if (itemCount > 0) {
                var _this2$getState = _this2.getState(), highlightedIndex = _this2$getState.highlightedIndex;
                var nextHighlightedIndex = getHighlightedIndex(highlightedIndex, 1, {
                  length: itemCount
                }, _this2.isItemDisabled, true);
                _this2.setHighlightedIndex(nextHighlightedIndex, {
                  type: keyDownArrowDown
                });
              }
            });
          }
        },
        ArrowUp: function ArrowUp(event) {
          var _this3 = this;
          event.preventDefault();
          if (this.getState().isOpen) {
            var amount = event.shiftKey ? -5 : -1;
            this.moveHighlightedIndex(amount, {
              type: keyDownArrowUp
            });
          } else {
            this.internalSetState({
              isOpen: true,
              type: keyDownArrowUp
            }, function() {
              var itemCount = _this3.getItemCount();
              if (itemCount > 0) {
                var _this3$getState = _this3.getState(), highlightedIndex = _this3$getState.highlightedIndex;
                var nextHighlightedIndex = getHighlightedIndex(highlightedIndex, -1, {
                  length: itemCount
                }, _this3.isItemDisabled, true);
                _this3.setHighlightedIndex(nextHighlightedIndex, {
                  type: keyDownArrowUp
                });
              }
            });
          }
        },
        Enter: function Enter(event) {
          if (event.which === 229) {
            return;
          }
          var _this$getState2 = this.getState(), isOpen = _this$getState2.isOpen, highlightedIndex = _this$getState2.highlightedIndex;
          if (isOpen && highlightedIndex != null) {
            event.preventDefault();
            var item = this.items[highlightedIndex];
            var itemNode = this.getItemNodeFromIndex(highlightedIndex);
            if (item == null || itemNode && itemNode.hasAttribute("disabled")) {
              return;
            }
            this.selectHighlightedItem({
              type: keyDownEnter
            });
          }
        },
        Escape: function Escape(event) {
          event.preventDefault();
          this.reset(_extends({
            type: keyDownEscape
          }, !this.state.isOpen && {
            selectedItem: null,
            inputValue: ""
          }));
        }
      };
      _this.buttonKeyDownHandlers = _extends({}, _this.keyDownHandlers, {
        " ": function _2(event) {
          event.preventDefault();
          this.toggleMenu({
            type: keyDownSpaceButton
          });
        }
      });
      _this.inputKeyDownHandlers = _extends({}, _this.keyDownHandlers, {
        Home: function Home(event) {
          var _this$getState3 = this.getState(), isOpen = _this$getState3.isOpen;
          if (!isOpen) {
            return;
          }
          event.preventDefault();
          var itemCount = this.getItemCount();
          if (itemCount <= 0 || !isOpen) {
            return;
          }
          var newHighlightedIndex = getNonDisabledIndex(0, false, {
            length: itemCount
          }, this.isItemDisabled);
          this.setHighlightedIndex(newHighlightedIndex, {
            type: keyDownHome
          });
        },
        End: function End(event) {
          var _this$getState4 = this.getState(), isOpen = _this$getState4.isOpen;
          if (!isOpen) {
            return;
          }
          event.preventDefault();
          var itemCount = this.getItemCount();
          if (itemCount <= 0 || !isOpen) {
            return;
          }
          var newHighlightedIndex = getNonDisabledIndex(itemCount - 1, true, {
            length: itemCount
          }, this.isItemDisabled);
          this.setHighlightedIndex(newHighlightedIndex, {
            type: keyDownEnd
          });
        }
      });
      _this.getToggleButtonProps = function(_temp3) {
        var _ref3 = _temp3 === void 0 ? {} : _temp3, onClick = _ref3.onClick;
        _ref3.onPress;
        var onKeyDown = _ref3.onKeyDown, onKeyUp = _ref3.onKeyUp, onBlur = _ref3.onBlur, rest = _objectWithoutPropertiesLoose(_ref3, _excluded2$3);
        var _this$getState5 = _this.getState(), isOpen = _this$getState5.isOpen;
        var enabledEventHandlers = {
          onClick: callAllEventHandlers(onClick, _this.buttonHandleClick),
          onKeyDown: callAllEventHandlers(onKeyDown, _this.buttonHandleKeyDown),
          onKeyUp: callAllEventHandlers(onKeyUp, _this.buttonHandleKeyUp),
          onBlur: callAllEventHandlers(onBlur, _this.buttonHandleBlur)
        };
        var eventHandlers = rest.disabled ? {} : enabledEventHandlers;
        return _extends({
          type: "button",
          role: "button",
          "aria-label": isOpen ? "close menu" : "open menu",
          "aria-haspopup": true,
          "data-toggle": true
        }, eventHandlers, rest);
      };
      _this.buttonHandleKeyUp = function(event) {
        event.preventDefault();
      };
      _this.buttonHandleKeyDown = function(event) {
        var key = normalizeArrowKey(event);
        if (_this.buttonKeyDownHandlers[key]) {
          _this.buttonKeyDownHandlers[key].call(_this, event);
        }
      };
      _this.buttonHandleClick = function(event) {
        event.preventDefault();
        if (_this.props.environment) {
          var _this$props$environme = _this.props.environment.document, body = _this$props$environme.body, activeElement = _this$props$environme.activeElement;
          if (body && body === activeElement) {
            event.target.focus();
          }
        }
        if (process.env.NODE_ENV === "test") {
          _this.toggleMenu({
            type: clickButton
          });
        } else {
          _this.internalSetTimeout(function() {
            return _this.toggleMenu({
              type: clickButton
            });
          });
        }
      };
      _this.buttonHandleBlur = function(event) {
        var blurTarget = event.target;
        _this.internalSetTimeout(function() {
          if (_this.isMouseDown || !_this.props.environment) {
            return;
          }
          var activeElement = _this.props.environment.document.activeElement;
          if ((activeElement == null || activeElement.id !== _this.inputId) && activeElement !== blurTarget) {
            _this.reset({
              type: blurButton
            });
          }
        });
      };
      _this.getLabelProps = function(props) {
        return _extends({
          htmlFor: _this.inputId,
          id: _this.labelId
        }, props);
      };
      _this.getInputProps = function(_temp4) {
        var _ref4 = _temp4 === void 0 ? {} : _temp4, onKeyDown = _ref4.onKeyDown, onBlur = _ref4.onBlur, onChange = _ref4.onChange, onInput = _ref4.onInput;
        _ref4.onChangeText;
        var rest = _objectWithoutPropertiesLoose(_ref4, _excluded3$2);
        var onChangeKey;
        var eventHandlers = {};
        {
          onChangeKey = "onChange";
        }
        var _this$getState6 = _this.getState(), inputValue = _this$getState6.inputValue, isOpen = _this$getState6.isOpen, highlightedIndex = _this$getState6.highlightedIndex;
        if (!rest.disabled) {
          var _eventHandlers;
          eventHandlers = (_eventHandlers = {}, _eventHandlers[onChangeKey] = callAllEventHandlers(onChange, onInput, _this.inputHandleChange), _eventHandlers.onKeyDown = callAllEventHandlers(onKeyDown, _this.inputHandleKeyDown), _eventHandlers.onBlur = callAllEventHandlers(onBlur, _this.inputHandleBlur), _eventHandlers);
        }
        return _extends({
          "aria-autocomplete": "list",
          "aria-activedescendant": isOpen && typeof highlightedIndex === "number" && highlightedIndex >= 0 ? _this.getItemId(highlightedIndex) : void 0,
          "aria-controls": isOpen ? _this.menuId : void 0,
          "aria-labelledby": rest && rest["aria-label"] ? void 0 : _this.labelId,
          // https://developer.mozilla.org/en-US/docs/Web/Security/Securing_your_site/Turning_off_form_autocompletion
          // revert back since autocomplete="nope" is ignored on latest Chrome and Opera
          autoComplete: "off",
          value: inputValue,
          id: _this.inputId
        }, eventHandlers, rest);
      };
      _this.inputHandleKeyDown = function(event) {
        var key = normalizeArrowKey(event);
        if (key && _this.inputKeyDownHandlers[key]) {
          _this.inputKeyDownHandlers[key].call(_this, event);
        }
      };
      _this.inputHandleChange = function(event) {
        _this.internalSetState({
          type: changeInput,
          isOpen: true,
          inputValue: event.target.value,
          highlightedIndex: _this.props.defaultHighlightedIndex
        });
      };
      _this.inputHandleBlur = function() {
        _this.internalSetTimeout(function() {
          var _activeElement$datase;
          if (_this.isMouseDown || !_this.props.environment) {
            return;
          }
          var activeElement = _this.props.environment.document.activeElement;
          var downshiftButtonIsActive = (activeElement == null || (_activeElement$datase = activeElement.dataset) == null ? void 0 : _activeElement$datase.toggle) && _this._rootNode && _this._rootNode.contains(activeElement);
          if (!downshiftButtonIsActive) {
            _this.reset({
              type: blurInput
            });
          }
        });
      };
      _this.menuRef = function(node) {
        _this._menuNode = node;
      };
      _this.getMenuProps = function(_temp5, _temp6) {
        var _extends3;
        var _ref5 = _temp5 === void 0 ? {} : _temp5, _ref5$refKey = _ref5.refKey, refKey = _ref5$refKey === void 0 ? "ref" : _ref5$refKey, ref = _ref5.ref, props = _objectWithoutPropertiesLoose(_ref5, _excluded4$2);
        var _ref6 = _temp6 === void 0 ? {} : _temp6, _ref6$suppressRefErro = _ref6.suppressRefError, suppressRefError = _ref6$suppressRefErro === void 0 ? false : _ref6$suppressRefErro;
        _this.getMenuProps.called = true;
        _this.getMenuProps.refKey = refKey;
        _this.getMenuProps.suppressRefError = suppressRefError;
        return _extends((_extends3 = {}, _extends3[refKey] = handleRefs(ref, _this.menuRef), _extends3.role = "listbox", _extends3["aria-labelledby"] = props && props["aria-label"] ? void 0 : _this.labelId, _extends3.id = _this.menuId, _extends3), props);
      };
      _this.getItemProps = function(_temp7) {
        var _enabledEventHandlers;
        var _ref7 = _temp7 === void 0 ? {} : _temp7, onMouseMove = _ref7.onMouseMove, onMouseDown = _ref7.onMouseDown, onClick = _ref7.onClick;
        _ref7.onPress;
        var index = _ref7.index, _ref7$item = _ref7.item, item = _ref7$item === void 0 ? process.env.NODE_ENV === "production" ? (
          /* istanbul ignore next */
          void 0
        ) : requiredProp("getItemProps", "item") : _ref7$item, rest = _objectWithoutPropertiesLoose(_ref7, _excluded5);
        if (index === void 0) {
          _this.items.push(item);
          index = _this.items.indexOf(item);
        } else {
          _this.items[index] = item;
        }
        var onSelectKey = "onClick";
        var customClickHandler = onClick;
        var enabledEventHandlers = (_enabledEventHandlers = {
          // onMouseMove is used over onMouseEnter here. onMouseMove
          // is only triggered on actual mouse movement while onMouseEnter
          // can fire on DOM changes, interrupting keyboard navigation
          onMouseMove: callAllEventHandlers(onMouseMove, function() {
            if (index === _this.getState().highlightedIndex) {
              return;
            }
            _this.setHighlightedIndex(index, {
              type: itemMouseEnter
            });
            _this.avoidScrolling = true;
            _this.internalSetTimeout(function() {
              return _this.avoidScrolling = false;
            }, 250);
          }),
          onMouseDown: callAllEventHandlers(onMouseDown, function(event) {
            event.preventDefault();
          })
        }, _enabledEventHandlers[onSelectKey] = callAllEventHandlers(customClickHandler, function() {
          _this.selectItemAtIndex(index, {
            type: clickItem
          });
        }), _enabledEventHandlers);
        var eventHandlers = rest.disabled ? {
          onMouseDown: enabledEventHandlers.onMouseDown
        } : enabledEventHandlers;
        return _extends({
          id: _this.getItemId(index),
          role: "option",
          "aria-selected": _this.getState().highlightedIndex === index
        }, eventHandlers, rest);
      };
      _this.clearItems = function() {
        _this.items = [];
      };
      _this.reset = function(otherStateToSet, cb) {
        if (otherStateToSet === void 0) {
          otherStateToSet = {};
        }
        otherStateToSet = pickState(otherStateToSet);
        _this.internalSetState(function(_ref8) {
          var selectedItem = _ref8.selectedItem;
          return _extends({
            isOpen: _this.props.defaultIsOpen,
            highlightedIndex: _this.props.defaultHighlightedIndex,
            inputValue: _this.props.itemToString(selectedItem)
          }, otherStateToSet);
        }, cb);
      };
      _this.toggleMenu = function(otherStateToSet, cb) {
        if (otherStateToSet === void 0) {
          otherStateToSet = {};
        }
        otherStateToSet = pickState(otherStateToSet);
        _this.internalSetState(function(_ref9) {
          var isOpen = _ref9.isOpen;
          return _extends({
            isOpen: !isOpen
          }, isOpen && {
            highlightedIndex: _this.props.defaultHighlightedIndex
          }, otherStateToSet);
        }, function() {
          var _this$getState7 = _this.getState(), isOpen = _this$getState7.isOpen, highlightedIndex = _this$getState7.highlightedIndex;
          if (isOpen) {
            if (_this.getItemCount() > 0 && typeof highlightedIndex === "number") {
              _this.setHighlightedIndex(highlightedIndex, otherStateToSet);
            }
          }
          cbToCb(cb)();
        });
      };
      _this.openMenu = function(cb) {
        _this.internalSetState({
          isOpen: true
        }, cb);
      };
      _this.closeMenu = function(cb) {
        _this.internalSetState({
          isOpen: false
        }, cb);
      };
      _this.updateStatus = debounce(function() {
        var _this$props;
        if (!((_this$props = _this.props) != null && (_this$props = _this$props.environment) != null && _this$props.document)) {
          return;
        }
        var state2 = _this.getState();
        var item = _this.items[state2.highlightedIndex];
        var resultCount = _this.getItemCount();
        var status = _this.props.getA11yStatusMessage(_extends({
          itemToString: _this.props.itemToString,
          previousResultCount: _this.previousResultCount,
          resultCount,
          highlightedItem: item
        }, state2));
        _this.previousResultCount = resultCount;
        setStatus(status, _this.props.environment.document);
      }, 200);
      var _this$props2 = _this.props, defaultHighlightedIndex = _this$props2.defaultHighlightedIndex, _this$props2$initialH = _this$props2.initialHighlightedIndex, _highlightedIndex = _this$props2$initialH === void 0 ? defaultHighlightedIndex : _this$props2$initialH, defaultIsOpen = _this$props2.defaultIsOpen, _this$props2$initialI = _this$props2.initialIsOpen, _isOpen = _this$props2$initialI === void 0 ? defaultIsOpen : _this$props2$initialI, _this$props2$initialI2 = _this$props2.initialInputValue, _inputValue = _this$props2$initialI2 === void 0 ? "" : _this$props2$initialI2, _this$props2$initialS = _this$props2.initialSelectedItem, _selectedItem = _this$props2$initialS === void 0 ? null : _this$props2$initialS;
      var _state = _this.getState({
        highlightedIndex: _highlightedIndex,
        isOpen: _isOpen,
        inputValue: _inputValue,
        selectedItem: _selectedItem
      });
      if (_state.selectedItem != null && _this.props.initialInputValue === void 0) {
        _state.inputValue = _this.props.itemToString(_state.selectedItem);
      }
      _this.state = _state;
      return _this;
    }
    _inheritsLoose(Downshift3, _Component);
    var _proto = Downshift3.prototype;
    _proto.internalClearTimeouts = function internalClearTimeouts() {
      this.timeoutIds.forEach(function(id) {
        clearTimeout(id);
      });
      this.timeoutIds = [];
    };
    _proto.getState = function getState$1(stateToMerge) {
      if (stateToMerge === void 0) {
        stateToMerge = this.state;
      }
      return getState(stateToMerge, this.props);
    };
    _proto.getItemCount = function getItemCount() {
      var itemCount = this.items.length;
      if (this.itemCount != null) {
        itemCount = this.itemCount;
      } else if (this.props.itemCount !== void 0) {
        itemCount = this.props.itemCount;
      }
      return itemCount;
    };
    _proto.getItemNodeFromIndex = function getItemNodeFromIndex(index) {
      return this.props.environment ? this.props.environment.document.getElementById(this.getItemId(index)) : null;
    };
    _proto.scrollHighlightedItemIntoView = function scrollHighlightedItemIntoView() {
      {
        var node = this.getItemNodeFromIndex(this.getState().highlightedIndex);
        this.props.scrollIntoView(node, this._menuNode);
      }
    };
    _proto.moveHighlightedIndex = function moveHighlightedIndex(amount, otherStateToSet) {
      var itemCount = this.getItemCount();
      var _this$getState8 = this.getState(), highlightedIndex = _this$getState8.highlightedIndex;
      if (itemCount > 0) {
        var nextHighlightedIndex = getHighlightedIndex(highlightedIndex, amount, {
          length: itemCount
        }, this.isItemDisabled, true);
        this.setHighlightedIndex(nextHighlightedIndex, otherStateToSet);
      }
    };
    _proto.getStateAndHelpers = function getStateAndHelpers() {
      var _this$getState9 = this.getState(), highlightedIndex = _this$getState9.highlightedIndex, inputValue = _this$getState9.inputValue, selectedItem = _this$getState9.selectedItem, isOpen = _this$getState9.isOpen;
      var itemToString2 = this.props.itemToString;
      var id = this.id;
      var getRootProps = this.getRootProps, getToggleButtonProps = this.getToggleButtonProps, getLabelProps = this.getLabelProps, getMenuProps = this.getMenuProps, getInputProps = this.getInputProps, getItemProps = this.getItemProps, openMenu = this.openMenu, closeMenu = this.closeMenu, toggleMenu = this.toggleMenu, selectItem = this.selectItem, selectItemAtIndex = this.selectItemAtIndex, selectHighlightedItem = this.selectHighlightedItem, setHighlightedIndex = this.setHighlightedIndex, clearSelection = this.clearSelection, clearItems = this.clearItems, reset = this.reset, setItemCount = this.setItemCount, unsetItemCount = this.unsetItemCount, setState = this.internalSetState;
      return {
        // prop getters
        getRootProps,
        getToggleButtonProps,
        getLabelProps,
        getMenuProps,
        getInputProps,
        getItemProps,
        // actions
        reset,
        openMenu,
        closeMenu,
        toggleMenu,
        selectItem,
        selectItemAtIndex,
        selectHighlightedItem,
        setHighlightedIndex,
        clearSelection,
        clearItems,
        setItemCount,
        unsetItemCount,
        setState,
        // props
        itemToString: itemToString2,
        // derived
        id,
        // state
        highlightedIndex,
        inputValue,
        isOpen,
        selectedItem
      };
    };
    _proto.componentDidMount = function componentDidMount() {
      var _this4 = this;
      if (process.env.NODE_ENV !== "production" && true && this.getMenuProps.called && !this.getMenuProps.suppressRefError) {
        validateGetMenuPropsCalledCorrectly(this._menuNode, this.getMenuProps);
      }
      if (!this.props.environment) {
        this.cleanup = function() {
          _this4.internalClearTimeouts();
        };
      } else {
        var onMouseDown = function onMouseDown2() {
          _this4.isMouseDown = true;
        };
        var onMouseUp = function onMouseUp2(event) {
          _this4.isMouseDown = false;
          var contextWithinDownshift = targetWithinDownshift(event.target, [_this4._rootNode, _this4._menuNode], _this4.props.environment);
          if (!contextWithinDownshift && _this4.getState().isOpen) {
            _this4.reset({
              type: mouseUp
            }, function() {
              return _this4.props.onOuterClick(_this4.getStateAndHelpers());
            });
          }
        };
        var onTouchStart = function onTouchStart2() {
          _this4.isTouchMove = false;
        };
        var onTouchMove = function onTouchMove2() {
          _this4.isTouchMove = true;
        };
        var onTouchEnd = function onTouchEnd2(event) {
          var contextWithinDownshift = targetWithinDownshift(event.target, [_this4._rootNode, _this4._menuNode], _this4.props.environment, false);
          if (!_this4.isTouchMove && !contextWithinDownshift && _this4.getState().isOpen) {
            _this4.reset({
              type: touchEnd
            }, function() {
              return _this4.props.onOuterClick(_this4.getStateAndHelpers());
            });
          }
        };
        var environment = this.props.environment;
        environment.addEventListener("mousedown", onMouseDown);
        environment.addEventListener("mouseup", onMouseUp);
        environment.addEventListener("touchstart", onTouchStart);
        environment.addEventListener("touchmove", onTouchMove);
        environment.addEventListener("touchend", onTouchEnd);
        this.cleanup = function() {
          _this4.internalClearTimeouts();
          _this4.updateStatus.cancel();
          environment.removeEventListener("mousedown", onMouseDown);
          environment.removeEventListener("mouseup", onMouseUp);
          environment.removeEventListener("touchstart", onTouchStart);
          environment.removeEventListener("touchmove", onTouchMove);
          environment.removeEventListener("touchend", onTouchEnd);
        };
      }
    };
    _proto.shouldScroll = function shouldScroll(prevState, prevProps) {
      var _ref0 = this.props.highlightedIndex === void 0 ? this.getState() : this.props, currentHighlightedIndex = _ref0.highlightedIndex;
      var _ref1 = prevProps.highlightedIndex === void 0 ? prevState : prevProps, prevHighlightedIndex = _ref1.highlightedIndex;
      var scrollWhenOpen = currentHighlightedIndex && this.getState().isOpen && !prevState.isOpen;
      var scrollWhenNavigating = currentHighlightedIndex !== prevHighlightedIndex;
      return scrollWhenOpen || scrollWhenNavigating;
    };
    _proto.componentDidUpdate = function componentDidUpdate(prevProps, prevState) {
      if (process.env.NODE_ENV !== "production") {
        validateControlledUnchanged(this.state, prevProps, this.props);
        if (this.getMenuProps.called && !this.getMenuProps.suppressRefError) {
          validateGetMenuPropsCalledCorrectly(this._menuNode, this.getMenuProps);
        }
      }
      if (isControlledProp(this.props, "selectedItem") && this.props.selectedItemChanged(prevProps.selectedItem, this.props.selectedItem)) {
        this.internalSetState({
          type: controlledPropUpdatedSelectedItem,
          inputValue: this.props.itemToString(this.props.selectedItem)
        });
      }
      if (!this.avoidScrolling && this.shouldScroll(prevState, prevProps)) {
        this.scrollHighlightedItemIntoView();
      }
      {
        this.updateStatus();
      }
    };
    _proto.componentWillUnmount = function componentWillUnmount() {
      this.cleanup();
    };
    _proto.render = function render() {
      var children = unwrapArray(this.props.children, noop);
      this.clearItems();
      this.getRootProps.called = false;
      this.getRootProps.refKey = void 0;
      this.getRootProps.suppressRefError = void 0;
      this.getMenuProps.called = false;
      this.getMenuProps.refKey = void 0;
      this.getMenuProps.suppressRefError = void 0;
      this.getLabelProps.called = false;
      this.getInputProps.called = false;
      var element = unwrapArray(children(this.getStateAndHelpers()));
      if (!element) {
        return null;
      }
      if (this.getRootProps.called || this.props.suppressRefError) {
        if (process.env.NODE_ENV !== "production" && !this.getRootProps.suppressRefError && !this.props.suppressRefError) {
          validateGetRootPropsCalledCorrectly(element, this.getRootProps);
        }
        return element;
      } else if (isDOMElement(element)) {
        return /* @__PURE__ */ _n(element, this.getRootProps(getElementProps(element)));
      }
      if (process.env.NODE_ENV !== "production") {
        throw new Error("downshift: If you return a non-DOM element, you must apply the getRootProps function");
      }
      return void 0;
    };
    return Downshift3;
  })(x$2);
  Downshift2.defaultProps = {
    defaultHighlightedIndex: null,
    defaultIsOpen: false,
    getA11yStatusMessage,
    itemToString: function itemToString2(i2) {
      if (i2 == null) {
        return "";
      }
      if (process.env.NODE_ENV !== "production" && isPlainObject(i2) && !i2.hasOwnProperty("toString")) {
        console.warn("downshift: An object was passed to the default implementation of `itemToString`. You should probably provide your own `itemToString` implementation. Please refer to the `itemToString` API documentation.", "The object that was passed:", i2);
      }
      return String(i2);
    },
    onStateChange: noop,
    onInputValueChange: noop,
    onUserAction: noop,
    onChange: noop,
    onSelect: noop,
    onOuterClick: noop,
    selectedItemChanged: function selectedItemChanged(prevItem, item) {
      return prevItem !== item;
    },
    environment: (
      /* istanbul ignore next (ssr) */
      typeof window === "undefined" || false ? void 0 : window
    ),
    stateReducer: function stateReducer2(state2, stateToSet) {
      return stateToSet;
    },
    suppressRefError: false,
    scrollIntoView
  };
  Downshift2.stateChangeTypes = stateChangeTypes$3;
  return Downshift2;
})();
process.env.NODE_ENV !== "production" ? Downshift.propTypes = {
  children: PropTypes.func,
  defaultHighlightedIndex: PropTypes.number,
  defaultIsOpen: PropTypes.bool,
  initialHighlightedIndex: PropTypes.number,
  initialSelectedItem: PropTypes.any,
  initialInputValue: PropTypes.string,
  initialIsOpen: PropTypes.bool,
  getA11yStatusMessage: PropTypes.func,
  itemToString: PropTypes.func,
  onChange: PropTypes.func,
  onSelect: PropTypes.func,
  onStateChange: PropTypes.func,
  onInputValueChange: PropTypes.func,
  onUserAction: PropTypes.func,
  onOuterClick: PropTypes.func,
  selectedItemChanged: PropTypes.func,
  stateReducer: PropTypes.func,
  itemCount: PropTypes.number,
  id: PropTypes.string,
  environment: PropTypes.shape({
    addEventListener: PropTypes.func.isRequired,
    removeEventListener: PropTypes.func.isRequired,
    document: PropTypes.shape({
      createElement: PropTypes.func.isRequired,
      getElementById: PropTypes.func.isRequired,
      activeElement: PropTypes.any.isRequired,
      body: PropTypes.any.isRequired
    }).isRequired,
    Node: PropTypes.func.isRequired
  }),
  suppressRefError: PropTypes.bool,
  scrollIntoView: PropTypes.func,
  // things we keep in state for uncontrolled components
  // but can accept as props for controlled components
  /* eslint-disable react/no-unused-prop-types */
  selectedItem: PropTypes.any,
  isOpen: PropTypes.bool,
  inputValue: PropTypes.string,
  highlightedIndex: PropTypes.number,
  labelId: PropTypes.string,
  inputId: PropTypes.string,
  menuId: PropTypes.string,
  getItemId: PropTypes.func
  /* eslint-enable react/no-unused-prop-types */
} : void 0;
function validateGetMenuPropsCalledCorrectly(node, _ref10) {
  var refKey = _ref10.refKey;
  if (!node) {
    console.error('downshift: The ref prop "' + refKey + '" from getMenuProps was not applied correctly on your menu element.');
  }
}
function validateGetRootPropsCalledCorrectly(element, _ref11) {
  var refKey = _ref11.refKey;
  var refKeySpecified = refKey !== "ref";
  var isComposite = !isDOMElement(element);
  if (isComposite && !refKeySpecified && !reactIsExports.isForwardRef(element)) {
    console.error("downshift: You returned a non-DOM element. You must specify a refKey in getRootProps");
  } else if (!isComposite && refKeySpecified) {
    console.error('downshift: You returned a DOM element. You should not specify a refKey in getRootProps. You specified "' + refKey + '"');
  }
  if (!reactIsExports.isForwardRef(element) && !getElementProps(element)[refKey]) {
    console.error('downshift: You must apply the ref prop "' + refKey + '" from getRootProps onto your root element.');
  }
}
var dropdownDefaultStateValues = {
  highlightedIndex: -1,
  isOpen: false,
  selectedItem: null,
  inputValue: ""
};
function callOnChangeProps(action, state2, newState) {
  var props = action.props, type = action.type;
  var changes = {};
  Object.keys(state2).forEach(function(key) {
    invokeOnChangeHandler(key, action, state2, newState);
    if (newState[key] !== state2[key]) {
      changes[key] = newState[key];
    }
  });
  if (props.onStateChange && Object.keys(changes).length) {
    props.onStateChange(_extends({
      type
    }, changes));
  }
}
function invokeOnChangeHandler(key, action, state2, newState) {
  var props = action.props, type = action.type;
  var handler = "on" + capitalizeString(key) + "Change";
  if (props[handler] && newState[key] !== void 0 && newState[key] !== state2[key]) {
    props[handler](_extends({
      type
    }, newState));
  }
}
function stateReducer(s2, a2) {
  return a2.changes;
}
var updateA11yStatus = debounce(function(status, document2) {
  setStatus(status, document2);
}, 200);
var useIsomorphicLayoutEffect = typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined" ? _ : y;
var useElementIds = "useId" in Rn ? function useElementIds2(_ref) {
  var id = _ref.id, labelId = _ref.labelId, menuId = _ref.menuId, getItemId = _ref.getItemId, toggleButtonId = _ref.toggleButtonId, inputId = _ref.inputId;
  var reactId = "downshift-" + Rn.useId();
  if (!id) {
    id = reactId;
  }
  var elementIds = T$1(function() {
    return {
      labelId: labelId || id + "-label",
      menuId: menuId || id + "-menu",
      getItemId: getItemId || function(index) {
        return id + "-item-" + index;
      },
      toggleButtonId: toggleButtonId || id + "-toggle-button",
      inputId: inputId || id + "-input"
    };
  }, [getItemId, id, inputId, labelId, menuId, toggleButtonId]);
  return elementIds;
} : function useElementIds3(_ref2) {
  var _ref2$id = _ref2.id, id = _ref2$id === void 0 ? "downshift-" + generateId() : _ref2$id, labelId = _ref2.labelId, menuId = _ref2.menuId, getItemId = _ref2.getItemId, toggleButtonId = _ref2.toggleButtonId, inputId = _ref2.inputId;
  var elementIds = T$1(function() {
    return {
      labelId: labelId || id + "-label",
      menuId: menuId || id + "-menu",
      getItemId: getItemId || function(index) {
        return id + "-item-" + index;
      },
      toggleButtonId: toggleButtonId || id + "-toggle-button",
      inputId: inputId || id + "-input"
    };
  }, [getItemId, id, inputId, labelId, menuId, toggleButtonId]);
  return elementIds;
};
function getItemAndIndex(itemProp, indexProp, items, errorMessage) {
  var item, index;
  if (itemProp === void 0) {
    if (indexProp === void 0) {
      throw new Error(errorMessage);
    }
    item = items[indexProp];
    index = indexProp;
  } else {
    index = indexProp === void 0 ? items.indexOf(itemProp) : indexProp;
    item = itemProp;
  }
  return [item, index];
}
function isAcceptedCharacterKey(key) {
  return /^\S{1}$/.test(key);
}
function capitalizeString(string) {
  return "" + string.slice(0, 1).toUpperCase() + string.slice(1);
}
function useLatestRef(val) {
  var ref = A$1(val);
  ref.current = val;
  return ref;
}
function useEnhancedReducer(reducer, props, createInitialState, isStateEqual) {
  var prevStateRef = A$1();
  var actionRef = A$1();
  var enhancedReducer = q$1(function(state3, action2) {
    actionRef.current = action2;
    state3 = getState(state3, action2.props);
    var changes = reducer(state3, action2);
    var newState = action2.props.stateReducer(state3, _extends({}, action2, {
      changes
    }));
    return newState;
  }, [reducer]);
  var _useReducer = h(enhancedReducer, props, createInitialState), state2 = _useReducer[0], dispatch = _useReducer[1];
  var propsRef = useLatestRef(props);
  var dispatchWithProps = q$1(function(action2) {
    return dispatch(_extends({
      props: propsRef.current
    }, action2));
  }, [propsRef]);
  var action = actionRef.current;
  y(function() {
    var prevState = getState(prevStateRef.current, action == null ? void 0 : action.props);
    var shouldCallOnChangeProps = action && prevStateRef.current && !isStateEqual(prevState, state2);
    if (shouldCallOnChangeProps) {
      callOnChangeProps(action, prevState, state2);
    }
    prevStateRef.current = state2;
  }, [state2, action, isStateEqual]);
  return [state2, dispatchWithProps];
}
function useControlledReducer$1(reducer, props, createInitialState, isStateEqual) {
  var _useEnhancedReducer = useEnhancedReducer(reducer, props, createInitialState, isStateEqual), state2 = _useEnhancedReducer[0], dispatch = _useEnhancedReducer[1];
  return [getState(state2, props), dispatch];
}
var defaultProps$3 = {
  itemToString: function itemToString(item) {
    return item ? String(item) : "";
  },
  itemToKey: function itemToKey(item) {
    return item;
  },
  stateReducer,
  scrollIntoView,
  environment: (
    /* istanbul ignore next (ssr) */
    typeof window === "undefined" || false ? void 0 : window
  )
};
function getDefaultValue$1(props, propKey, defaultStateValues) {
  if (defaultStateValues === void 0) {
    defaultStateValues = dropdownDefaultStateValues;
  }
  var defaultValue = props["default" + capitalizeString(propKey)];
  if (defaultValue !== void 0) {
    return defaultValue;
  }
  return defaultStateValues[propKey];
}
function getInitialValue$1(props, propKey, defaultStateValues) {
  if (defaultStateValues === void 0) {
    defaultStateValues = dropdownDefaultStateValues;
  }
  var value = props[propKey];
  if (value !== void 0) {
    return value;
  }
  var initialValue = props["initial" + capitalizeString(propKey)];
  if (initialValue !== void 0) {
    return initialValue;
  }
  return getDefaultValue$1(props, propKey, defaultStateValues);
}
function getInitialState$2(props) {
  var selectedItem = getInitialValue$1(props, "selectedItem");
  var isOpen = getInitialValue$1(props, "isOpen");
  var highlightedIndex = getInitialHighlightedIndex(props);
  var inputValue = getInitialValue$1(props, "inputValue");
  return {
    highlightedIndex: highlightedIndex < 0 && selectedItem && isOpen ? props.items.findIndex(function(item) {
      return props.itemToKey(item) === props.itemToKey(selectedItem);
    }) : highlightedIndex,
    isOpen,
    selectedItem,
    inputValue
  };
}
function getHighlightedIndexOnOpen(props, state2, offset) {
  var items = props.items, initialHighlightedIndex = props.initialHighlightedIndex, defaultHighlightedIndex = props.defaultHighlightedIndex, isItemDisabled2 = props.isItemDisabled, itemToKey2 = props.itemToKey;
  var selectedItem = state2.selectedItem, highlightedIndex = state2.highlightedIndex;
  if (items.length === 0) {
    return -1;
  }
  if (initialHighlightedIndex !== void 0 && highlightedIndex === initialHighlightedIndex && !isItemDisabled2(items[initialHighlightedIndex], initialHighlightedIndex)) {
    return initialHighlightedIndex;
  }
  if (defaultHighlightedIndex !== void 0 && !isItemDisabled2(items[defaultHighlightedIndex], defaultHighlightedIndex)) {
    return defaultHighlightedIndex;
  }
  if (selectedItem) {
    return items.findIndex(function(item) {
      return itemToKey2(selectedItem) === itemToKey2(item);
    });
  }
  if (offset < 0 && !isItemDisabled2(items[items.length - 1], items.length - 1)) {
    return items.length - 1;
  }
  if (offset > 0 && !isItemDisabled2(items[0], 0)) {
    return 0;
  }
  return -1;
}
function useMouseAndTouchTracker(environment, handleBlur, downshiftRefs) {
  var mouseAndTouchTrackersRef = A$1({
    isMouseDown: false,
    isTouchMove: false,
    isTouchEnd: false
  });
  var getDownshiftElements = q$1(function() {
    return downshiftRefs.map(function(ref) {
      return ref.current;
    });
  }, [downshiftRefs]);
  y(function() {
    if (!environment) {
      return noop;
    }
    function onMouseDown() {
      mouseAndTouchTrackersRef.current.isTouchEnd = false;
      mouseAndTouchTrackersRef.current.isMouseDown = true;
    }
    function onMouseUp(event) {
      mouseAndTouchTrackersRef.current.isMouseDown = false;
      if (!targetWithinDownshift(event.target, getDownshiftElements(), environment)) {
        handleBlur();
      }
    }
    function onTouchStart() {
      mouseAndTouchTrackersRef.current.isTouchEnd = false;
      mouseAndTouchTrackersRef.current.isTouchMove = false;
    }
    function onTouchMove() {
      mouseAndTouchTrackersRef.current.isTouchMove = true;
    }
    function onTouchEnd(event) {
      mouseAndTouchTrackersRef.current.isTouchEnd = true;
      if (!mouseAndTouchTrackersRef.current.isTouchMove && !targetWithinDownshift(event.target, getDownshiftElements(), environment, false)) {
        handleBlur();
      }
    }
    environment.addEventListener("mousedown", onMouseDown);
    environment.addEventListener("mouseup", onMouseUp);
    environment.addEventListener("touchstart", onTouchStart);
    environment.addEventListener("touchmove", onTouchMove);
    environment.addEventListener("touchend", onTouchEnd);
    return function cleanup() {
      environment.removeEventListener("mousedown", onMouseDown);
      environment.removeEventListener("mouseup", onMouseUp);
      environment.removeEventListener("touchstart", onTouchStart);
      environment.removeEventListener("touchmove", onTouchMove);
      environment.removeEventListener("touchend", onTouchEnd);
    };
  }, [environment, getDownshiftElements, handleBlur]);
  return mouseAndTouchTrackersRef.current;
}
var useGetterPropsCalledChecker = function useGetterPropsCalledChecker2() {
  return noop;
};
if (process.env.NODE_ENV !== "production") {
  useGetterPropsCalledChecker = function useGetterPropsCalledChecker3() {
    for (var _len = arguments.length, propKeys = new Array(_len), _key = 0; _key < _len; _key++) {
      propKeys[_key] = arguments[_key];
    }
    var getterPropsCalledRef = A$1(propKeys.reduce(function(acc, propKey) {
      acc[propKey] = {};
      return acc;
    }, {}));
    y(function() {
      Object.keys(getterPropsCalledRef.current).forEach(function(propKey) {
        var propCallInfo = getterPropsCalledRef.current[propKey];
        if (!Object.keys(propCallInfo).length) {
          console.error("downshift: You forgot to call the " + propKey + " getter function on your component / element.");
          return;
        }
        var suppressRefError = propCallInfo.suppressRefError, refKey = propCallInfo.refKey, elementRef = propCallInfo.elementRef;
        if (suppressRefError) {
          return;
        }
        if (!(elementRef != null && elementRef.current)) {
          console.error('downshift: The ref prop "' + refKey + '" from ' + propKey + " was not applied correctly on your element.");
        }
      });
    }, []);
    var setGetterPropCallInfo = q$1(function(propKey, suppressRefError, refKey, elementRef) {
      getterPropsCalledRef.current[propKey] = {
        suppressRefError,
        refKey,
        elementRef
      };
    }, []);
    return setGetterPropCallInfo;
  };
}
function useA11yMessageStatus(getA11yStatusMessage2, options, dependencyArray, environment) {
  if (environment === void 0) {
    environment = {};
  }
  var document2 = environment.document;
  var isInitialMount = useIsInitialMount();
  y(function() {
    if (!getA11yStatusMessage2 || isInitialMount || false || !document2) {
      return;
    }
    var status = getA11yStatusMessage2(options);
    updateA11yStatus(status, document2);
  }, dependencyArray);
  y(function() {
    return function() {
      updateA11yStatus.cancel();
      cleanupStatusDiv(document2);
    };
  }, [document2]);
}
function useScrollIntoView(_ref3) {
  var highlightedIndex = _ref3.highlightedIndex, isOpen = _ref3.isOpen, itemRefs = _ref3.itemRefs, getItemNodeFromIndex = _ref3.getItemNodeFromIndex, menuElement = _ref3.menuElement, scrollIntoViewProp = _ref3.scrollIntoView;
  var shouldScrollRef = A$1(true);
  useIsomorphicLayoutEffect(function() {
    if (highlightedIndex < 0 || !isOpen || !Object.keys(itemRefs.current).length) {
      return;
    }
    if (shouldScrollRef.current === false) {
      shouldScrollRef.current = true;
    } else {
      scrollIntoViewProp(getItemNodeFromIndex(highlightedIndex), menuElement);
    }
  }, [highlightedIndex]);
  return shouldScrollRef;
}
var useControlPropsValidator = noop;
if (process.env.NODE_ENV !== "production") {
  useControlPropsValidator = function useControlPropsValidator2(_ref4) {
    var props = _ref4.props, state2 = _ref4.state;
    var prevPropsRef = A$1(props);
    var isInitialMount = useIsInitialMount();
    y(function() {
      if (isInitialMount) {
        return;
      }
      validateControlledUnchanged(state2, prevPropsRef.current, props);
      prevPropsRef.current = props;
    }, [state2, props, isInitialMount]);
  };
}
function getChangesOnSelection(props, highlightedIndex, inputValue) {
  var _props$items;
  var shouldSelect = ((_props$items = props.items) == null ? void 0 : _props$items.length) && highlightedIndex >= 0;
  return _extends({
    isOpen: false,
    highlightedIndex: -1
  }, shouldSelect && _extends({
    selectedItem: props.items[highlightedIndex],
    isOpen: getDefaultValue$1(props, "isOpen"),
    highlightedIndex: getDefaultValue$1(props, "highlightedIndex")
  }, inputValue));
}
function isDropdownsStateEqual(prevState, newState) {
  return prevState.isOpen === newState.isOpen && prevState.inputValue === newState.inputValue && prevState.highlightedIndex === newState.highlightedIndex && prevState.selectedItem === newState.selectedItem;
}
function useIsInitialMount() {
  var isInitialMountRef = Rn.useRef(true);
  Rn.useEffect(function() {
    isInitialMountRef.current = false;
    return function() {
      isInitialMountRef.current = true;
    };
  }, []);
  return isInitialMountRef.current;
}
function getDefaultHighlightedIndex(props) {
  var highlightedIndex = getDefaultValue$1(props, "highlightedIndex");
  if (highlightedIndex > -1 && props.isItemDisabled(props.items[highlightedIndex], highlightedIndex)) {
    return -1;
  }
  return highlightedIndex;
}
function getInitialHighlightedIndex(props) {
  var highlightedIndex = getInitialValue$1(props, "highlightedIndex");
  if (highlightedIndex > -1 && props.isItemDisabled(props.items[highlightedIndex], highlightedIndex)) {
    return -1;
  }
  return highlightedIndex;
}
var commonPropTypes = {
  environment: PropTypes.shape({
    addEventListener: PropTypes.func.isRequired,
    removeEventListener: PropTypes.func.isRequired,
    document: PropTypes.shape({
      createElement: PropTypes.func.isRequired,
      getElementById: PropTypes.func.isRequired,
      activeElement: PropTypes.any.isRequired,
      body: PropTypes.any.isRequired
    }).isRequired,
    Node: PropTypes.func.isRequired
  }),
  itemToString: PropTypes.func,
  itemToKey: PropTypes.func,
  stateReducer: PropTypes.func
};
var commonDropdownPropTypes = _extends({}, commonPropTypes, {
  getA11yStatusMessage: PropTypes.func,
  highlightedIndex: PropTypes.number,
  defaultHighlightedIndex: PropTypes.number,
  initialHighlightedIndex: PropTypes.number,
  isOpen: PropTypes.bool,
  defaultIsOpen: PropTypes.bool,
  initialIsOpen: PropTypes.bool,
  selectedItem: PropTypes.any,
  initialSelectedItem: PropTypes.any,
  defaultSelectedItem: PropTypes.any,
  id: PropTypes.string,
  labelId: PropTypes.string,
  menuId: PropTypes.string,
  getItemId: PropTypes.func,
  toggleButtonId: PropTypes.string,
  onSelectedItemChange: PropTypes.func,
  onHighlightedIndexChange: PropTypes.func,
  onStateChange: PropTypes.func,
  onIsOpenChange: PropTypes.func,
  scrollIntoView: PropTypes.func
});
function downshiftCommonReducer(state2, action, stateChangeTypes) {
  var type = action.type, props = action.props;
  var changes;
  switch (type) {
    case stateChangeTypes.ItemMouseMove:
      changes = {
        highlightedIndex: action.disabled ? -1 : action.index
      };
      break;
    case stateChangeTypes.MenuMouseLeave:
      changes = {
        highlightedIndex: -1
      };
      break;
    case stateChangeTypes.ToggleButtonClick:
    case stateChangeTypes.FunctionToggleMenu:
      changes = {
        isOpen: !state2.isOpen,
        highlightedIndex: state2.isOpen ? -1 : getHighlightedIndexOnOpen(props, state2, 0)
      };
      break;
    case stateChangeTypes.FunctionOpenMenu:
      changes = {
        isOpen: true,
        highlightedIndex: getHighlightedIndexOnOpen(props, state2, 0)
      };
      break;
    case stateChangeTypes.FunctionCloseMenu:
      changes = {
        isOpen: false
      };
      break;
    case stateChangeTypes.FunctionSetHighlightedIndex:
      changes = {
        highlightedIndex: props.isItemDisabled(props.items[action.highlightedIndex], action.highlightedIndex) ? -1 : action.highlightedIndex
      };
      break;
    case stateChangeTypes.FunctionSetInputValue:
      changes = {
        inputValue: action.inputValue
      };
      break;
    case stateChangeTypes.FunctionReset:
      changes = {
        highlightedIndex: getDefaultHighlightedIndex(props),
        isOpen: getDefaultValue$1(props, "isOpen"),
        selectedItem: getDefaultValue$1(props, "selectedItem"),
        inputValue: getDefaultValue$1(props, "inputValue")
      };
      break;
    default:
      throw new Error("Reducer called without proper action type.");
  }
  return _extends({}, state2, changes);
}
function getItemIndexByCharacterKey(_a) {
  var keysSoFar = _a.keysSoFar, highlightedIndex = _a.highlightedIndex, items = _a.items, itemToString2 = _a.itemToString, isItemDisabled2 = _a.isItemDisabled;
  var lowerCasedKeysSoFar = keysSoFar.toLowerCase();
  for (var index = 0; index < items.length; index++) {
    var offsetIndex = (index + highlightedIndex + (keysSoFar.length < 2 ? 1 : 0)) % items.length;
    var item = items[offsetIndex];
    if (item !== void 0 && itemToString2(item).toLowerCase().startsWith(lowerCasedKeysSoFar) && !isItemDisabled2(item, offsetIndex)) {
      return offsetIndex;
    }
  }
  return highlightedIndex;
}
var propTypes$2 = __assign(__assign({}, commonDropdownPropTypes), { items: PropTypes.array.isRequired, isItemDisabled: PropTypes.func });
var defaultProps$2 = __assign(__assign({}, defaultProps$3), { isItemDisabled: function() {
  return false;
} });
var validatePropTypes$2 = noop;
if (process.env.NODE_ENV !== "production") {
  validatePropTypes$2 = function(options, caller) {
    PropTypes.checkPropTypes(propTypes$2, options, "prop", caller.name);
  };
}
var ToggleButtonClick$1 = process.env.NODE_ENV !== "production" ? "__togglebutton_click__" : 0;
var ToggleButtonKeyDownArrowDown = process.env.NODE_ENV !== "production" ? "__togglebutton_keydown_arrow_down__" : 1;
var ToggleButtonKeyDownArrowUp = process.env.NODE_ENV !== "production" ? "__togglebutton_keydown_arrow_up__" : 2;
var ToggleButtonKeyDownCharacter = process.env.NODE_ENV !== "production" ? "__togglebutton_keydown_character__" : 3;
var ToggleButtonKeyDownEscape = process.env.NODE_ENV !== "production" ? "__togglebutton_keydown_escape__" : 4;
var ToggleButtonKeyDownHome = process.env.NODE_ENV !== "production" ? "__togglebutton_keydown_home__" : 5;
var ToggleButtonKeyDownEnd = process.env.NODE_ENV !== "production" ? "__togglebutton_keydown_end__" : 6;
var ToggleButtonKeyDownEnter = process.env.NODE_ENV !== "production" ? "__togglebutton_keydown_enter__" : 7;
var ToggleButtonKeyDownSpaceButton = process.env.NODE_ENV !== "production" ? "__togglebutton_keydown_space_button__" : 8;
var ToggleButtonKeyDownPageUp = process.env.NODE_ENV !== "production" ? "__togglebutton_keydown_page_up__" : 9;
var ToggleButtonKeyDownPageDown = process.env.NODE_ENV !== "production" ? "__togglebutton_keydown_page_down__" : 10;
var ToggleButtonBlur = process.env.NODE_ENV !== "production" ? "__togglebutton_blur__" : 11;
var MenuMouseLeave$1 = process.env.NODE_ENV !== "production" ? "__menu_mouse_leave__" : 12;
var ItemMouseMove$1 = process.env.NODE_ENV !== "production" ? "__item_mouse_move__" : 13;
var ItemClick$1 = process.env.NODE_ENV !== "production" ? "__item_click__" : 14;
var FunctionToggleMenu$1 = process.env.NODE_ENV !== "production" ? "__function_toggle_menu__" : 15;
var FunctionOpenMenu$1 = process.env.NODE_ENV !== "production" ? "__function_open_menu__" : 16;
var FunctionCloseMenu$1 = process.env.NODE_ENV !== "production" ? "__function_close_menu__" : 17;
var FunctionSetHighlightedIndex$1 = process.env.NODE_ENV !== "production" ? "__function_set_highlighted_index__" : 18;
var FunctionSelectItem$1 = process.env.NODE_ENV !== "production" ? "__function_select_item__" : 19;
var FunctionSetInputValue$1 = process.env.NODE_ENV !== "production" ? "__function_set_input_value__" : 20;
var FunctionReset$2 = process.env.NODE_ENV !== "production" ? "__function_reset__" : 21;
var stateChangeTypes$2 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  FunctionCloseMenu: FunctionCloseMenu$1,
  FunctionOpenMenu: FunctionOpenMenu$1,
  FunctionReset: FunctionReset$2,
  FunctionSelectItem: FunctionSelectItem$1,
  FunctionSetHighlightedIndex: FunctionSetHighlightedIndex$1,
  FunctionSetInputValue: FunctionSetInputValue$1,
  FunctionToggleMenu: FunctionToggleMenu$1,
  ItemClick: ItemClick$1,
  ItemMouseMove: ItemMouseMove$1,
  MenuMouseLeave: MenuMouseLeave$1,
  ToggleButtonBlur,
  ToggleButtonClick: ToggleButtonClick$1,
  ToggleButtonKeyDownArrowDown,
  ToggleButtonKeyDownArrowUp,
  ToggleButtonKeyDownCharacter,
  ToggleButtonKeyDownEnd,
  ToggleButtonKeyDownEnter,
  ToggleButtonKeyDownEscape,
  ToggleButtonKeyDownHome,
  ToggleButtonKeyDownPageDown,
  ToggleButtonKeyDownPageUp,
  ToggleButtonKeyDownSpaceButton
});
function downshiftSelectReducer(state2, action) {
  var _props$items;
  var type = action.type, props = action.props, altKey = action.altKey;
  var changes;
  switch (type) {
    case ItemClick$1:
      changes = {
        isOpen: getDefaultValue$1(props, "isOpen"),
        highlightedIndex: getDefaultHighlightedIndex(props),
        selectedItem: props.items[action.index]
      };
      break;
    case ToggleButtonKeyDownCharacter:
      {
        var lowercasedKey = action.key;
        var inputValue = "" + state2.inputValue + lowercasedKey;
        var prevHighlightedIndex = !state2.isOpen && state2.selectedItem ? props.items.findIndex(function(item) {
          return props.itemToKey(item) === props.itemToKey(state2.selectedItem);
        }) : state2.highlightedIndex;
        var highlightedIndex = getItemIndexByCharacterKey({
          keysSoFar: inputValue,
          highlightedIndex: prevHighlightedIndex,
          items: props.items,
          itemToString: props.itemToString,
          isItemDisabled: props.isItemDisabled
        });
        changes = {
          inputValue,
          highlightedIndex,
          isOpen: true
        };
      }
      break;
    case ToggleButtonKeyDownArrowDown:
      {
        var _highlightedIndex = state2.isOpen ? getHighlightedIndex(state2.highlightedIndex, 1, props.items, props.isItemDisabled) : altKey && state2.selectedItem == null ? -1 : getHighlightedIndexOnOpen(props, state2, 1);
        changes = {
          highlightedIndex: _highlightedIndex,
          isOpen: true
        };
      }
      break;
    case ToggleButtonKeyDownArrowUp:
      if (state2.isOpen && altKey) {
        changes = getChangesOnSelection(props, state2.highlightedIndex, false);
      } else {
        var _highlightedIndex2 = state2.isOpen ? getHighlightedIndex(state2.highlightedIndex, -1, props.items, props.isItemDisabled) : getHighlightedIndexOnOpen(props, state2, -1);
        changes = {
          highlightedIndex: _highlightedIndex2,
          isOpen: true
        };
      }
      break;
    // only triggered when menu is open.
    case ToggleButtonKeyDownEnter:
    case ToggleButtonKeyDownSpaceButton:
      changes = getChangesOnSelection(props, state2.highlightedIndex, false);
      break;
    case ToggleButtonKeyDownHome:
      changes = {
        highlightedIndex: getNonDisabledIndex(0, false, props.items, props.isItemDisabled),
        isOpen: true
      };
      break;
    case ToggleButtonKeyDownEnd:
      changes = {
        highlightedIndex: getNonDisabledIndex(props.items.length - 1, true, props.items, props.isItemDisabled),
        isOpen: true
      };
      break;
    case ToggleButtonKeyDownPageUp:
      changes = {
        highlightedIndex: getHighlightedIndex(state2.highlightedIndex, -10, props.items, props.isItemDisabled)
      };
      break;
    case ToggleButtonKeyDownPageDown:
      changes = {
        highlightedIndex: getHighlightedIndex(state2.highlightedIndex, 10, props.items, props.isItemDisabled)
      };
      break;
    case ToggleButtonKeyDownEscape:
      changes = {
        isOpen: false,
        highlightedIndex: -1
      };
      break;
    case ToggleButtonBlur:
      changes = _extends({
        isOpen: false,
        highlightedIndex: -1
      }, state2.highlightedIndex >= 0 && ((_props$items = props.items) == null ? void 0 : _props$items.length) && {
        selectedItem: props.items[state2.highlightedIndex]
      });
      break;
    case FunctionSelectItem$1:
      changes = {
        selectedItem: action.selectedItem
      };
      break;
    default:
      return downshiftCommonReducer(state2, action, stateChangeTypes$2);
  }
  return _extends({}, state2, changes);
}
var _excluded$2 = ["onClick"], _excluded2$2 = ["onMouseLeave", "refKey", "ref"], _excluded3$1 = ["onBlur", "onClick", "onPress", "onKeyDown", "refKey", "ref"], _excluded4$1 = ["item", "index", "onMouseMove", "onClick", "onMouseDown", "onPress", "refKey", "disabled", "ref"];
useSelect.stateChangeTypes = stateChangeTypes$2;
function useSelect(userProps) {
  if (userProps === void 0) {
    userProps = {};
  }
  validatePropTypes$2(userProps, useSelect);
  var props = _extends({}, defaultProps$2, userProps);
  var scrollIntoView2 = props.scrollIntoView, environment = props.environment, getA11yStatusMessage2 = props.getA11yStatusMessage;
  var _useControlledReducer = useControlledReducer$1(downshiftSelectReducer, props, getInitialState$2, isDropdownsStateEqual), state2 = _useControlledReducer[0], dispatch = _useControlledReducer[1];
  var isOpen = state2.isOpen, highlightedIndex = state2.highlightedIndex, selectedItem = state2.selectedItem, inputValue = state2.inputValue;
  var toggleButtonRef = A$1(null);
  var menuRef = A$1(null);
  var itemRefs = A$1({});
  var clearTimeoutRef = A$1(null);
  var elementIds = useElementIds(props);
  var latest = useLatestRef({
    state: state2,
    props
  });
  var getItemNodeFromIndex = q$1(function(index) {
    return itemRefs.current[elementIds.getItemId(index)];
  }, [elementIds]);
  useA11yMessageStatus(getA11yStatusMessage2, state2, [isOpen, highlightedIndex, selectedItem, inputValue], environment);
  var shouldScrollRef = useScrollIntoView({
    menuElement: menuRef.current,
    highlightedIndex,
    isOpen,
    itemRefs,
    scrollIntoView: scrollIntoView2,
    getItemNodeFromIndex
  });
  y(function() {
    clearTimeoutRef.current = debounce(function(outerDispatch) {
      outerDispatch({
        type: FunctionSetInputValue$1,
        inputValue: ""
      });
    }, 500);
    return function() {
      clearTimeoutRef.current.cancel();
    };
  }, []);
  y(function() {
    if (!inputValue) {
      return;
    }
    clearTimeoutRef.current(dispatch);
  }, [dispatch, inputValue]);
  useControlPropsValidator({
    props,
    state: state2
  });
  y(function() {
    var focusOnOpen = getInitialValue$1(props, "isOpen");
    if (focusOnOpen && toggleButtonRef.current) {
      toggleButtonRef.current.focus();
    }
  }, []);
  var handleBlurInTracker = q$1(function handleBlur() {
    if (latest.current.state.isOpen) {
      dispatch({
        type: ToggleButtonBlur
      });
    }
  }, [dispatch, latest]);
  var downshiftRefs = T$1(function() {
    return [menuRef, toggleButtonRef];
  }, []);
  var mouseAndTouchTrackers = useMouseAndTouchTracker(environment, handleBlurInTracker, downshiftRefs);
  var setGetterPropCallInfo = useGetterPropsCalledChecker("getMenuProps", "getToggleButtonProps");
  y(function() {
    if (!isOpen) {
      itemRefs.current = {};
    }
  }, [isOpen]);
  var toggleButtonKeyDownHandlers = T$1(function() {
    return {
      ArrowDown: function ArrowDown(event) {
        event.preventDefault();
        dispatch({
          type: ToggleButtonKeyDownArrowDown,
          altKey: event.altKey
        });
      },
      ArrowUp: function ArrowUp(event) {
        event.preventDefault();
        dispatch({
          type: ToggleButtonKeyDownArrowUp,
          altKey: event.altKey
        });
      },
      Home: function Home(event) {
        event.preventDefault();
        dispatch({
          type: ToggleButtonKeyDownHome
        });
      },
      End: function End(event) {
        event.preventDefault();
        dispatch({
          type: ToggleButtonKeyDownEnd
        });
      },
      Escape: function Escape() {
        if (latest.current.state.isOpen) {
          dispatch({
            type: ToggleButtonKeyDownEscape
          });
        }
      },
      Enter: function Enter(event) {
        event.preventDefault();
        dispatch({
          type: latest.current.state.isOpen ? ToggleButtonKeyDownEnter : ToggleButtonClick$1
        });
      },
      PageUp: function PageUp(event) {
        if (latest.current.state.isOpen) {
          event.preventDefault();
          dispatch({
            type: ToggleButtonKeyDownPageUp
          });
        }
      },
      PageDown: function PageDown(event) {
        if (latest.current.state.isOpen) {
          event.preventDefault();
          dispatch({
            type: ToggleButtonKeyDownPageDown
          });
        }
      },
      " ": function _2(event) {
        event.preventDefault();
        var currentState = latest.current.state;
        if (!currentState.isOpen) {
          dispatch({
            type: ToggleButtonClick$1
          });
          return;
        }
        if (currentState.inputValue) {
          dispatch({
            type: ToggleButtonKeyDownCharacter,
            key: " "
          });
        } else {
          dispatch({
            type: ToggleButtonKeyDownSpaceButton
          });
        }
      }
    };
  }, [dispatch, latest]);
  var toggleMenu = q$1(function() {
    dispatch({
      type: FunctionToggleMenu$1
    });
  }, [dispatch]);
  var closeMenu = q$1(function() {
    dispatch({
      type: FunctionCloseMenu$1
    });
  }, [dispatch]);
  var openMenu = q$1(function() {
    dispatch({
      type: FunctionOpenMenu$1
    });
  }, [dispatch]);
  var setHighlightedIndex = q$1(function(newHighlightedIndex) {
    dispatch({
      type: FunctionSetHighlightedIndex$1,
      highlightedIndex: newHighlightedIndex
    });
  }, [dispatch]);
  var selectItem = q$1(function(newSelectedItem) {
    dispatch({
      type: FunctionSelectItem$1,
      selectedItem: newSelectedItem
    });
  }, [dispatch]);
  var reset = q$1(function() {
    dispatch({
      type: FunctionReset$2
    });
  }, [dispatch]);
  var setInputValue = q$1(function(newInputValue) {
    dispatch({
      type: FunctionSetInputValue$1,
      inputValue: newInputValue
    });
  }, [dispatch]);
  var getLabelProps = q$1(function(_temp) {
    var _ref = _temp === void 0 ? {} : _temp, onClick = _ref.onClick, labelProps = _objectWithoutPropertiesLoose(_ref, _excluded$2);
    var labelHandleClick = function labelHandleClick2() {
      var _toggleButtonRef$curr;
      (_toggleButtonRef$curr = toggleButtonRef.current) == null || _toggleButtonRef$curr.focus();
    };
    return _extends({
      id: elementIds.labelId,
      htmlFor: elementIds.toggleButtonId,
      onClick: callAllEventHandlers(onClick, labelHandleClick)
    }, labelProps);
  }, [elementIds]);
  var getMenuProps = q$1(function(_temp2, _temp3) {
    var _extends2;
    var _ref2 = _temp2 === void 0 ? {} : _temp2, onMouseLeave = _ref2.onMouseLeave, _ref2$refKey = _ref2.refKey, refKey = _ref2$refKey === void 0 ? "ref" : _ref2$refKey, ref = _ref2.ref, rest = _objectWithoutPropertiesLoose(_ref2, _excluded2$2);
    var _ref3 = _temp3 === void 0 ? {} : _temp3, _ref3$suppressRefErro = _ref3.suppressRefError, suppressRefError = _ref3$suppressRefErro === void 0 ? false : _ref3$suppressRefErro;
    var menuHandleMouseLeave = function menuHandleMouseLeave2() {
      dispatch({
        type: MenuMouseLeave$1
      });
    };
    setGetterPropCallInfo("getMenuProps", suppressRefError, refKey, menuRef);
    return _extends((_extends2 = {}, _extends2[refKey] = handleRefs(ref, function(menuNode) {
      menuRef.current = menuNode;
    }), _extends2.id = elementIds.menuId, _extends2.role = "listbox", _extends2["aria-labelledby"] = rest && rest["aria-label"] ? void 0 : "" + elementIds.labelId, _extends2.onMouseLeave = callAllEventHandlers(onMouseLeave, menuHandleMouseLeave), _extends2), rest);
  }, [dispatch, setGetterPropCallInfo, elementIds]);
  var getToggleButtonProps = q$1(function(_temp4, _temp5) {
    var _extends3;
    var _ref4 = _temp4 === void 0 ? {} : _temp4, onBlur = _ref4.onBlur, onClick = _ref4.onClick;
    _ref4.onPress;
    var onKeyDown = _ref4.onKeyDown, _ref4$refKey = _ref4.refKey, refKey = _ref4$refKey === void 0 ? "ref" : _ref4$refKey, ref = _ref4.ref, rest = _objectWithoutPropertiesLoose(_ref4, _excluded3$1);
    var _ref5 = _temp5 === void 0 ? {} : _temp5, _ref5$suppressRefErro = _ref5.suppressRefError, suppressRefError = _ref5$suppressRefErro === void 0 ? false : _ref5$suppressRefErro;
    var latestState = latest.current.state;
    var toggleButtonHandleClick = function toggleButtonHandleClick2() {
      dispatch({
        type: ToggleButtonClick$1
      });
    };
    var toggleButtonHandleBlur = function toggleButtonHandleBlur2() {
      if (latestState.isOpen && !mouseAndTouchTrackers.isMouseDown) {
        dispatch({
          type: ToggleButtonBlur
        });
      }
    };
    var toggleButtonHandleKeyDown = function toggleButtonHandleKeyDown2(event) {
      var key = normalizeArrowKey(event);
      if (key && toggleButtonKeyDownHandlers[key]) {
        toggleButtonKeyDownHandlers[key](event);
      } else if (isAcceptedCharacterKey(key)) {
        dispatch({
          type: ToggleButtonKeyDownCharacter,
          key
        });
      }
    };
    var toggleProps = _extends((_extends3 = {}, _extends3[refKey] = handleRefs(ref, function(toggleButtonNode) {
      toggleButtonRef.current = toggleButtonNode;
    }), _extends3["aria-activedescendant"] = latestState.isOpen && latestState.highlightedIndex > -1 ? elementIds.getItemId(latestState.highlightedIndex) : "", _extends3["aria-controls"] = elementIds.menuId, _extends3["aria-expanded"] = latest.current.state.isOpen, _extends3["aria-haspopup"] = "listbox", _extends3["aria-labelledby"] = rest && rest["aria-label"] ? void 0 : "" + elementIds.labelId, _extends3.id = elementIds.toggleButtonId, _extends3.role = "combobox", _extends3.tabIndex = 0, _extends3.onBlur = callAllEventHandlers(onBlur, toggleButtonHandleBlur), _extends3), rest);
    if (!rest.disabled) {
      {
        toggleProps.onClick = callAllEventHandlers(onClick, toggleButtonHandleClick);
        toggleProps.onKeyDown = callAllEventHandlers(onKeyDown, toggleButtonHandleKeyDown);
      }
    }
    setGetterPropCallInfo("getToggleButtonProps", suppressRefError, refKey, toggleButtonRef);
    return toggleProps;
  }, [dispatch, elementIds, latest, mouseAndTouchTrackers, setGetterPropCallInfo, toggleButtonKeyDownHandlers]);
  var getItemProps = q$1(function(_temp6) {
    var _extends4;
    var _ref6 = _temp6 === void 0 ? {} : _temp6, itemProp = _ref6.item, indexProp = _ref6.index, onMouseMove = _ref6.onMouseMove, onClick = _ref6.onClick, onMouseDown = _ref6.onMouseDown;
    _ref6.onPress;
    var _ref6$refKey = _ref6.refKey, refKey = _ref6$refKey === void 0 ? "ref" : _ref6$refKey, disabledProp = _ref6.disabled, ref = _ref6.ref, rest = _objectWithoutPropertiesLoose(_ref6, _excluded4$1);
    if (disabledProp !== void 0) {
      console.warn('Passing "disabled" as an argument to getItemProps is not supported anymore. Please use the isItemDisabled prop from useSelect.');
    }
    var _latest$current = latest.current, latestState = _latest$current.state, latestProps = _latest$current.props;
    var _getItemAndIndex = getItemAndIndex(itemProp, indexProp, latestProps.items, "Pass either item or index to getItemProps!"), item = _getItemAndIndex[0], index = _getItemAndIndex[1];
    var disabled = latestProps.isItemDisabled(item, index);
    var itemHandleMouseMove = function itemHandleMouseMove2() {
      if (mouseAndTouchTrackers.isTouchEnd || index === latestState.highlightedIndex) {
        return;
      }
      shouldScrollRef.current = false;
      dispatch({
        type: ItemMouseMove$1,
        index,
        disabled
      });
    };
    var itemHandleClick = function itemHandleClick2() {
      dispatch({
        type: ItemClick$1,
        index
      });
    };
    var itemHandleMouseDown = function itemHandleMouseDown2(e2) {
      return e2.preventDefault();
    };
    var itemProps = _extends((_extends4 = {}, _extends4[refKey] = handleRefs(ref, function(itemNode) {
      if (itemNode) {
        itemRefs.current[elementIds.getItemId(index)] = itemNode;
      }
    }), _extends4["aria-disabled"] = disabled, _extends4["aria-selected"] = item === latestState.selectedItem, _extends4.id = elementIds.getItemId(index), _extends4.role = "option", _extends4), rest);
    if (!disabled) {
      {
        itemProps.onClick = callAllEventHandlers(onClick, itemHandleClick);
      }
    }
    itemProps.onMouseMove = callAllEventHandlers(onMouseMove, itemHandleMouseMove);
    itemProps.onMouseDown = callAllEventHandlers(onMouseDown, itemHandleMouseDown);
    return itemProps;
  }, [latest, elementIds, mouseAndTouchTrackers, shouldScrollRef, dispatch]);
  return {
    // prop getters.
    getToggleButtonProps,
    getLabelProps,
    getMenuProps,
    getItemProps,
    // actions.
    toggleMenu,
    openMenu,
    closeMenu,
    setHighlightedIndex,
    selectItem,
    reset,
    setInputValue,
    // state.
    highlightedIndex,
    isOpen,
    selectedItem,
    inputValue
  };
}
process.env.NODE_ENV !== "production" ? "__input_keydown_arrow_down__" : 0;
process.env.NODE_ENV !== "production" ? "__input_keydown_arrow_up__" : 1;
process.env.NODE_ENV !== "production" ? "__input_keydown_escape__" : 2;
process.env.NODE_ENV !== "production" ? "__input_keydown_home__" : 3;
process.env.NODE_ENV !== "production" ? "__input_keydown_end__" : 4;
process.env.NODE_ENV !== "production" ? "__input_keydown_page_up__" : 5;
process.env.NODE_ENV !== "production" ? "__input_keydown_page_down__" : 6;
process.env.NODE_ENV !== "production" ? "__input_keydown_enter__" : 7;
process.env.NODE_ENV !== "production" ? "__input_change__" : 8;
process.env.NODE_ENV !== "production" ? "__input_blur__" : 9;
process.env.NODE_ENV !== "production" ? "__input_click__" : 10;
process.env.NODE_ENV !== "production" ? "__menu_mouse_leave__" : 11;
process.env.NODE_ENV !== "production" ? "__item_mouse_move__" : 12;
process.env.NODE_ENV !== "production" ? "__item_click__" : 13;
process.env.NODE_ENV !== "production" ? "__togglebutton_click__" : 14;
process.env.NODE_ENV !== "production" ? "__function_toggle_menu__" : 15;
process.env.NODE_ENV !== "production" ? "__function_open_menu__" : 16;
process.env.NODE_ENV !== "production" ? "__function_close_menu__" : 17;
process.env.NODE_ENV !== "production" ? "__function_set_highlighted_index__" : 18;
process.env.NODE_ENV !== "production" ? "__function_select_item__" : 19;
process.env.NODE_ENV !== "production" ? "__function_set_input_value__" : 20;
process.env.NODE_ENV !== "production" ? "__function_reset__" : 21;
process.env.NODE_ENV !== "production" ? "__controlled_prop_updated_selected_item__" : 22;
_extends({}, commonDropdownPropTypes, {
  items: PropTypes.array.isRequired,
  isItemDisabled: PropTypes.func,
  inputValue: PropTypes.string,
  defaultInputValue: PropTypes.string,
  initialInputValue: PropTypes.string,
  inputId: PropTypes.string,
  onInputValueChange: PropTypes.func
});
if (process.env.NODE_ENV !== "production") ;
_extends({}, defaultProps$3, {
  isItemDisabled: function isItemDisabled() {
    return false;
  }
});
({
  stateReducer: commonPropTypes.stateReducer,
  itemToKey: commonPropTypes.itemToKey,
  environment: commonPropTypes.environment,
  selectedItems: PropTypes.array,
  initialSelectedItems: PropTypes.array,
  defaultSelectedItems: PropTypes.array,
  getA11yStatusMessage: PropTypes.func,
  activeIndex: PropTypes.number,
  initialActiveIndex: PropTypes.number,
  defaultActiveIndex: PropTypes.number,
  onActiveIndexChange: PropTypes.func,
  onSelectedItemsChange: PropTypes.func,
  keyNavigationNext: PropTypes.string,
  keyNavigationPrevious: PropTypes.string
});
({
  itemToKey: defaultProps$3.itemToKey,
  stateReducer: defaultProps$3.stateReducer,
  environment: defaultProps$3.environment
});
if (process.env.NODE_ENV !== "production") ;
process.env.NODE_ENV !== "production" ? "__selected_item_click__" : 0;
process.env.NODE_ENV !== "production" ? "__selected_item_keydown_delete__" : 1;
process.env.NODE_ENV !== "production" ? "__selected_item_keydown_backspace__" : 2;
process.env.NODE_ENV !== "production" ? "__selected_item_keydown_navigation_next__" : 3;
process.env.NODE_ENV !== "production" ? "__selected_item_keydown_navigation_previous__" : 4;
process.env.NODE_ENV !== "production" ? "__dropdown_keydown_navigation_previous__" : 5;
process.env.NODE_ENV !== "production" ? "__dropdown_keydown_backspace__" : 6;
process.env.NODE_ENV !== "production" ? "__dropdown_click__" : 7;
process.env.NODE_ENV !== "production" ? "__function_add_selected_item__" : 8;
process.env.NODE_ENV !== "production" ? "__function_remove_selected_item__" : 9;
process.env.NODE_ENV !== "production" ? "__function_set_selected_items__" : 10;
process.env.NODE_ENV !== "production" ? "__function_set_active_index__" : 11;
process.env.NODE_ENV !== "production" ? "__function_reset__" : 12;
function useMacOSCheck() {
  const plugin = usePlugin();
  const enabled = plugin && plugin.settings?.dropdownEmulation;
  return enabled && require$$0$1.Platform.isMacOS;
}
function FallbackStyledDropdown({
  items,
  selectedItem,
  onChange,
  showButton = true
}) {
  const select = /* @__PURE__ */ u$1(
    "div",
    {
      className: "relative",
      onClick: (e2) => {
        e2.stopPropagation();
      },
      children: [
        items.find((item) => item.value === selectedItem).label,
        /* @__PURE__ */ u$1(
          "select",
          {
            value: selectedItem,
            onChange: (e2) => onChange(e2.target.value),
            className: "absolute top-0 left-0 right-0 bottom-0 border-none! p-0! m-0! h-auto! w-auto! text-[0px] opacity-0",
            children: items.map((item) => /* @__PURE__ */ u$1("option", { value: item.value, children: item.label }, item.value))
          }
        )
      ]
    }
  );
  return !showButton ? select : /* @__PURE__ */ u$1("button", { className: "p-1 rounded hover:bg-background-modifier-hover active:bg-background-modifier-active transition-colors w-full justify-start! active:outline-[3px solid var(--color-base-50)]", children: select });
}
function MacOSStyledDropdown({
  items,
  selectedItem,
  onChange,
  optionHeight = 24,
  showButton = true
}) {
  const {
    isOpen,
    getToggleButtonProps,
    getLabelProps,
    getMenuProps,
    highlightedIndex,
    getItemProps
  } = useSelect({
    items,
    selectedItem: items.find((item) => item.value === selectedItem),
    onSelectedItemChange: ({
      selectedItem: newSelectedItem
    }) => newSelectedItem && onChange(newSelectedItem.value)
  });
  const modal = items.map((item, index) => /* @__PURE__ */ u$1(
    "div",
    {
      ...getItemProps({ index, item }),
      className: `p-0.75 text-(size:--font-ui-small) flex flex-row items-center pl-5 rounded ${(highlightedIndex == -1 ? items.findIndex((item2) => item2.value === selectedItem) === index : highlightedIndex === index) ? "bg-(--background-modifier-hover)" : ""} active:bg-(--background-modifier-active-hover)`,
      style: {
        height: optionHeight
      },
      children: [
        /* @__PURE__ */ u$1(
          "div",
          {
            className: `absolute font-bold left-2.5 ${selectedItem === item.value ? "block" : "hidden"}`,
            children: "âœ“"
          }
        ),
        item.label
      ]
    },
    item.value
  ));
  return /* @__PURE__ */ u$1(
    "div",
    {
      onClick: (e2) => {
        e2.stopPropagation();
      },
      children: [
        /* @__PURE__ */ u$1("div", { id: "dropdown-anchor", className: "anchor-relative" }),
        /* @__PURE__ */ u$1("div", { children: !showButton ? /* @__PURE__ */ u$1("label", { ...getLabelProps(), ...getToggleButtonProps(), children: items.find((item) => item.value === selectedItem).label }) : /* @__PURE__ */ u$1(
          "button",
          {
            ...getToggleButtonProps(),
            className: "p-1 rounded hover:bg-background-modifier-hover active:bg-background-modifier-active transition-colors w-full justify-start!",
            "aria-label": isOpen ? "Close menu" : "Open menu",
            style: {
              outline: isOpen ? "3px solid var(--color-base-50)" : null
            },
            children: /* @__PURE__ */ u$1("label", { ...getLabelProps(), children: items.find((item) => item.value === selectedItem).label })
          }
        ) }),
        /* @__PURE__ */ u$1(
          "div",
          {
            id: "dropdown-portal",
            className: "fixed top-0 left-0 w-full h-full pointer-events-none"
          }
        ),
        /* @__PURE__ */ u$1(
          "div",
          {
            className: "anchor-position:top anchor-reference:anchor(--dropdown-anchor) min-w-full z-50",
            style: {
              opacity: isOpen ? 1 : 0,
              pointerEvents: isOpen ? "auto" : "none",
              transitionProperty: "opacity, top",
              transitionTimingFunction: isOpen ? "none" : "linear, steps(1, end)",
              transitionDuration: isOpen ? "0ms" : "150ms, 0ms",
              transitionDelay: isOpen ? "0ms" : "0ms, 5000ms",
              top: -Math.max(
                items.findIndex((item) => item.value === selectedItem),
                0
              ) * optionHeight - 1
            },
            children: /* @__PURE__ */ u$1(
              "div",
              {
                ...getMenuProps(),
                className: `px-0.5 py-1 w-full bg-(--background-modifier-form-field) border border-(--color-base-40) rounded-lg shadow-lg`,
                children: modal
              }
            )
          }
        )
      ]
    }
  );
}
function Dropdown({
  items,
  selectedItem,
  onChange,
  optionHeight,
  showButton = true
}) {
  if (useMacOSCheck()) {
    return /* @__PURE__ */ u$1(
      MacOSStyledDropdown,
      {
        items,
        selectedItem,
        onChange,
        optionHeight,
        showButton
      }
    );
  } else {
    return /* @__PURE__ */ u$1(
      FallbackStyledDropdown,
      {
        items,
        selectedItem,
        onChange,
        showButton
      }
    );
  }
}
var reactResizable = { exports: {} };
var Resizable = {};
const require$$0 = /* @__PURE__ */ getAugmentedNamespace(compat_module);
var cjs = { exports: {} };
var Draggable = {};
var clsx = { exports: {} };
var hasRequiredClsx;
function requireClsx() {
  if (hasRequiredClsx) return clsx.exports;
  hasRequiredClsx = 1;
  function r2(e3) {
    var o2, t2, f2 = "";
    if ("string" == typeof e3 || "number" == typeof e3) f2 += e3;
    else if ("object" == typeof e3) if (Array.isArray(e3)) {
      var n2 = e3.length;
      for (o2 = 0; o2 < n2; o2++) e3[o2] && (t2 = r2(e3[o2])) && (f2 && (f2 += " "), f2 += t2);
    } else for (t2 in e3) e3[t2] && (f2 && (f2 += " "), f2 += t2);
    return f2;
  }
  function e2() {
    for (var e3, o2, t2 = 0, f2 = "", n2 = arguments.length; t2 < n2; t2++) (e3 = arguments[t2]) && (o2 = r2(e3)) && (f2 && (f2 += " "), f2 += o2);
    return f2;
  }
  clsx.exports = e2, clsx.exports.clsx = e2;
  return clsx.exports;
}
var domFns = {};
var shims = {};
var hasRequiredShims;
function requireShims() {
  if (hasRequiredShims) return shims;
  hasRequiredShims = 1;
  Object.defineProperty(shims, "__esModule", {
    value: true
  });
  shims.dontSetMe = dontSetMe;
  shims.findInArray = findInArray;
  shims.int = int;
  shims.isFunction = isFunction2;
  shims.isNum = isNum;
  function findInArray(array, callback) {
    for (let i2 = 0, length = array.length; i2 < length; i2++) {
      if (callback.apply(callback, [array[i2], i2, array])) return array[i2];
    }
  }
  function isFunction2(func) {
    return typeof func === "function" || Object.prototype.toString.call(func) === "[object Function]";
  }
  function isNum(num) {
    return typeof num === "number" && !isNaN(num);
  }
  function int(a2) {
    return parseInt(a2, 10);
  }
  function dontSetMe(props, propName, componentName) {
    if (props[propName]) {
      return new Error(`Invalid prop ${propName} passed to ${componentName} - do not set this, set it on the child.`);
    }
  }
  return shims;
}
var getPrefix = {};
var hasRequiredGetPrefix;
function requireGetPrefix() {
  if (hasRequiredGetPrefix) return getPrefix;
  hasRequiredGetPrefix = 1;
  Object.defineProperty(getPrefix, "__esModule", {
    value: true
  });
  getPrefix.browserPrefixToKey = browserPrefixToKey;
  getPrefix.browserPrefixToStyle = browserPrefixToStyle;
  getPrefix.default = void 0;
  getPrefix.getPrefix = getPrefix$1;
  const prefixes = ["Moz", "Webkit", "O", "ms"];
  function getPrefix$1() {
    let prop = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "transform";
    if (typeof window === "undefined") return "";
    const style = window.document?.documentElement?.style;
    if (!style) return "";
    if (prop in style) return "";
    for (let i2 = 0; i2 < prefixes.length; i2++) {
      if (browserPrefixToKey(prop, prefixes[i2]) in style) return prefixes[i2];
    }
    return "";
  }
  function browserPrefixToKey(prop, prefix) {
    return prefix ? `${prefix}${kebabToTitleCase(prop)}` : prop;
  }
  function browserPrefixToStyle(prop, prefix) {
    return prefix ? `-${prefix.toLowerCase()}-${prop}` : prop;
  }
  function kebabToTitleCase(str) {
    let out = "";
    let shouldCapitalize = true;
    for (let i2 = 0; i2 < str.length; i2++) {
      if (shouldCapitalize) {
        out += str[i2].toUpperCase();
        shouldCapitalize = false;
      } else if (str[i2] === "-") {
        shouldCapitalize = true;
      } else {
        out += str[i2];
      }
    }
    return out;
  }
  getPrefix.default = getPrefix$1();
  return getPrefix;
}
var hasRequiredDomFns;
function requireDomFns() {
  if (hasRequiredDomFns) return domFns;
  hasRequiredDomFns = 1;
  Object.defineProperty(domFns, "__esModule", {
    value: true
  });
  domFns.addClassName = addClassName;
  domFns.addEvent = addEvent;
  domFns.addUserSelectStyles = addUserSelectStyles;
  domFns.createCSSTransform = createCSSTransform;
  domFns.createSVGTransform = createSVGTransform;
  domFns.getTouch = getTouch;
  domFns.getTouchIdentifier = getTouchIdentifier;
  domFns.getTranslation = getTranslation;
  domFns.innerHeight = innerHeight2;
  domFns.innerWidth = innerWidth2;
  domFns.matchesSelector = matchesSelector;
  domFns.matchesSelectorAndParentsTo = matchesSelectorAndParentsTo;
  domFns.offsetXYFromParent = offsetXYFromParent;
  domFns.outerHeight = outerHeight;
  domFns.outerWidth = outerWidth;
  domFns.removeClassName = removeClassName;
  domFns.removeEvent = removeEvent;
  domFns.scheduleRemoveUserSelectStyles = scheduleRemoveUserSelectStyles;
  var _shims = requireShims();
  var _getPrefix = _interopRequireWildcard(requireGetPrefix());
  function _interopRequireWildcard(e2, t2) {
    if ("function" == typeof WeakMap) var r2 = /* @__PURE__ */ new WeakMap(), n2 = /* @__PURE__ */ new WeakMap();
    return (_interopRequireWildcard = function(e3, t3) {
      if (!t3 && e3 && e3.__esModule) return e3;
      var o2, i2, f2 = { __proto__: null, default: e3 };
      if (null === e3 || "object" != typeof e3 && "function" != typeof e3) return f2;
      if (o2 = t3 ? n2 : r2) {
        if (o2.has(e3)) return o2.get(e3);
        o2.set(e3, f2);
      }
      for (const t4 in e3) "default" !== t4 && {}.hasOwnProperty.call(e3, t4) && ((i2 = (o2 = Object.defineProperty) && Object.getOwnPropertyDescriptor(e3, t4)) && (i2.get || i2.set) ? o2(f2, t4, i2) : f2[t4] = e3[t4]);
      return f2;
    })(e2, t2);
  }
  let matchesSelectorFunc = "";
  function matchesSelector(el, selector) {
    if (!matchesSelectorFunc) {
      matchesSelectorFunc = (0, _shims.findInArray)(["matches", "webkitMatchesSelector", "mozMatchesSelector", "msMatchesSelector", "oMatchesSelector"], function(method) {
        return (0, _shims.isFunction)(el[method]);
      });
    }
    if (!(0, _shims.isFunction)(el[matchesSelectorFunc])) return false;
    return el[matchesSelectorFunc](selector);
  }
  function matchesSelectorAndParentsTo(el, selector, baseNode) {
    let node = el;
    do {
      if (matchesSelector(node, selector)) return true;
      if (node === baseNode) return false;
      node = node.parentNode;
    } while (node);
    return false;
  }
  function addEvent(el, event, handler, inputOptions) {
    if (!el) return;
    const options = {
      capture: true,
      ...inputOptions
    };
    if (el.addEventListener) {
      el.addEventListener(event, handler, options);
    } else if (el.attachEvent) {
      el.attachEvent("on" + event, handler);
    } else {
      el["on" + event] = handler;
    }
  }
  function removeEvent(el, event, handler, inputOptions) {
    if (!el) return;
    const options = {
      capture: true,
      ...inputOptions
    };
    if (el.removeEventListener) {
      el.removeEventListener(event, handler, options);
    } else if (el.detachEvent) {
      el.detachEvent("on" + event, handler);
    } else {
      el["on" + event] = null;
    }
  }
  function outerHeight(node) {
    let height = node.clientHeight;
    const computedStyle = node.ownerDocument.defaultView.getComputedStyle(node);
    height += (0, _shims.int)(computedStyle.borderTopWidth);
    height += (0, _shims.int)(computedStyle.borderBottomWidth);
    return height;
  }
  function outerWidth(node) {
    let width = node.clientWidth;
    const computedStyle = node.ownerDocument.defaultView.getComputedStyle(node);
    width += (0, _shims.int)(computedStyle.borderLeftWidth);
    width += (0, _shims.int)(computedStyle.borderRightWidth);
    return width;
  }
  function innerHeight2(node) {
    let height = node.clientHeight;
    const computedStyle = node.ownerDocument.defaultView.getComputedStyle(node);
    height -= (0, _shims.int)(computedStyle.paddingTop);
    height -= (0, _shims.int)(computedStyle.paddingBottom);
    return height;
  }
  function innerWidth2(node) {
    let width = node.clientWidth;
    const computedStyle = node.ownerDocument.defaultView.getComputedStyle(node);
    width -= (0, _shims.int)(computedStyle.paddingLeft);
    width -= (0, _shims.int)(computedStyle.paddingRight);
    return width;
  }
  function offsetXYFromParent(evt, offsetParent, scale) {
    const isBody = offsetParent === offsetParent.ownerDocument.body;
    const offsetParentRect = isBody ? {
      left: 0,
      top: 0
    } : offsetParent.getBoundingClientRect();
    const x2 = (evt.clientX + offsetParent.scrollLeft - offsetParentRect.left) / scale;
    const y2 = (evt.clientY + offsetParent.scrollTop - offsetParentRect.top) / scale;
    return {
      x: x2,
      y: y2
    };
  }
  function createCSSTransform(controlPos, positionOffset) {
    const translation = getTranslation(controlPos, positionOffset, "px");
    return {
      [(0, _getPrefix.browserPrefixToKey)("transform", _getPrefix.default)]: translation
    };
  }
  function createSVGTransform(controlPos, positionOffset) {
    const translation = getTranslation(controlPos, positionOffset, "");
    return translation;
  }
  function getTranslation(_ref, positionOffset, unitSuffix) {
    let {
      x: x2,
      y: y2
    } = _ref;
    let translation = `translate(${x2}${unitSuffix},${y2}${unitSuffix})`;
    if (positionOffset) {
      const defaultX = `${typeof positionOffset.x === "string" ? positionOffset.x : positionOffset.x + unitSuffix}`;
      const defaultY = `${typeof positionOffset.y === "string" ? positionOffset.y : positionOffset.y + unitSuffix}`;
      translation = `translate(${defaultX}, ${defaultY})` + translation;
    }
    return translation;
  }
  function getTouch(e2, identifier) {
    return e2.targetTouches && (0, _shims.findInArray)(e2.targetTouches, (t2) => identifier === t2.identifier) || e2.changedTouches && (0, _shims.findInArray)(e2.changedTouches, (t2) => identifier === t2.identifier);
  }
  function getTouchIdentifier(e2) {
    if (e2.targetTouches && e2.targetTouches[0]) return e2.targetTouches[0].identifier;
    if (e2.changedTouches && e2.changedTouches[0]) return e2.changedTouches[0].identifier;
  }
  function addUserSelectStyles(doc) {
    if (!doc) return;
    let styleEl = doc.getElementById("react-draggable-style-el");
    if (!styleEl) {
      styleEl = doc.createElement("style");
      styleEl.type = "text/css";
      styleEl.id = "react-draggable-style-el";
      styleEl.innerHTML = ".react-draggable-transparent-selection *::-moz-selection {all: inherit;}\n";
      styleEl.innerHTML += ".react-draggable-transparent-selection *::selection {all: inherit;}\n";
      doc.getElementsByTagName("head")[0].appendChild(styleEl);
    }
    if (doc.body) addClassName(doc.body, "react-draggable-transparent-selection");
  }
  function scheduleRemoveUserSelectStyles(doc) {
    if (window.requestAnimationFrame) {
      window.requestAnimationFrame(() => {
        removeUserSelectStyles(doc);
      });
    } else {
      removeUserSelectStyles(doc);
    }
  }
  function removeUserSelectStyles(doc) {
    if (!doc) return;
    try {
      if (doc.body) removeClassName(doc.body, "react-draggable-transparent-selection");
      if (doc.selection) {
        doc.selection.empty();
      } else {
        const selection = (doc.defaultView || window).getSelection();
        if (selection && selection.type !== "Caret") {
          selection.removeAllRanges();
        }
      }
    } catch (e2) {
    }
  }
  function addClassName(el, className) {
    if (el.classList) {
      el.classList.add(className);
    } else {
      if (!el.className.match(new RegExp(`(?:^|\\s)${className}(?!\\S)`))) {
        el.className += ` ${className}`;
      }
    }
  }
  function removeClassName(el, className) {
    if (el.classList) {
      el.classList.remove(className);
    } else {
      el.className = el.className.replace(new RegExp(`(?:^|\\s)${className}(?!\\S)`, "g"), "");
    }
  }
  return domFns;
}
var positionFns = {};
var hasRequiredPositionFns;
function requirePositionFns() {
  if (hasRequiredPositionFns) return positionFns;
  hasRequiredPositionFns = 1;
  Object.defineProperty(positionFns, "__esModule", {
    value: true
  });
  positionFns.canDragX = canDragX;
  positionFns.canDragY = canDragY;
  positionFns.createCoreData = createCoreData;
  positionFns.createDraggableData = createDraggableData;
  positionFns.getBoundPosition = getBoundPosition;
  positionFns.getControlPosition = getControlPosition;
  positionFns.snapToGrid = snapToGrid;
  var _shims = requireShims();
  var _domFns = requireDomFns();
  function getBoundPosition(draggable, x2, y2) {
    if (!draggable.props.bounds) return [x2, y2];
    let {
      bounds
    } = draggable.props;
    bounds = typeof bounds === "string" ? bounds : cloneBounds(bounds);
    const node = findDOMNode(draggable);
    if (typeof bounds === "string") {
      const {
        ownerDocument
      } = node;
      const ownerWindow = ownerDocument.defaultView;
      let boundNode;
      if (bounds === "parent") {
        boundNode = node.parentNode;
      } else {
        const rootNode = node.getRootNode();
        boundNode = rootNode.querySelector(bounds);
      }
      if (!(boundNode instanceof ownerWindow.HTMLElement)) {
        throw new Error('Bounds selector "' + bounds + '" could not find an element.');
      }
      const boundNodeEl = boundNode;
      const nodeStyle = ownerWindow.getComputedStyle(node);
      const boundNodeStyle = ownerWindow.getComputedStyle(boundNodeEl);
      bounds = {
        left: -node.offsetLeft + (0, _shims.int)(boundNodeStyle.paddingLeft) + (0, _shims.int)(nodeStyle.marginLeft),
        top: -node.offsetTop + (0, _shims.int)(boundNodeStyle.paddingTop) + (0, _shims.int)(nodeStyle.marginTop),
        right: (0, _domFns.innerWidth)(boundNodeEl) - (0, _domFns.outerWidth)(node) - node.offsetLeft + (0, _shims.int)(boundNodeStyle.paddingRight) - (0, _shims.int)(nodeStyle.marginRight),
        bottom: (0, _domFns.innerHeight)(boundNodeEl) - (0, _domFns.outerHeight)(node) - node.offsetTop + (0, _shims.int)(boundNodeStyle.paddingBottom) - (0, _shims.int)(nodeStyle.marginBottom)
      };
    }
    if ((0, _shims.isNum)(bounds.right)) x2 = Math.min(x2, bounds.right);
    if ((0, _shims.isNum)(bounds.bottom)) y2 = Math.min(y2, bounds.bottom);
    if ((0, _shims.isNum)(bounds.left)) x2 = Math.max(x2, bounds.left);
    if ((0, _shims.isNum)(bounds.top)) y2 = Math.max(y2, bounds.top);
    return [x2, y2];
  }
  function snapToGrid(grid, pendingX, pendingY) {
    const x2 = Math.round(pendingX / grid[0]) * grid[0];
    const y2 = Math.round(pendingY / grid[1]) * grid[1];
    return [x2, y2];
  }
  function canDragX(draggable) {
    return draggable.props.axis === "both" || draggable.props.axis === "x";
  }
  function canDragY(draggable) {
    return draggable.props.axis === "both" || draggable.props.axis === "y";
  }
  function getControlPosition(e2, touchIdentifier, draggableCore) {
    const touchObj = typeof touchIdentifier === "number" ? (0, _domFns.getTouch)(e2, touchIdentifier) : null;
    if (typeof touchIdentifier === "number" && !touchObj) return null;
    const node = findDOMNode(draggableCore);
    const offsetParent = draggableCore.props.offsetParent || node.offsetParent || node.ownerDocument.body;
    return (0, _domFns.offsetXYFromParent)(touchObj || e2, offsetParent, draggableCore.props.scale);
  }
  function createCoreData(draggable, x2, y2) {
    const isStart = !(0, _shims.isNum)(draggable.lastX);
    const node = findDOMNode(draggable);
    if (isStart) {
      return {
        node,
        deltaX: 0,
        deltaY: 0,
        lastX: x2,
        lastY: y2,
        x: x2,
        y: y2
      };
    } else {
      return {
        node,
        deltaX: x2 - draggable.lastX,
        deltaY: y2 - draggable.lastY,
        lastX: draggable.lastX,
        lastY: draggable.lastY,
        x: x2,
        y: y2
      };
    }
  }
  function createDraggableData(draggable, coreData) {
    const scale = draggable.props.scale;
    return {
      node: coreData.node,
      x: draggable.state.x + coreData.deltaX / scale,
      y: draggable.state.y + coreData.deltaY / scale,
      deltaX: coreData.deltaX / scale,
      deltaY: coreData.deltaY / scale,
      lastX: draggable.state.x,
      lastY: draggable.state.y
    };
  }
  function cloneBounds(bounds) {
    return {
      left: bounds.left,
      top: bounds.top,
      right: bounds.right,
      bottom: bounds.bottom
    };
  }
  function findDOMNode(draggable) {
    const node = draggable.findDOMNode();
    if (!node) {
      throw new Error("<DraggableCore>: Unmounted during event!");
    }
    return node;
  }
  return positionFns;
}
var DraggableCore = {};
var log = {};
var hasRequiredLog;
function requireLog() {
  if (hasRequiredLog) return log;
  hasRequiredLog = 1;
  Object.defineProperty(log, "__esModule", {
    value: true
  });
  log.default = log$1;
  function log$1() {
  }
  return log;
}
var hasRequiredDraggableCore;
function requireDraggableCore() {
  if (hasRequiredDraggableCore) return DraggableCore;
  hasRequiredDraggableCore = 1;
  Object.defineProperty(DraggableCore, "__esModule", {
    value: true
  });
  DraggableCore.default = void 0;
  var React = _interopRequireWildcard(require$$0);
  var _propTypes = _interopRequireDefault(/* @__PURE__ */ requirePropTypes$1());
  var _reactDom = _interopRequireDefault(require$$0);
  var _domFns = requireDomFns();
  var _positionFns = requirePositionFns();
  var _shims = requireShims();
  var _log = _interopRequireDefault(requireLog());
  function _interopRequireDefault(e2) {
    return e2 && e2.__esModule ? e2 : { default: e2 };
  }
  function _interopRequireWildcard(e2, t2) {
    if ("function" == typeof WeakMap) var r2 = /* @__PURE__ */ new WeakMap(), n2 = /* @__PURE__ */ new WeakMap();
    return (_interopRequireWildcard = function(e3, t3) {
      if (!t3 && e3 && e3.__esModule) return e3;
      var o2, i2, f2 = { __proto__: null, default: e3 };
      if (null === e3 || "object" != typeof e3 && "function" != typeof e3) return f2;
      if (o2 = t3 ? n2 : r2) {
        if (o2.has(e3)) return o2.get(e3);
        o2.set(e3, f2);
      }
      for (const t4 in e3) "default" !== t4 && {}.hasOwnProperty.call(e3, t4) && ((i2 = (o2 = Object.defineProperty) && Object.getOwnPropertyDescriptor(e3, t4)) && (i2.get || i2.set) ? o2(f2, t4, i2) : f2[t4] = e3[t4]);
      return f2;
    })(e2, t2);
  }
  function _defineProperty(e2, r2, t2) {
    return (r2 = _toPropertyKey(r2)) in e2 ? Object.defineProperty(e2, r2, { value: t2, enumerable: true, configurable: true, writable: true }) : e2[r2] = t2, e2;
  }
  function _toPropertyKey(t2) {
    var i2 = _toPrimitive(t2, "string");
    return "symbol" == typeof i2 ? i2 : i2 + "";
  }
  function _toPrimitive(t2, r2) {
    if ("object" != typeof t2 || !t2) return t2;
    var e2 = t2[Symbol.toPrimitive];
    if (void 0 !== e2) {
      var i2 = e2.call(t2, r2);
      if ("object" != typeof i2) return i2;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ("string" === r2 ? String : Number)(t2);
  }
  const eventsFor = {
    touch: {
      start: "touchstart",
      move: "touchmove",
      stop: "touchend"
    },
    mouse: {
      start: "mousedown",
      move: "mousemove",
      stop: "mouseup"
    }
  };
  let dragEventFor = eventsFor.mouse;
  let DraggableCore$1 = class DraggableCore extends React.Component {
    constructor() {
      super(...arguments);
      _defineProperty(this, "dragging", false);
      _defineProperty(this, "lastX", NaN);
      _defineProperty(this, "lastY", NaN);
      _defineProperty(this, "touchIdentifier", null);
      _defineProperty(this, "mounted", false);
      _defineProperty(this, "handleDragStart", (e2) => {
        this.props.onMouseDown(e2);
        if (!this.props.allowAnyClick && typeof e2.button === "number" && e2.button !== 0) return false;
        const thisNode = this.findDOMNode();
        if (!thisNode || !thisNode.ownerDocument || !thisNode.ownerDocument.body) {
          throw new Error("<DraggableCore> not mounted on DragStart!");
        }
        const {
          ownerDocument
        } = thisNode;
        if (this.props.disabled || !(e2.target instanceof ownerDocument.defaultView.Node) || this.props.handle && !(0, _domFns.matchesSelectorAndParentsTo)(e2.target, this.props.handle, thisNode) || this.props.cancel && (0, _domFns.matchesSelectorAndParentsTo)(e2.target, this.props.cancel, thisNode)) {
          return;
        }
        if (e2.type === "touchstart" && !this.props.allowMobileScroll) e2.preventDefault();
        const touchIdentifier = (0, _domFns.getTouchIdentifier)(e2);
        this.touchIdentifier = touchIdentifier;
        const position = (0, _positionFns.getControlPosition)(e2, touchIdentifier, this);
        if (position == null) return;
        const {
          x: x2,
          y: y2
        } = position;
        const coreEvent = (0, _positionFns.createCoreData)(this, x2, y2);
        (0, _log.default)("DraggableCore: handleDragStart: %j", coreEvent);
        (0, _log.default)("calling", this.props.onStart);
        const shouldUpdate = this.props.onStart(e2, coreEvent);
        if (shouldUpdate === false || this.mounted === false) return;
        if (this.props.enableUserSelectHack) (0, _domFns.addUserSelectStyles)(ownerDocument);
        this.dragging = true;
        this.lastX = x2;
        this.lastY = y2;
        (0, _domFns.addEvent)(ownerDocument, dragEventFor.move, this.handleDrag);
        (0, _domFns.addEvent)(ownerDocument, dragEventFor.stop, this.handleDragStop);
      });
      _defineProperty(this, "handleDrag", (e2) => {
        const position = (0, _positionFns.getControlPosition)(e2, this.touchIdentifier, this);
        if (position == null) return;
        let {
          x: x2,
          y: y2
        } = position;
        if (Array.isArray(this.props.grid)) {
          let deltaX = x2 - this.lastX, deltaY = y2 - this.lastY;
          [deltaX, deltaY] = (0, _positionFns.snapToGrid)(this.props.grid, deltaX, deltaY);
          if (!deltaX && !deltaY) return;
          x2 = this.lastX + deltaX, y2 = this.lastY + deltaY;
        }
        const coreEvent = (0, _positionFns.createCoreData)(this, x2, y2);
        (0, _log.default)("DraggableCore: handleDrag: %j", coreEvent);
        const shouldUpdate = this.props.onDrag(e2, coreEvent);
        if (shouldUpdate === false || this.mounted === false) {
          try {
            this.handleDragStop(new MouseEvent("mouseup"));
          } catch (err) {
            const event = document.createEvent("MouseEvents");
            event.initMouseEvent("mouseup", true, true, window, 0, 0, 0, 0, 0, false, false, false, false, 0, null);
            this.handleDragStop(event);
          }
          return;
        }
        this.lastX = x2;
        this.lastY = y2;
      });
      _defineProperty(this, "handleDragStop", (e2) => {
        if (!this.dragging) return;
        const position = (0, _positionFns.getControlPosition)(e2, this.touchIdentifier, this);
        if (position == null) return;
        let {
          x: x2,
          y: y2
        } = position;
        if (Array.isArray(this.props.grid)) {
          let deltaX = x2 - this.lastX || 0;
          let deltaY = y2 - this.lastY || 0;
          [deltaX, deltaY] = (0, _positionFns.snapToGrid)(this.props.grid, deltaX, deltaY);
          x2 = this.lastX + deltaX, y2 = this.lastY + deltaY;
        }
        const coreEvent = (0, _positionFns.createCoreData)(this, x2, y2);
        const shouldContinue = this.props.onStop(e2, coreEvent);
        if (shouldContinue === false || this.mounted === false) return false;
        const thisNode = this.findDOMNode();
        if (thisNode) {
          if (this.props.enableUserSelectHack) (0, _domFns.scheduleRemoveUserSelectStyles)(thisNode.ownerDocument);
        }
        (0, _log.default)("DraggableCore: handleDragStop: %j", coreEvent);
        this.dragging = false;
        this.lastX = NaN;
        this.lastY = NaN;
        if (thisNode) {
          (0, _log.default)("DraggableCore: Removing handlers");
          (0, _domFns.removeEvent)(thisNode.ownerDocument, dragEventFor.move, this.handleDrag);
          (0, _domFns.removeEvent)(thisNode.ownerDocument, dragEventFor.stop, this.handleDragStop);
        }
      });
      _defineProperty(this, "onMouseDown", (e2) => {
        dragEventFor = eventsFor.mouse;
        return this.handleDragStart(e2);
      });
      _defineProperty(this, "onMouseUp", (e2) => {
        dragEventFor = eventsFor.mouse;
        return this.handleDragStop(e2);
      });
      _defineProperty(this, "onTouchStart", (e2) => {
        dragEventFor = eventsFor.touch;
        return this.handleDragStart(e2);
      });
      _defineProperty(this, "onTouchEnd", (e2) => {
        dragEventFor = eventsFor.touch;
        return this.handleDragStop(e2);
      });
    }
    componentDidMount() {
      this.mounted = true;
      const thisNode = this.findDOMNode();
      if (thisNode) {
        (0, _domFns.addEvent)(thisNode, eventsFor.touch.start, this.onTouchStart, {
          passive: false
        });
      }
    }
    componentWillUnmount() {
      this.mounted = false;
      const thisNode = this.findDOMNode();
      if (thisNode) {
        const {
          ownerDocument
        } = thisNode;
        (0, _domFns.removeEvent)(ownerDocument, eventsFor.mouse.move, this.handleDrag);
        (0, _domFns.removeEvent)(ownerDocument, eventsFor.touch.move, this.handleDrag);
        (0, _domFns.removeEvent)(ownerDocument, eventsFor.mouse.stop, this.handleDragStop);
        (0, _domFns.removeEvent)(ownerDocument, eventsFor.touch.stop, this.handleDragStop);
        (0, _domFns.removeEvent)(thisNode, eventsFor.touch.start, this.onTouchStart, {
          passive: false
        });
        if (this.props.enableUserSelectHack) (0, _domFns.scheduleRemoveUserSelectStyles)(ownerDocument);
      }
    }
    // React Strict Mode compatibility: if `nodeRef` is passed, we will use it instead of trying to find
    // the underlying DOM node ourselves. See the README for more information.
    findDOMNode() {
      return this.props?.nodeRef ? this.props?.nodeRef?.current : _reactDom.default.findDOMNode(this);
    }
    render() {
      return /* @__PURE__ */ React.cloneElement(React.Children.only(this.props.children), {
        // Note: mouseMove handler is attached to document so it will still function
        // when the user drags quickly and leaves the bounds of the element.
        onMouseDown: this.onMouseDown,
        onMouseUp: this.onMouseUp,
        // onTouchStart is added on `componentDidMount` so they can be added with
        // {passive: false}, which allows it to cancel. See
        // https://developers.google.com/web/updates/2017/01/scrolling-intervention
        onTouchEnd: this.onTouchEnd
      });
    }
  };
  DraggableCore.default = DraggableCore$1;
  _defineProperty(DraggableCore$1, "displayName", "DraggableCore");
  _defineProperty(DraggableCore$1, "propTypes", {
    /**
     * `allowAnyClick` allows dragging using any mouse button.
     * By default, we only accept the left button.
     *
     * Defaults to `false`.
     */
    allowAnyClick: _propTypes.default.bool,
    /**
     * `allowMobileScroll` turns off cancellation of the 'touchstart' event
     * on mobile devices. Only enable this if you are having trouble with click
     * events. Prefer using 'handle' / 'cancel' instead.
     *
     * Defaults to `false`.
     */
    allowMobileScroll: _propTypes.default.bool,
    children: _propTypes.default.node.isRequired,
    /**
     * `disabled`, if true, stops the <Draggable> from dragging. All handlers,
     * with the exception of `onMouseDown`, will not fire.
     */
    disabled: _propTypes.default.bool,
    /**
     * By default, we add 'user-select:none' attributes to the document body
     * to prevent ugly text selection during drag. If this is causing problems
     * for your app, set this to `false`.
     */
    enableUserSelectHack: _propTypes.default.bool,
    /**
     * `offsetParent`, if set, uses the passed DOM node to compute drag offsets
     * instead of using the parent node.
     */
    offsetParent: function(props, propName) {
      if (props[propName] && props[propName].nodeType !== 1) {
        throw new Error("Draggable's offsetParent must be a DOM Node.");
      }
    },
    /**
     * `grid` specifies the x and y that dragging should snap to.
     */
    grid: _propTypes.default.arrayOf(_propTypes.default.number),
    /**
     * `handle` specifies a selector to be used as the handle that initiates drag.
     *
     * Example:
     *
     * ```jsx
     *   let App = React.createClass({
     *       render: function () {
     *         return (
     *            <Draggable handle=".handle">
     *              <div>
     *                  <div className="handle">Click me to drag</div>
     *                  <div>This is some other content</div>
     *              </div>
     *           </Draggable>
     *         );
     *       }
     *   });
     * ```
     */
    handle: _propTypes.default.string,
    /**
     * `cancel` specifies a selector to be used to prevent drag initialization.
     *
     * Example:
     *
     * ```jsx
     *   let App = React.createClass({
     *       render: function () {
     *           return(
     *               <Draggable cancel=".cancel">
     *                   <div>
     *                     <div className="cancel">You can't drag from here</div>
     *                     <div>Dragging here works fine</div>
     *                   </div>
     *               </Draggable>
     *           );
     *       }
     *   });
     * ```
     */
    cancel: _propTypes.default.string,
    /* If running in React Strict mode, ReactDOM.findDOMNode() is deprecated.
     * Unfortunately, in order for <Draggable> to work properly, we need raw access
     * to the underlying DOM node. If you want to avoid the warning, pass a `nodeRef`
     * as in this example:
     *
     * function MyComponent() {
     *   const nodeRef = React.useRef(null);
     *   return (
     *     <Draggable nodeRef={nodeRef}>
     *       <div ref={nodeRef}>Example Target</div>
     *     </Draggable>
     *   );
     * }
     *
     * This can be used for arbitrarily nested components, so long as the ref ends up
     * pointing to the actual child DOM node and not a custom component.
     */
    nodeRef: _propTypes.default.object,
    /**
     * Called when dragging starts.
     * If this function returns the boolean false, dragging will be canceled.
     */
    onStart: _propTypes.default.func,
    /**
     * Called while dragging.
     * If this function returns the boolean false, dragging will be canceled.
     */
    onDrag: _propTypes.default.func,
    /**
     * Called when dragging stops.
     * If this function returns the boolean false, the drag will remain active.
     */
    onStop: _propTypes.default.func,
    /**
     * A workaround option which can be passed if onMouseDown needs to be accessed,
     * since it'll always be blocked (as there is internal use of onMouseDown)
     */
    onMouseDown: _propTypes.default.func,
    /**
     * `scale`, if set, applies scaling while dragging an element
     */
    scale: _propTypes.default.number,
    /**
     * These properties should be defined on the child, not here.
     */
    className: _shims.dontSetMe,
    style: _shims.dontSetMe,
    transform: _shims.dontSetMe
  });
  _defineProperty(DraggableCore$1, "defaultProps", {
    allowAnyClick: false,
    // by default only accept left click
    allowMobileScroll: false,
    disabled: false,
    enableUserSelectHack: true,
    onStart: function() {
    },
    onDrag: function() {
    },
    onStop: function() {
    },
    onMouseDown: function() {
    },
    scale: 1
  });
  return DraggableCore;
}
var hasRequiredDraggable;
function requireDraggable() {
  if (hasRequiredDraggable) return Draggable;
  hasRequiredDraggable = 1;
  (function(exports$1) {
    Object.defineProperty(exports$1, "__esModule", {
      value: true
    });
    Object.defineProperty(exports$1, "DraggableCore", {
      enumerable: true,
      get: function() {
        return _DraggableCore.default;
      }
    });
    exports$1.default = void 0;
    var React = _interopRequireWildcard(require$$0);
    var _propTypes = _interopRequireDefault(/* @__PURE__ */ requirePropTypes$1());
    var _reactDom = _interopRequireDefault(require$$0);
    var _clsx = requireClsx();
    var _domFns = requireDomFns();
    var _positionFns = requirePositionFns();
    var _shims = requireShims();
    var _DraggableCore = _interopRequireDefault(requireDraggableCore());
    var _log = _interopRequireDefault(requireLog());
    function _interopRequireDefault(e2) {
      return e2 && e2.__esModule ? e2 : { default: e2 };
    }
    function _interopRequireWildcard(e2, t2) {
      if ("function" == typeof WeakMap) var r2 = /* @__PURE__ */ new WeakMap(), n2 = /* @__PURE__ */ new WeakMap();
      return (_interopRequireWildcard = function(e3, t3) {
        if (!t3 && e3 && e3.__esModule) return e3;
        var o2, i2, f2 = { __proto__: null, default: e3 };
        if (null === e3 || "object" != typeof e3 && "function" != typeof e3) return f2;
        if (o2 = t3 ? n2 : r2) {
          if (o2.has(e3)) return o2.get(e3);
          o2.set(e3, f2);
        }
        for (const t4 in e3) "default" !== t4 && {}.hasOwnProperty.call(e3, t4) && ((i2 = (o2 = Object.defineProperty) && Object.getOwnPropertyDescriptor(e3, t4)) && (i2.get || i2.set) ? o2(f2, t4, i2) : f2[t4] = e3[t4]);
        return f2;
      })(e2, t2);
    }
    function _extends2() {
      return _extends2 = Object.assign ? Object.assign.bind() : function(n2) {
        for (var e2 = 1; e2 < arguments.length; e2++) {
          var t2 = arguments[e2];
          for (var r2 in t2) ({}).hasOwnProperty.call(t2, r2) && (n2[r2] = t2[r2]);
        }
        return n2;
      }, _extends2.apply(null, arguments);
    }
    function _defineProperty(e2, r2, t2) {
      return (r2 = _toPropertyKey(r2)) in e2 ? Object.defineProperty(e2, r2, { value: t2, enumerable: true, configurable: true, writable: true }) : e2[r2] = t2, e2;
    }
    function _toPropertyKey(t2) {
      var i2 = _toPrimitive(t2, "string");
      return "symbol" == typeof i2 ? i2 : i2 + "";
    }
    function _toPrimitive(t2, r2) {
      if ("object" != typeof t2 || !t2) return t2;
      var e2 = t2[Symbol.toPrimitive];
      if (void 0 !== e2) {
        var i2 = e2.call(t2, r2);
        if ("object" != typeof i2) return i2;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return ("string" === r2 ? String : Number)(t2);
    }
    class Draggable2 extends React.Component {
      // React 16.3+
      // Arity (props, state)
      static getDerivedStateFromProps(_ref, _ref2) {
        let {
          position
        } = _ref;
        let {
          prevPropsPosition
        } = _ref2;
        if (position && (!prevPropsPosition || position.x !== prevPropsPosition.x || position.y !== prevPropsPosition.y)) {
          (0, _log.default)("Draggable: getDerivedStateFromProps %j", {
            position,
            prevPropsPosition
          });
          return {
            x: position.x,
            y: position.y,
            prevPropsPosition: {
              ...position
            }
          };
        }
        return null;
      }
      constructor(props) {
        super(props);
        _defineProperty(this, "onDragStart", (e2, coreData) => {
          (0, _log.default)("Draggable: onDragStart: %j", coreData);
          const shouldStart = this.props.onStart(e2, (0, _positionFns.createDraggableData)(this, coreData));
          if (shouldStart === false) return false;
          this.setState({
            dragging: true,
            dragged: true
          });
        });
        _defineProperty(this, "onDrag", (e2, coreData) => {
          if (!this.state.dragging) return false;
          (0, _log.default)("Draggable: onDrag: %j", coreData);
          const uiData = (0, _positionFns.createDraggableData)(this, coreData);
          const newState = {
            x: uiData.x,
            y: uiData.y,
            slackX: 0,
            slackY: 0
          };
          if (this.props.bounds) {
            const {
              x: x2,
              y: y2
            } = newState;
            newState.x += this.state.slackX;
            newState.y += this.state.slackY;
            const [newStateX, newStateY] = (0, _positionFns.getBoundPosition)(this, newState.x, newState.y);
            newState.x = newStateX;
            newState.y = newStateY;
            newState.slackX = this.state.slackX + (x2 - newState.x);
            newState.slackY = this.state.slackY + (y2 - newState.y);
            uiData.x = newState.x;
            uiData.y = newState.y;
            uiData.deltaX = newState.x - this.state.x;
            uiData.deltaY = newState.y - this.state.y;
          }
          const shouldUpdate = this.props.onDrag(e2, uiData);
          if (shouldUpdate === false) return false;
          this.setState(newState);
        });
        _defineProperty(this, "onDragStop", (e2, coreData) => {
          if (!this.state.dragging) return false;
          const shouldContinue = this.props.onStop(e2, (0, _positionFns.createDraggableData)(this, coreData));
          if (shouldContinue === false) return false;
          (0, _log.default)("Draggable: onDragStop: %j", coreData);
          const newState = {
            dragging: false,
            slackX: 0,
            slackY: 0
          };
          const controlled = Boolean(this.props.position);
          if (controlled) {
            const {
              x: x2,
              y: y2
            } = this.props.position;
            newState.x = x2;
            newState.y = y2;
          }
          this.setState(newState);
        });
        this.state = {
          // Whether or not we are currently dragging.
          dragging: false,
          // Whether or not we have been dragged before.
          dragged: false,
          // Current transform x and y.
          x: props.position ? props.position.x : props.defaultPosition.x,
          y: props.position ? props.position.y : props.defaultPosition.y,
          prevPropsPosition: {
            ...props.position
          },
          // Used for compensating for out-of-bounds drags
          slackX: 0,
          slackY: 0,
          // Can only determine if SVG after mounting
          isElementSVG: false
        };
        if (props.position && !(props.onDrag || props.onStop)) {
          console.warn("A `position` was applied to this <Draggable>, without drag handlers. This will make this component effectively undraggable. Please attach `onDrag` or `onStop` handlers so you can adjust the `position` of this element.");
        }
      }
      componentDidMount() {
        if (typeof window.SVGElement !== "undefined" && this.findDOMNode() instanceof window.SVGElement) {
          this.setState({
            isElementSVG: true
          });
        }
      }
      componentWillUnmount() {
        if (this.state.dragging) {
          this.setState({
            dragging: false
          });
        }
      }
      // React Strict Mode compatibility: if `nodeRef` is passed, we will use it instead of trying to find
      // the underlying DOM node ourselves. See the README for more information.
      findDOMNode() {
        return this.props?.nodeRef?.current ?? _reactDom.default.findDOMNode(this);
      }
      render() {
        const {
          axis,
          bounds,
          children,
          defaultPosition,
          defaultClassName,
          defaultClassNameDragging,
          defaultClassNameDragged,
          position,
          positionOffset,
          scale,
          ...draggableCoreProps
        } = this.props;
        let style = {};
        let svgTransform = null;
        const controlled = Boolean(position);
        const draggable = !controlled || this.state.dragging;
        const validPosition = position || defaultPosition;
        const transformOpts = {
          // Set left if horizontal drag is enabled
          x: (0, _positionFns.canDragX)(this) && draggable ? this.state.x : validPosition.x,
          // Set top if vertical drag is enabled
          y: (0, _positionFns.canDragY)(this) && draggable ? this.state.y : validPosition.y
        };
        if (this.state.isElementSVG) {
          svgTransform = (0, _domFns.createSVGTransform)(transformOpts, positionOffset);
        } else {
          style = (0, _domFns.createCSSTransform)(transformOpts, positionOffset);
        }
        const className = (0, _clsx.clsx)(children.props.className || "", defaultClassName, {
          [defaultClassNameDragging]: this.state.dragging,
          [defaultClassNameDragged]: this.state.dragged
        });
        return /* @__PURE__ */ React.createElement(_DraggableCore.default, _extends2({}, draggableCoreProps, {
          onStart: this.onDragStart,
          onDrag: this.onDrag,
          onStop: this.onDragStop
        }), /* @__PURE__ */ React.cloneElement(React.Children.only(children), {
          className,
          style: {
            ...children.props.style,
            ...style
          },
          transform: svgTransform
        }));
      }
    }
    exports$1.default = Draggable2;
    _defineProperty(Draggable2, "displayName", "Draggable");
    _defineProperty(Draggable2, "propTypes", {
      // Accepts all props <DraggableCore> accepts.
      ..._DraggableCore.default.propTypes,
      /**
       * `axis` determines which axis the draggable can move.
       *
       *  Note that all callbacks will still return data as normal. This only
       *  controls flushing to the DOM.
       *
       * 'both' allows movement horizontally and vertically.
       * 'x' limits movement to horizontal axis.
       * 'y' limits movement to vertical axis.
       * 'none' limits all movement.
       *
       * Defaults to 'both'.
       */
      axis: _propTypes.default.oneOf(["both", "x", "y", "none"]),
      /**
       * `bounds` determines the range of movement available to the element.
       * Available values are:
       *
       * 'parent' restricts movement within the Draggable's parent node.
       *
       * Alternatively, pass an object with the following properties, all of which are optional:
       *
       * {left: LEFT_BOUND, right: RIGHT_BOUND, bottom: BOTTOM_BOUND, top: TOP_BOUND}
       *
       * All values are in px.
       *
       * Example:
       *
       * ```jsx
       *   let App = React.createClass({
       *       render: function () {
       *         return (
       *            <Draggable bounds={{right: 300, bottom: 300}}>
       *              <div>Content</div>
       *           </Draggable>
       *         );
       *       }
       *   });
       * ```
       */
      bounds: _propTypes.default.oneOfType([_propTypes.default.shape({
        left: _propTypes.default.number,
        right: _propTypes.default.number,
        top: _propTypes.default.number,
        bottom: _propTypes.default.number
      }), _propTypes.default.string, _propTypes.default.oneOf([false])]),
      defaultClassName: _propTypes.default.string,
      defaultClassNameDragging: _propTypes.default.string,
      defaultClassNameDragged: _propTypes.default.string,
      /**
       * `defaultPosition` specifies the x and y that the dragged item should start at
       *
       * Example:
       *
       * ```jsx
       *      let App = React.createClass({
       *          render: function () {
       *              return (
       *                  <Draggable defaultPosition={{x: 25, y: 25}}>
       *                      <div>I start with transformX: 25px and transformY: 25px;</div>
       *                  </Draggable>
       *              );
       *          }
       *      });
       * ```
       */
      defaultPosition: _propTypes.default.shape({
        x: _propTypes.default.number,
        y: _propTypes.default.number
      }),
      positionOffset: _propTypes.default.shape({
        x: _propTypes.default.oneOfType([_propTypes.default.number, _propTypes.default.string]),
        y: _propTypes.default.oneOfType([_propTypes.default.number, _propTypes.default.string])
      }),
      /**
       * `position`, if present, defines the current position of the element.
       *
       *  This is similar to how form elements in React work - if no `position` is supplied, the component
       *  is uncontrolled.
       *
       * Example:
       *
       * ```jsx
       *      let App = React.createClass({
       *          render: function () {
       *              return (
       *                  <Draggable position={{x: 25, y: 25}}>
       *                      <div>I start with transformX: 25px and transformY: 25px;</div>
       *                  </Draggable>
       *              );
       *          }
       *      });
       * ```
       */
      position: _propTypes.default.shape({
        x: _propTypes.default.number,
        y: _propTypes.default.number
      }),
      /**
       * These properties should be defined on the child, not here.
       */
      className: _shims.dontSetMe,
      style: _shims.dontSetMe,
      transform: _shims.dontSetMe
    });
    _defineProperty(Draggable2, "defaultProps", {
      ..._DraggableCore.default.defaultProps,
      axis: "both",
      bounds: false,
      defaultClassName: "react-draggable",
      defaultClassNameDragging: "react-draggable-dragging",
      defaultClassNameDragged: "react-draggable-dragged",
      defaultPosition: {
        x: 0,
        y: 0
      },
      scale: 1
    });
  })(Draggable);
  return Draggable;
}
var hasRequiredCjs;
function requireCjs() {
  if (hasRequiredCjs) return cjs.exports;
  hasRequiredCjs = 1;
  const {
    default: Draggable2,
    DraggableCore: DraggableCore2
  } = requireDraggable();
  cjs.exports = Draggable2;
  cjs.exports.default = Draggable2;
  cjs.exports.DraggableCore = DraggableCore2;
  return cjs.exports;
}
var utils = {};
var hasRequiredUtils;
function requireUtils() {
  if (hasRequiredUtils) return utils;
  hasRequiredUtils = 1;
  utils.__esModule = true;
  utils.cloneElement = cloneElement;
  var _react = _interopRequireDefault(require$$0);
  function _interopRequireDefault(e2) {
    return e2 && e2.__esModule ? e2 : { default: e2 };
  }
  function ownKeys(e2, r2) {
    var t2 = Object.keys(e2);
    if (Object.getOwnPropertySymbols) {
      var o2 = Object.getOwnPropertySymbols(e2);
      r2 && (o2 = o2.filter(function(r3) {
        return Object.getOwnPropertyDescriptor(e2, r3).enumerable;
      })), t2.push.apply(t2, o2);
    }
    return t2;
  }
  function _objectSpread(e2) {
    for (var r2 = 1; r2 < arguments.length; r2++) {
      var t2 = null != arguments[r2] ? arguments[r2] : {};
      r2 % 2 ? ownKeys(Object(t2), true).forEach(function(r3) {
        _defineProperty(e2, r3, t2[r3]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(t2)) : ownKeys(Object(t2)).forEach(function(r3) {
        Object.defineProperty(e2, r3, Object.getOwnPropertyDescriptor(t2, r3));
      });
    }
    return e2;
  }
  function _defineProperty(e2, r2, t2) {
    return (r2 = _toPropertyKey(r2)) in e2 ? Object.defineProperty(e2, r2, { value: t2, enumerable: true, configurable: true, writable: true }) : e2[r2] = t2, e2;
  }
  function _toPropertyKey(t2) {
    var i2 = _toPrimitive(t2, "string");
    return "symbol" == typeof i2 ? i2 : i2 + "";
  }
  function _toPrimitive(t2, r2) {
    if ("object" != typeof t2 || !t2) return t2;
    var e2 = t2[Symbol.toPrimitive];
    if (void 0 !== e2) {
      var i2 = e2.call(t2, r2);
      if ("object" != typeof i2) return i2;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ("string" === r2 ? String : Number)(t2);
  }
  function cloneElement(element, props) {
    if (props.style && element.props.style) {
      props.style = _objectSpread(_objectSpread({}, element.props.style), props.style);
    }
    if (props.className && element.props.className) {
      props.className = `${element.props.className} ${props.className}`;
    }
    return /* @__PURE__ */ _react.default.cloneElement(element, props);
  }
  return utils;
}
var propTypes = {};
var hasRequiredPropTypes;
function requirePropTypes() {
  if (hasRequiredPropTypes) return propTypes;
  hasRequiredPropTypes = 1;
  propTypes.__esModule = true;
  propTypes.resizableProps = void 0;
  var _propTypes = _interopRequireDefault(/* @__PURE__ */ requirePropTypes$1());
  requireCjs();
  function _interopRequireDefault(e2) {
    return e2 && e2.__esModule ? e2 : { default: e2 };
  }
  propTypes.resizableProps = {
    /*
    * Restricts resizing to a particular axis (default: 'both')
    * 'both' - allows resizing by width or height
    * 'x' - only allows the width to be changed
    * 'y' - only allows the height to be changed
    * 'none' - disables resizing altogether
    * */
    axis: _propTypes.default.oneOf(["both", "x", "y", "none"]),
    className: _propTypes.default.string,
    /*
    * Require that one and only one child be present.
    * */
    children: _propTypes.default.element.isRequired,
    /*
    * These will be passed wholesale to react-draggable's DraggableCore
    * */
    draggableOpts: _propTypes.default.shape({
      allowAnyClick: _propTypes.default.bool,
      cancel: _propTypes.default.string,
      children: _propTypes.default.node,
      disabled: _propTypes.default.bool,
      enableUserSelectHack: _propTypes.default.bool,
      // #251: Check for Element to support SSR environments where DOM globals don't exist
      offsetParent: typeof Element !== "undefined" ? _propTypes.default.instanceOf(Element) : _propTypes.default.any,
      grid: _propTypes.default.arrayOf(_propTypes.default.number),
      handle: _propTypes.default.string,
      nodeRef: _propTypes.default.object,
      onStart: _propTypes.default.func,
      onDrag: _propTypes.default.func,
      onStop: _propTypes.default.func,
      onMouseDown: _propTypes.default.func,
      scale: _propTypes.default.number
    }),
    /*
    * Initial height
    * */
    height: function() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      const [props] = args;
      if (props.axis === "both" || props.axis === "y") {
        return _propTypes.default.number.isRequired(...args);
      }
      return _propTypes.default.number(...args);
    },
    /*
    * Customize cursor resize handle
    * */
    handle: _propTypes.default.oneOfType([_propTypes.default.node, _propTypes.default.func]),
    /*
    * If you change this, be sure to update your css
    * */
    handleSize: _propTypes.default.arrayOf(_propTypes.default.number),
    lockAspectRatio: _propTypes.default.bool,
    /*
    * Max X & Y measure
    * */
    maxConstraints: _propTypes.default.arrayOf(_propTypes.default.number),
    /*
    * Min X & Y measure
    * */
    minConstraints: _propTypes.default.arrayOf(_propTypes.default.number),
    /*
    * Called on stop resize event
    * */
    onResizeStop: _propTypes.default.func,
    /*
    * Called on start resize event
    * */
    onResizeStart: _propTypes.default.func,
    /*
    * Called on resize event
    * */
    onResize: _propTypes.default.func,
    /*
    * Defines which resize handles should be rendered (default: 'se')
    * 's' - South handle (bottom-center)
    * 'w' - West handle (left-center)
    * 'e' - East handle (right-center)
    * 'n' - North handle (top-center)
    * 'sw' - Southwest handle (bottom-left)
    * 'nw' - Northwest handle (top-left)
    * 'se' - Southeast handle (bottom-right)
    * 'ne' - Northeast handle (top-center)
    * */
    resizeHandles: _propTypes.default.arrayOf(_propTypes.default.oneOf(["s", "w", "e", "n", "sw", "nw", "se", "ne"])),
    /*
    * If `transform: scale(n)` is set on the parent, this should be set to `n`.
    * */
    transformScale: _propTypes.default.number,
    /*
     * Initial width
     */
    width: function() {
      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }
      const [props] = args;
      if (props.axis === "both" || props.axis === "x") {
        return _propTypes.default.number.isRequired(...args);
      }
      return _propTypes.default.number(...args);
    }
  };
  return propTypes;
}
var hasRequiredResizable;
function requireResizable() {
  if (hasRequiredResizable) return Resizable;
  hasRequiredResizable = 1;
  Resizable.__esModule = true;
  Resizable.default = void 0;
  var React = _interopRequireWildcard(require$$0);
  var _reactDraggable = requireCjs();
  var _utils = requireUtils();
  var _propTypes = requirePropTypes();
  const _excluded = ["children", "className", "draggableOpts", "width", "height", "handle", "handleSize", "lockAspectRatio", "axis", "minConstraints", "maxConstraints", "onResize", "onResizeStop", "onResizeStart", "resizeHandles", "transformScale"];
  function _interopRequireWildcard(e2, t2) {
    if ("function" == typeof WeakMap) var r2 = /* @__PURE__ */ new WeakMap(), n2 = /* @__PURE__ */ new WeakMap();
    return (_interopRequireWildcard = function(e3, t3) {
      if (!t3 && e3 && e3.__esModule) return e3;
      var o2, i2, f2 = { __proto__: null, default: e3 };
      if (null === e3 || "object" != typeof e3 && "function" != typeof e3) return f2;
      if (o2 = t3 ? n2 : r2) {
        if (o2.has(e3)) return o2.get(e3);
        o2.set(e3, f2);
      }
      for (const t4 in e3) "default" !== t4 && {}.hasOwnProperty.call(e3, t4) && ((i2 = (o2 = Object.defineProperty) && Object.getOwnPropertyDescriptor(e3, t4)) && (i2.get || i2.set) ? o2(f2, t4, i2) : f2[t4] = e3[t4]);
      return f2;
    })(e2, t2);
  }
  function _extends2() {
    return _extends2 = Object.assign ? Object.assign.bind() : function(n2) {
      for (var e2 = 1; e2 < arguments.length; e2++) {
        var t2 = arguments[e2];
        for (var r2 in t2) ({}).hasOwnProperty.call(t2, r2) && (n2[r2] = t2[r2]);
      }
      return n2;
    }, _extends2.apply(null, arguments);
  }
  function _objectWithoutProperties(e2, t2) {
    if (null == e2) return {};
    var o2, r2, i2 = _objectWithoutPropertiesLoose2(e2, t2);
    if (Object.getOwnPropertySymbols) {
      var n2 = Object.getOwnPropertySymbols(e2);
      for (r2 = 0; r2 < n2.length; r2++) o2 = n2[r2], -1 === t2.indexOf(o2) && {}.propertyIsEnumerable.call(e2, o2) && (i2[o2] = e2[o2]);
    }
    return i2;
  }
  function _objectWithoutPropertiesLoose2(r2, e2) {
    if (null == r2) return {};
    var t2 = {};
    for (var n2 in r2) if ({}.hasOwnProperty.call(r2, n2)) {
      if (-1 !== e2.indexOf(n2)) continue;
      t2[n2] = r2[n2];
    }
    return t2;
  }
  function ownKeys(e2, r2) {
    var t2 = Object.keys(e2);
    if (Object.getOwnPropertySymbols) {
      var o2 = Object.getOwnPropertySymbols(e2);
      r2 && (o2 = o2.filter(function(r3) {
        return Object.getOwnPropertyDescriptor(e2, r3).enumerable;
      })), t2.push.apply(t2, o2);
    }
    return t2;
  }
  function _objectSpread(e2) {
    for (var r2 = 1; r2 < arguments.length; r2++) {
      var t2 = null != arguments[r2] ? arguments[r2] : {};
      r2 % 2 ? ownKeys(Object(t2), true).forEach(function(r3) {
        _defineProperty(e2, r3, t2[r3]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(t2)) : ownKeys(Object(t2)).forEach(function(r3) {
        Object.defineProperty(e2, r3, Object.getOwnPropertyDescriptor(t2, r3));
      });
    }
    return e2;
  }
  function _defineProperty(e2, r2, t2) {
    return (r2 = _toPropertyKey(r2)) in e2 ? Object.defineProperty(e2, r2, { value: t2, enumerable: true, configurable: true, writable: true }) : e2[r2] = t2, e2;
  }
  function _toPropertyKey(t2) {
    var i2 = _toPrimitive(t2, "string");
    return "symbol" == typeof i2 ? i2 : i2 + "";
  }
  function _toPrimitive(t2, r2) {
    if ("object" != typeof t2 || !t2) return t2;
    var e2 = t2[Symbol.toPrimitive];
    if (void 0 !== e2) {
      var i2 = e2.call(t2, r2);
      if ("object" != typeof i2) return i2;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ("string" === r2 ? String : Number)(t2);
  }
  let Resizable$1 = class Resizable extends React.Component {
    constructor() {
      super(...arguments);
      this.handleRefs = {};
      this.lastHandleRect = null;
      this.slack = null;
      this.lastSize = null;
    }
    componentWillUnmount() {
      this.resetData();
    }
    resetData() {
      this.lastHandleRect = this.slack = this.lastSize = null;
    }
    // Clamp width and height within provided constraints
    runConstraints(width, height) {
      const {
        minConstraints,
        maxConstraints,
        lockAspectRatio
      } = this.props;
      if (!minConstraints && !maxConstraints && !lockAspectRatio) return [width, height];
      if (lockAspectRatio) {
        const ratio = this.props.width / this.props.height;
        const deltaW = width - this.props.width;
        const deltaH = height - this.props.height;
        if (Math.abs(deltaW) > Math.abs(deltaH * ratio)) {
          height = width / ratio;
        } else {
          width = height * ratio;
        }
      }
      const [oldW, oldH] = [width, height];
      let [slackW, slackH] = this.slack || [0, 0];
      width += slackW;
      height += slackH;
      if (minConstraints) {
        width = Math.max(minConstraints[0], width);
        height = Math.max(minConstraints[1], height);
      }
      if (maxConstraints) {
        width = Math.min(maxConstraints[0], width);
        height = Math.min(maxConstraints[1], height);
      }
      this.slack = [slackW + (oldW - width), slackH + (oldH - height)];
      return [width, height];
    }
    /**
     * Wrapper around drag events to provide more useful data.
     *
     * @param  {String} handlerName Handler name to wrap.
     * @return {Function}           Handler function.
     */
    resizeHandler(handlerName, axis) {
      return (e2, _ref) => {
        let {
          node,
          deltaX,
          deltaY
        } = _ref;
        if (handlerName === "onResizeStart") this.resetData();
        const canDragX = (this.props.axis === "both" || this.props.axis === "x") && axis !== "n" && axis !== "s";
        const canDragY = (this.props.axis === "both" || this.props.axis === "y") && axis !== "e" && axis !== "w";
        if (!canDragX && !canDragY) return;
        const axisV = axis[0];
        const axisH = axis[axis.length - 1];
        const handleRect = node.getBoundingClientRect();
        if (this.lastHandleRect != null) {
          if (axisH === "w") {
            const deltaLeftSinceLast = handleRect.left - this.lastHandleRect.left;
            deltaX += deltaLeftSinceLast;
          }
          if (axisV === "n") {
            const deltaTopSinceLast = handleRect.top - this.lastHandleRect.top;
            deltaY += deltaTopSinceLast;
          }
        }
        this.lastHandleRect = handleRect;
        if (axisH === "w") deltaX = -deltaX;
        if (axisV === "n") deltaY = -deltaY;
        let width = this.props.width + (canDragX ? deltaX / this.props.transformScale : 0);
        let height = this.props.height + (canDragY ? deltaY / this.props.transformScale : 0);
        [width, height] = this.runConstraints(width, height);
        if (handlerName === "onResizeStop" && this.lastSize) {
          ({
            width,
            height
          } = this.lastSize);
        }
        const dimensionsChanged = width !== this.props.width || height !== this.props.height;
        if (handlerName !== "onResizeStop") {
          this.lastSize = {
            width,
            height
          };
        }
        const cb = typeof this.props[handlerName] === "function" ? this.props[handlerName] : null;
        const shouldSkipCb = handlerName === "onResize" && !dimensionsChanged;
        if (cb && !shouldSkipCb) {
          e2.persist?.();
          cb(e2, {
            node,
            size: {
              width,
              height
            },
            handle: axis
          });
        }
        if (handlerName === "onResizeStop") this.resetData();
      };
    }
    // Render a resize handle given an axis & DOM ref. Ref *must* be attached for
    // the underlying draggable library to work properly.
    renderResizeHandle(handleAxis, ref) {
      const {
        handle
      } = this.props;
      if (!handle) {
        return /* @__PURE__ */ React.createElement("span", {
          className: `react-resizable-handle react-resizable-handle-${handleAxis}`,
          ref
        });
      }
      if (typeof handle === "function") {
        return handle(handleAxis, ref);
      }
      const isDOMElement2 = typeof handle.type === "string";
      const props = _objectSpread({
        ref
      }, isDOMElement2 ? {} : {
        handleAxis
      });
      return /* @__PURE__ */ React.cloneElement(handle, props);
    }
    render() {
      const _this$props = this.props, {
        children,
        className,
        draggableOpts,
        width,
        height,
        handle,
        handleSize,
        lockAspectRatio,
        axis,
        minConstraints,
        maxConstraints,
        onResize,
        onResizeStop,
        onResizeStart,
        resizeHandles,
        transformScale
      } = _this$props, p2 = _objectWithoutProperties(_this$props, _excluded);
      return (0, _utils.cloneElement)(children, _objectSpread(_objectSpread({}, p2), {}, {
        className: `${className ? `${className} ` : ""}react-resizable`,
        children: [...React.Children.toArray(children.props.children), ...resizeHandles.map((handleAxis) => {
          const ref = this.handleRefs[handleAxis] ?? (this.handleRefs[handleAxis] = /* @__PURE__ */ React.createRef());
          return /* @__PURE__ */ React.createElement(_reactDraggable.DraggableCore, _extends2({}, draggableOpts, {
            nodeRef: ref,
            key: `resizableHandle-${handleAxis}`,
            onStop: this.resizeHandler("onResizeStop", handleAxis),
            onStart: this.resizeHandler("onResizeStart", handleAxis),
            onDrag: this.resizeHandler("onResize", handleAxis)
          }), this.renderResizeHandle(handleAxis, ref));
        })]
      }));
    }
  };
  Resizable.default = Resizable$1;
  Resizable$1.propTypes = _propTypes.resizableProps;
  Resizable$1.defaultProps = {
    axis: "both",
    handleSize: [20, 20],
    lockAspectRatio: false,
    minConstraints: [20, 20],
    maxConstraints: [Infinity, Infinity],
    resizeHandles: ["se"],
    transformScale: 1
  };
  return Resizable;
}
var ResizableBox = {};
var hasRequiredResizableBox;
function requireResizableBox() {
  if (hasRequiredResizableBox) return ResizableBox;
  hasRequiredResizableBox = 1;
  ResizableBox.__esModule = true;
  ResizableBox.default = void 0;
  var React = _interopRequireWildcard(require$$0);
  var _propTypes = _interopRequireDefault(/* @__PURE__ */ requirePropTypes$1());
  var _Resizable = _interopRequireDefault(requireResizable());
  var _propTypes2 = requirePropTypes();
  const _excluded = ["handle", "handleSize", "onResize", "onResizeStart", "onResizeStop", "draggableOpts", "minConstraints", "maxConstraints", "lockAspectRatio", "axis", "width", "height", "resizeHandles", "style", "transformScale"];
  function _interopRequireDefault(e2) {
    return e2 && e2.__esModule ? e2 : { default: e2 };
  }
  function _interopRequireWildcard(e2, t2) {
    if ("function" == typeof WeakMap) var r2 = /* @__PURE__ */ new WeakMap(), n2 = /* @__PURE__ */ new WeakMap();
    return (_interopRequireWildcard = function(e3, t3) {
      if (!t3 && e3 && e3.__esModule) return e3;
      var o2, i2, f2 = { __proto__: null, default: e3 };
      if (null === e3 || "object" != typeof e3 && "function" != typeof e3) return f2;
      if (o2 = t3 ? n2 : r2) {
        if (o2.has(e3)) return o2.get(e3);
        o2.set(e3, f2);
      }
      for (const t4 in e3) "default" !== t4 && {}.hasOwnProperty.call(e3, t4) && ((i2 = (o2 = Object.defineProperty) && Object.getOwnPropertyDescriptor(e3, t4)) && (i2.get || i2.set) ? o2(f2, t4, i2) : f2[t4] = e3[t4]);
      return f2;
    })(e2, t2);
  }
  function _extends2() {
    return _extends2 = Object.assign ? Object.assign.bind() : function(n2) {
      for (var e2 = 1; e2 < arguments.length; e2++) {
        var t2 = arguments[e2];
        for (var r2 in t2) ({}).hasOwnProperty.call(t2, r2) && (n2[r2] = t2[r2]);
      }
      return n2;
    }, _extends2.apply(null, arguments);
  }
  function ownKeys(e2, r2) {
    var t2 = Object.keys(e2);
    if (Object.getOwnPropertySymbols) {
      var o2 = Object.getOwnPropertySymbols(e2);
      r2 && (o2 = o2.filter(function(r3) {
        return Object.getOwnPropertyDescriptor(e2, r3).enumerable;
      })), t2.push.apply(t2, o2);
    }
    return t2;
  }
  function _objectSpread(e2) {
    for (var r2 = 1; r2 < arguments.length; r2++) {
      var t2 = null != arguments[r2] ? arguments[r2] : {};
      r2 % 2 ? ownKeys(Object(t2), true).forEach(function(r3) {
        _defineProperty(e2, r3, t2[r3]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(t2)) : ownKeys(Object(t2)).forEach(function(r3) {
        Object.defineProperty(e2, r3, Object.getOwnPropertyDescriptor(t2, r3));
      });
    }
    return e2;
  }
  function _defineProperty(e2, r2, t2) {
    return (r2 = _toPropertyKey(r2)) in e2 ? Object.defineProperty(e2, r2, { value: t2, enumerable: true, configurable: true, writable: true }) : e2[r2] = t2, e2;
  }
  function _toPropertyKey(t2) {
    var i2 = _toPrimitive(t2, "string");
    return "symbol" == typeof i2 ? i2 : i2 + "";
  }
  function _toPrimitive(t2, r2) {
    if ("object" != typeof t2 || !t2) return t2;
    var e2 = t2[Symbol.toPrimitive];
    if (void 0 !== e2) {
      var i2 = e2.call(t2, r2);
      if ("object" != typeof i2) return i2;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ("string" === r2 ? String : Number)(t2);
  }
  function _objectWithoutProperties(e2, t2) {
    if (null == e2) return {};
    var o2, r2, i2 = _objectWithoutPropertiesLoose2(e2, t2);
    if (Object.getOwnPropertySymbols) {
      var n2 = Object.getOwnPropertySymbols(e2);
      for (r2 = 0; r2 < n2.length; r2++) o2 = n2[r2], -1 === t2.indexOf(o2) && {}.propertyIsEnumerable.call(e2, o2) && (i2[o2] = e2[o2]);
    }
    return i2;
  }
  function _objectWithoutPropertiesLoose2(r2, e2) {
    if (null == r2) return {};
    var t2 = {};
    for (var n2 in r2) if ({}.hasOwnProperty.call(r2, n2)) {
      if (-1 !== e2.indexOf(n2)) continue;
      t2[n2] = r2[n2];
    }
    return t2;
  }
  let ResizableBox$1 = class ResizableBox extends React.Component {
    constructor() {
      super(...arguments);
      this.state = {
        width: this.props.width,
        height: this.props.height,
        propsWidth: this.props.width,
        propsHeight: this.props.height
      };
      this.onResize = (e2, data) => {
        const {
          size
        } = data;
        if (this.props.onResize) {
          e2.persist?.();
          this.setState(size, () => this.props.onResize && this.props.onResize(e2, data));
        } else {
          this.setState(size);
        }
      };
    }
    static getDerivedStateFromProps(props, state2) {
      if (state2.propsWidth !== props.width || state2.propsHeight !== props.height) {
        return {
          width: props.width,
          height: props.height,
          propsWidth: props.width,
          propsHeight: props.height
        };
      }
      return null;
    }
    render() {
      const _this$props = this.props, {
        handle,
        handleSize,
        onResize,
        onResizeStart,
        onResizeStop,
        draggableOpts,
        minConstraints,
        maxConstraints,
        lockAspectRatio,
        axis,
        width,
        height,
        resizeHandles,
        style,
        transformScale
      } = _this$props, props = _objectWithoutProperties(_this$props, _excluded);
      return /* @__PURE__ */ React.createElement(_Resizable.default, {
        axis,
        draggableOpts,
        handle,
        handleSize,
        height: this.state.height,
        lockAspectRatio,
        maxConstraints,
        minConstraints,
        onResizeStart,
        onResize: this.onResize,
        onResizeStop,
        resizeHandles,
        transformScale,
        width: this.state.width
      }, /* @__PURE__ */ React.createElement("div", _extends2({}, props, {
        style: _objectSpread(_objectSpread({}, style), {}, {
          width: this.state.width + "px",
          height: this.state.height + "px"
        })
      })));
    }
  };
  ResizableBox.default = ResizableBox$1;
  ResizableBox$1.propTypes = _objectSpread(_objectSpread({}, _propTypes2.resizableProps), {}, {
    children: _propTypes.default.element
  });
  return ResizableBox;
}
var hasRequiredReactResizable;
function requireReactResizable() {
  if (hasRequiredReactResizable) return reactResizable.exports;
  hasRequiredReactResizable = 1;
  reactResizable.exports = function() {
    throw new Error("Don't instantiate Resizable directly! Use require('react-resizable').Resizable");
  };
  reactResizable.exports.Resizable = requireResizable().default;
  reactResizable.exports.ResizableBox = requireResizableBox().default;
  return reactResizable.exports;
}
var reactResizableExports = requireReactResizable();
function TaskEditor({
  task,
  onSave,
  onCancel,
  mode = "edit"
}) {
  const plugin = usePlugin();
  const [editedTask, setEditedTask] = d(
    extractTaskDetails(task)
  );
  const [edited, setEdited] = d(false);
  y(() => {
    setEditedTask(extractTaskDetails(task));
  }, [task]);
  const handleInputChange = (field, value) => {
    setEdited(true);
    setEditedTask((prev) => ({
      ...prev,
      [field]: value
    }));
  };
  const [managedValue, setManagedValue] = d({ value: task.description ?? "", source: "react" });
  y(() => {
    setManagedValue({ value: task.description || "", source: "react" });
  }, [task]);
  const onEditorChange = q$1(
    (_update, editor) => {
      handleInputChange("description", editor.value || "");
      setManagedValue({ value: editor.value || "", source: "editor" });
    },
    []
  );
  return /* @__PURE__ */ u$1(k$2, { children: [
    /* @__PURE__ */ u$1(
      "div",
      {
        className: "touchable t-8 r-8 modal-close-button mod-raised clickable-icon",
        onClick: onCancel,
        children: /* @__PURE__ */ u$1(Icon, { icon: "x" })
      }
    ),
    /* @__PURE__ */ u$1("div", { className: "p-4", children: [
      /* @__PURE__ */ u$1("div", { className: "flex justify-between items-center mb-4", children: [
        /* @__PURE__ */ u$1("h3", { className: "text-lg font-semibold", children: mode === "create" ? "New Task" : "Edit Task" }),
        /* @__PURE__ */ u$1("div", { className: "flex gap-2", children: /* @__PURE__ */ u$1(
          "button",
          {
            className: "px-3 py-1 bg-(--color-green) text-white rounded text-sm",
            disabled: !edited,
            onClick: () => {
              onSave(task, editedTask).catch((err) => {
                Logger.error("[TaskTrack][TaskEditor.tsx:62]", "Error in saving task:", err);
              });
            },
            children: "Save"
          }
        ) })
      ] }),
      /* @__PURE__ */ u$1("div", { className: "space-y-4", children: [
        /* @__PURE__ */ u$1("div", { children: [
          /* @__PURE__ */ u$1("label", { className: "block text-sm font-medium mb-1", children: "Title" }),
          /* @__PURE__ */ u$1(
            "input",
            {
              type: "text",
              value: editedTask.title,
              onChange: (e2) => handleInputChange("title", e2.currentTarget.value),
              className: "w-full px-3 py-2 bg-(--background-primary) border border-(--background-modifier-border) rounded text-sm"
            }
          )
        ] }),
        /* @__PURE__ */ u$1("div", { children: [
          /* @__PURE__ */ u$1("label", { className: "block text-sm font-medium mb-1", children: "Status" }),
          /* @__PURE__ */ u$1(
            "select",
            {
              value: editedTask.status,
              onChange: (e2) => handleInputChange("status", e2.currentTarget.value),
              className: "w-full px-3 py-2 bg-(--background-primary) border border-(--background-modifier-border) rounded text-sm",
              children: [
                /* @__PURE__ */ u$1("option", { value: "todo", children: "None" }),
                /* @__PURE__ */ u$1("option", { value: "in-progress", children: "In Progress" }),
                /* @__PURE__ */ u$1("option", { value: "backlog", children: "Blocked" }),
                /* @__PURE__ */ u$1("option", { value: "review", children: "Ready" }),
                /* @__PURE__ */ u$1("option", { value: "closed", children: "Closed" })
              ]
            }
          )
        ] }),
        /* @__PURE__ */ u$1("div", { children: [
          /* @__PURE__ */ u$1("label", { className: "block text-sm font-medium mb-1", children: "Priority" }),
          /* @__PURE__ */ u$1(
            Dropdown,
            {
              optionHeight: 28,
              items: [
                {
                  value: "none",
                  label: /* @__PURE__ */ u$1(PriorityBadge, { priority: "none" })
                },
                { value: "low", label: /* @__PURE__ */ u$1(PriorityBadge, { priority: "low" }) },
                {
                  value: "medium",
                  label: /* @__PURE__ */ u$1(PriorityBadge, { priority: "medium" })
                },
                { value: "high", label: /* @__PURE__ */ u$1(PriorityBadge, { priority: "high" }) },
                {
                  value: "critical",
                  label: /* @__PURE__ */ u$1(PriorityBadge, { priority: "critical" })
                }
              ],
              selectedItem: editedTask.priority,
              onChange: (value) => handleInputChange("priority", value)
            }
          )
        ] }),
        /* @__PURE__ */ u$1("div", { children: [
          /* @__PURE__ */ u$1("label", { className: "block text-sm font-medium mb-1", children: "Due Date" }),
          /* @__PURE__ */ u$1(
            "input",
            {
              type: "date",
              value: editedTask.dueDate || "",
              onChange: (e2) => handleInputChange("dueDate", e2.currentTarget.value),
              className: "w-full px-3 py-2 bg-(--background-primary) border border-(--background-modifier-border) rounded text-sm"
            }
          )
        ] }),
        /* @__PURE__ */ u$1("div", { className: "hidden", children: [
          /* @__PURE__ */ u$1("div", { children: [
            /* @__PURE__ */ u$1("label", { className: "block text-sm font-medium mb-1", children: "Project" }),
            /* @__PURE__ */ u$1(
              "input",
              {
                type: "text",
                value: editedTask.project,
                onChange: (e2) => handleInputChange("project", e2.currentTarget.value),
                className: "w-full px-3 py-2 bg(--background-primary)) border border-(--background-modifier-border) rounded text-sm"
              }
            )
          ] }),
          /* @__PURE__ */ u$1("div", { children: [
            /* @__PURE__ */ u$1("label", { className: "block text-sm font-medium mb-1", children: "Section" }),
            /* @__PURE__ */ u$1(
              "input",
              {
                type: "text",
                value: editedTask.section,
                onChange: (e2) => handleInputChange("section", e2.currentTarget.value),
                className: "w-full px-3 py-2 bg-(--background-primary) border border-(--background-modifier-border) rounded text-sm"
              }
            )
          ] })
        ] }),
        /* @__PURE__ */ u$1("div", { children: [
          /* @__PURE__ */ u$1("label", { className: "block text-sm font-medium mb-1", children: "Assignee" }),
          /* @__PURE__ */ u$1(
            "input",
            {
              type: "text",
              value: editedTask.assignee,
              onChange: (e2) => handleInputChange("assignee", e2.currentTarget.value),
              className: "w-full px-3 py-2 bg-(--background-primary) border border-(--background-modifier-border) rounded text-sm"
            }
          )
        ] }),
        /* @__PURE__ */ u$1("label", { className: "block text-sm font-medium", children: "Notes" })
      ] })
    ] }),
    /* @__PURE__ */ u$1("div", { className: "w-full border-t border-(--background-modifier-border) px-4 pt-3 h-full flex flex-col min-h-50", children: /* @__PURE__ */ u$1(
      MarkdownEditor,
      {
        app: plugin.app,
        value: managedValue,
        onChange: onEditorChange,
        cssText: "font-size: 15px; flex-grow: 1"
      }
    ) })
  ] });
}
function TaskEditorSidebar({
  task,
  onSave,
  onCancel
}) {
  const [width, setWidth] = d(400);
  return /* @__PURE__ */ u$1(
    reactResizableExports.Resizable,
    {
      width,
      height: 0,
      minConstraints: [250, 0],
      maxConstraints: [1e3, 0],
      resizeHandles: ["w"],
      onResize: (e2, { size }) => {
        e2.stopPropagation();
        setWidth(size.width);
      },
      handle: /* @__PURE__ */ u$1("div", { className: "absolute top-0 bottom-0 left-0 w-1 cursor-col-resize select-none bg-(--divider-color) hover:bg-(--text-normal) active:bg-(--color-blue)" }),
      children: /* @__PURE__ */ u$1(
        "div",
        {
          className: "bg-(--background-primary) absolute right-0 top-0 bottom-0 overflow-y-scroll shadow-lg",
          style: { width },
          children: /* @__PURE__ */ u$1(TaskEditor, { task, onSave, onCancel })
        }
      )
    }
  );
}
var dexie_min$1 = { exports: {} };
var dexie_min = dexie_min$1.exports;
var hasRequiredDexie_min;
function requireDexie_min() {
  if (hasRequiredDexie_min) return dexie_min$1.exports;
  hasRequiredDexie_min = 1;
  (function(module2, exports$1) {
    (function(e2, t2) {
      module2.exports = t2();
    })(dexie_min, function() {
      var s2 = function(e3, t3) {
        return (s2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e4, t4) {
          e4.__proto__ = t4;
        } || function(e4, t4) {
          for (var n3 in t4) Object.prototype.hasOwnProperty.call(t4, n3) && (e4[n3] = t4[n3]);
        })(e3, t3);
      };
      var _2 = function() {
        return (_2 = Object.assign || function(e3) {
          for (var t3, n3 = 1, r3 = arguments.length; n3 < r3; n3++) for (var i3 in t3 = arguments[n3]) Object.prototype.hasOwnProperty.call(t3, i3) && (e3[i3] = t3[i3]);
          return e3;
        }).apply(this, arguments);
      };
      function i2(e3, t3, n3) {
        for (var r3, i3 = 0, o3 = t3.length; i3 < o3; i3++) !r3 && i3 in t3 || ((r3 = r3 || Array.prototype.slice.call(t3, 0, i3))[i3] = t3[i3]);
        return e3.concat(r3 || Array.prototype.slice.call(t3));
      }
      var f2 = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof self ? self : "undefined" != typeof window ? window : commonjsGlobal, O2 = Object.keys, x2 = Array.isArray;
      function a2(t3, n3) {
        return "object" != typeof n3 || O2(n3).forEach(function(e3) {
          t3[e3] = n3[e3];
        }), t3;
      }
      "undefined" == typeof Promise || f2.Promise || (f2.Promise = Promise);
      var c2 = Object.getPrototypeOf, n2 = {}.hasOwnProperty;
      function m2(e3, t3) {
        return n2.call(e3, t3);
      }
      function r2(t3, n3) {
        "function" == typeof n3 && (n3 = n3(c2(t3))), ("undefined" == typeof Reflect ? O2 : Reflect.ownKeys)(n3).forEach(function(e3) {
          l2(t3, e3, n3[e3]);
        });
      }
      var u2 = Object.defineProperty;
      function l2(e3, t3, n3, r3) {
        u2(e3, t3, a2(n3 && m2(n3, "get") && "function" == typeof n3.get ? { get: n3.get, set: n3.set, configurable: true } : { value: n3, configurable: true, writable: true }, r3));
      }
      function o2(t3) {
        return { from: function(e3) {
          return t3.prototype = Object.create(e3.prototype), l2(t3.prototype, "constructor", t3), { extend: r2.bind(null, t3.prototype) };
        } };
      }
      var h2 = Object.getOwnPropertyDescriptor;
      var d2 = [].slice;
      function b2(e3, t3, n3) {
        return d2.call(e3, t3, n3);
      }
      function p2(e3, t3) {
        return t3(e3);
      }
      function y2(e3) {
        if (!e3) throw new Error("Assertion Failed");
      }
      function v2(e3) {
        f2.setImmediate ? setImmediate(e3) : setTimeout(e3, 0);
      }
      function g2(e3, t3) {
        if ("string" == typeof t3 && m2(e3, t3)) return e3[t3];
        if (!t3) return e3;
        if ("string" != typeof t3) {
          for (var n3 = [], r3 = 0, i3 = t3.length; r3 < i3; ++r3) {
            var o3 = g2(e3, t3[r3]);
            n3.push(o3);
          }
          return n3;
        }
        var a3 = t3.indexOf(".");
        if (-1 !== a3) {
          var u3 = e3[t3.substr(0, a3)];
          return null == u3 ? void 0 : g2(u3, t3.substr(a3 + 1));
        }
      }
      function w2(e3, t3, n3) {
        if (e3 && void 0 !== t3 && !("isFrozen" in Object && Object.isFrozen(e3))) if ("string" != typeof t3 && "length" in t3) {
          y2("string" != typeof n3 && "length" in n3);
          for (var r3 = 0, i3 = t3.length; r3 < i3; ++r3) w2(e3, t3[r3], n3[r3]);
        } else {
          var o3, a3, u3 = t3.indexOf(".");
          -1 !== u3 ? (o3 = t3.substr(0, u3), "" === (a3 = t3.substr(u3 + 1)) ? void 0 === n3 ? x2(e3) && !isNaN(parseInt(o3)) ? e3.splice(o3, 1) : delete e3[o3] : e3[o3] = n3 : w2(u3 = !(u3 = e3[o3]) || !m2(e3, o3) ? e3[o3] = {} : u3, a3, n3)) : void 0 === n3 ? x2(e3) && !isNaN(parseInt(t3)) ? e3.splice(t3, 1) : delete e3[t3] : e3[t3] = n3;
        }
      }
      function k2(e3) {
        var t3, n3 = {};
        for (t3 in e3) m2(e3, t3) && (n3[t3] = e3[t3]);
        return n3;
      }
      var t2 = [].concat;
      function P2(e3) {
        return t2.apply([], e3);
      }
      var e2 = "BigUint64Array,BigInt64Array,Array,Boolean,String,Date,RegExp,Blob,File,FileList,FileSystemFileHandle,FileSystemDirectoryHandle,ArrayBuffer,DataView,Uint8ClampedArray,ImageBitmap,ImageData,Map,Set,CryptoKey".split(",").concat(P2([8, 16, 32, 64].map(function(t3) {
        return ["Int", "Uint", "Float"].map(function(e3) {
          return e3 + t3 + "Array";
        });
      }))).filter(function(e3) {
        return f2[e3];
      }), K2 = new Set(e2.map(function(e3) {
        return f2[e3];
      }));
      var E2 = null;
      function S2(e3) {
        E2 = /* @__PURE__ */ new WeakMap();
        e3 = (function e4(t3) {
          if (!t3 || "object" != typeof t3) return t3;
          var n3 = E2.get(t3);
          if (n3) return n3;
          if (x2(t3)) {
            n3 = [], E2.set(t3, n3);
            for (var r3 = 0, i3 = t3.length; r3 < i3; ++r3) n3.push(e4(t3[r3]));
          } else if (K2.has(t3.constructor)) n3 = t3;
          else {
            var o3, a3 = c2(t3);
            for (o3 in n3 = a3 === Object.prototype ? {} : Object.create(a3), E2.set(t3, n3), t3) m2(t3, o3) && (n3[o3] = e4(t3[o3]));
          }
          return n3;
        })(e3);
        return E2 = null, e3;
      }
      var j2 = {}.toString;
      function A2(e3) {
        return j2.call(e3).slice(8, -1);
      }
      var C2 = "undefined" != typeof Symbol ? Symbol.iterator : "@@iterator", T2 = "symbol" == typeof C2 ? function(e3) {
        var t3;
        return null != e3 && (t3 = e3[C2]) && t3.apply(e3);
      } : function() {
        return null;
      };
      function I2(e3, t3) {
        t3 = e3.indexOf(t3);
        return 0 <= t3 && e3.splice(t3, 1), 0 <= t3;
      }
      var q2 = {};
      function D2(e3) {
        var t3, n3, r3, i3;
        if (1 === arguments.length) {
          if (x2(e3)) return e3.slice();
          if (this === q2 && "string" == typeof e3) return [e3];
          if (i3 = T2(e3)) {
            for (n3 = []; !(r3 = i3.next()).done; ) n3.push(r3.value);
            return n3;
          }
          if (null == e3) return [e3];
          if ("number" != typeof (t3 = e3.length)) return [e3];
          for (n3 = new Array(t3); t3--; ) n3[t3] = e3[t3];
          return n3;
        }
        for (t3 = arguments.length, n3 = new Array(t3); t3--; ) n3[t3] = arguments[t3];
        return n3;
      }
      var B2 = "undefined" != typeof Symbol ? function(e3) {
        return "AsyncFunction" === e3[Symbol.toStringTag];
      } : function() {
        return false;
      }, R2 = ["Unknown", "Constraint", "Data", "TransactionInactive", "ReadOnly", "Version", "NotFound", "InvalidState", "InvalidAccess", "Abort", "Timeout", "QuotaExceeded", "Syntax", "DataClone"], F2 = ["Modify", "Bulk", "OpenFailed", "VersionChange", "Schema", "Upgrade", "InvalidTable", "MissingAPI", "NoSuchDatabase", "InvalidArgument", "SubTransaction", "Unsupported", "Internal", "DatabaseClosed", "PrematureCommit", "ForeignAwait"].concat(R2), M2 = { VersionChanged: "Database version changed by other database connection", DatabaseClosed: "Database has been closed", Abort: "Transaction aborted", TransactionInactive: "Transaction has already completed or failed", MissingAPI: "IndexedDB API missing. Please visit https://tinyurl.com/y2uuvskb" };
      function N2(e3, t3) {
        this.name = e3, this.message = t3;
      }
      function L2(e3, t3) {
        return e3 + ". Errors: " + Object.keys(t3).map(function(e4) {
          return t3[e4].toString();
        }).filter(function(e4, t4, n3) {
          return n3.indexOf(e4) === t4;
        }).join("\n");
      }
      function U2(e3, t3, n3, r3) {
        this.failures = t3, this.failedKeys = r3, this.successCount = n3, this.message = L2(e3, t3);
      }
      function V2(e3, t3) {
        this.name = "BulkError", this.failures = Object.keys(t3).map(function(e4) {
          return t3[e4];
        }), this.failuresByPos = t3, this.message = L2(e3, this.failures);
      }
      o2(N2).from(Error).extend({ toString: function() {
        return this.name + ": " + this.message;
      } }), o2(U2).from(N2), o2(V2).from(N2);
      var z2 = F2.reduce(function(e3, t3) {
        return e3[t3] = t3 + "Error", e3;
      }, {}), W2 = N2, Y2 = F2.reduce(function(e3, n3) {
        var r3 = n3 + "Error";
        function t3(e4, t4) {
          this.name = r3, e4 ? "string" == typeof e4 ? (this.message = "".concat(e4).concat(t4 ? "\n " + t4 : ""), this.inner = t4 || null) : "object" == typeof e4 && (this.message = "".concat(e4.name, " ").concat(e4.message), this.inner = e4) : (this.message = M2[n3] || r3, this.inner = null);
        }
        return o2(t3).from(W2), e3[n3] = t3, e3;
      }, {});
      Y2.Syntax = SyntaxError, Y2.Type = TypeError, Y2.Range = RangeError;
      var $2 = R2.reduce(function(e3, t3) {
        return e3[t3 + "Error"] = Y2[t3], e3;
      }, {});
      var Q2 = F2.reduce(function(e3, t3) {
        return -1 === ["Syntax", "Type", "Range"].indexOf(t3) && (e3[t3 + "Error"] = Y2[t3]), e3;
      }, {});
      function G2() {
      }
      function X2(e3) {
        return e3;
      }
      function H2(t3, n3) {
        return null == t3 || t3 === X2 ? n3 : function(e3) {
          return n3(t3(e3));
        };
      }
      function J2(e3, t3) {
        return function() {
          e3.apply(this, arguments), t3.apply(this, arguments);
        };
      }
      function Z2(i3, o3) {
        return i3 === G2 ? o3 : function() {
          var e3 = i3.apply(this, arguments);
          void 0 !== e3 && (arguments[0] = e3);
          var t3 = this.onsuccess, n3 = this.onerror;
          this.onsuccess = null, this.onerror = null;
          var r3 = o3.apply(this, arguments);
          return t3 && (this.onsuccess = this.onsuccess ? J2(t3, this.onsuccess) : t3), n3 && (this.onerror = this.onerror ? J2(n3, this.onerror) : n3), void 0 !== r3 ? r3 : e3;
        };
      }
      function ee(n3, r3) {
        return n3 === G2 ? r3 : function() {
          n3.apply(this, arguments);
          var e3 = this.onsuccess, t3 = this.onerror;
          this.onsuccess = this.onerror = null, r3.apply(this, arguments), e3 && (this.onsuccess = this.onsuccess ? J2(e3, this.onsuccess) : e3), t3 && (this.onerror = this.onerror ? J2(t3, this.onerror) : t3);
        };
      }
      function te(i3, o3) {
        return i3 === G2 ? o3 : function(e3) {
          var t3 = i3.apply(this, arguments);
          a2(e3, t3);
          var n3 = this.onsuccess, r3 = this.onerror;
          this.onsuccess = null, this.onerror = null;
          e3 = o3.apply(this, arguments);
          return n3 && (this.onsuccess = this.onsuccess ? J2(n3, this.onsuccess) : n3), r3 && (this.onerror = this.onerror ? J2(r3, this.onerror) : r3), void 0 === t3 ? void 0 === e3 ? void 0 : e3 : a2(t3, e3);
        };
      }
      function ne(e3, t3) {
        return e3 === G2 ? t3 : function() {
          return false !== t3.apply(this, arguments) && e3.apply(this, arguments);
        };
      }
      function re(i3, o3) {
        return i3 === G2 ? o3 : function() {
          var e3 = i3.apply(this, arguments);
          if (e3 && "function" == typeof e3.then) {
            for (var t3 = this, n3 = arguments.length, r3 = new Array(n3); n3--; ) r3[n3] = arguments[n3];
            return e3.then(function() {
              return o3.apply(t3, r3);
            });
          }
          return o3.apply(this, arguments);
        };
      }
      Q2.ModifyError = U2, Q2.DexieError = N2, Q2.BulkError = V2;
      var ie = "undefined" != typeof location && /^(http|https):\/\/(localhost|127\.0\.0\.1)/.test(location.href);
      function oe(e3) {
        ie = e3;
      }
      var ae = {}, ue = 100, e2 = "undefined" == typeof Promise ? [] : (function() {
        var e3 = Promise.resolve();
        if ("undefined" == typeof crypto || !crypto.subtle) return [e3, c2(e3), e3];
        var t3 = crypto.subtle.digest("SHA-512", new Uint8Array([0]));
        return [t3, c2(t3), e3];
      })(), R2 = e2[0], F2 = e2[1], e2 = e2[2], F2 = F2 && F2.then, se = R2 && R2.constructor, ce = !!e2;
      var le = function(e3, t3) {
        be.push([e3, t3]), he && (queueMicrotask(Se), he = false);
      }, fe = true, he = true, de = [], pe = [], ye = X2, ve = { id: "global", global: true, ref: 0, unhandleds: [], onunhandled: G2, pgp: false, env: {}, finalize: G2 }, me = ve, be = [], ge = 0, we = [];
      function _e(e3) {
        if ("object" != typeof this) throw new TypeError("Promises must be constructed via new");
        this._listeners = [], this._lib = false;
        var t3 = this._PSD = me;
        if ("function" != typeof e3) {
          if (e3 !== ae) throw new TypeError("Not a function");
          return this._state = arguments[1], this._value = arguments[2], void (false === this._state && Oe(this, this._value));
        }
        this._state = null, this._value = null, ++t3.ref, (function t4(r3, e4) {
          try {
            e4(function(n3) {
              if (null === r3._state) {
                if (n3 === r3) throw new TypeError("A promise cannot be resolved with itself.");
                var e5 = r3._lib && je();
                n3 && "function" == typeof n3.then ? t4(r3, function(e6, t5) {
                  n3 instanceof _e ? n3._then(e6, t5) : n3.then(e6, t5);
                }) : (r3._state = true, r3._value = n3, Pe(r3)), e5 && Ae();
              }
            }, Oe.bind(null, r3));
          } catch (e5) {
            Oe(r3, e5);
          }
        })(this, e3);
      }
      var xe = { get: function() {
        var u3 = me, t3 = Fe;
        function e3(n3, r3) {
          var i3 = this, o3 = !u3.global && (u3 !== me || t3 !== Fe), a3 = o3 && !Ue(), e4 = new _e(function(e5, t4) {
            Ke(i3, new ke(Qe(n3, u3, o3, a3), Qe(r3, u3, o3, a3), e5, t4, u3));
          });
          return this._consoleTask && (e4._consoleTask = this._consoleTask), e4;
        }
        return e3.prototype = ae, e3;
      }, set: function(e3) {
        l2(this, "then", e3 && e3.prototype === ae ? xe : { get: function() {
          return e3;
        }, set: xe.set });
      } };
      function ke(e3, t3, n3, r3, i3) {
        this.onFulfilled = "function" == typeof e3 ? e3 : null, this.onRejected = "function" == typeof t3 ? t3 : null, this.resolve = n3, this.reject = r3, this.psd = i3;
      }
      function Oe(e3, t3) {
        var n3, r3;
        pe.push(t3), null === e3._state && (n3 = e3._lib && je(), t3 = ye(t3), e3._state = false, e3._value = t3, r3 = e3, de.some(function(e4) {
          return e4._value === r3._value;
        }) || de.push(r3), Pe(e3), n3 && Ae());
      }
      function Pe(e3) {
        var t3 = e3._listeners;
        e3._listeners = [];
        for (var n3 = 0, r3 = t3.length; n3 < r3; ++n3) Ke(e3, t3[n3]);
        var i3 = e3._PSD;
        --i3.ref || i3.finalize(), 0 === ge && (++ge, le(function() {
          0 == --ge && Ce();
        }, []));
      }
      function Ke(e3, t3) {
        if (null !== e3._state) {
          var n3 = e3._state ? t3.onFulfilled : t3.onRejected;
          if (null === n3) return (e3._state ? t3.resolve : t3.reject)(e3._value);
          ++t3.psd.ref, ++ge, le(Ee, [n3, e3, t3]);
        } else e3._listeners.push(t3);
      }
      function Ee(e3, t3, n3) {
        try {
          var r3, i3 = t3._value;
          !t3._state && pe.length && (pe = []), r3 = ie && t3._consoleTask ? t3._consoleTask.run(function() {
            return e3(i3);
          }) : e3(i3), t3._state || -1 !== pe.indexOf(i3) || (function(e4) {
            var t4 = de.length;
            for (; t4; ) if (de[--t4]._value === e4._value) return de.splice(t4, 1);
          })(t3), n3.resolve(r3);
        } catch (e4) {
          n3.reject(e4);
        } finally {
          0 == --ge && Ce(), --n3.psd.ref || n3.psd.finalize();
        }
      }
      function Se() {
        $e(ve, function() {
          je() && Ae();
        });
      }
      function je() {
        var e3 = fe;
        return he = fe = false, e3;
      }
      function Ae() {
        var e3, t3, n3;
        do {
          for (; 0 < be.length; ) for (e3 = be, be = [], n3 = e3.length, t3 = 0; t3 < n3; ++t3) {
            var r3 = e3[t3];
            r3[0].apply(null, r3[1]);
          }
        } while (0 < be.length);
        he = fe = true;
      }
      function Ce() {
        var e3 = de;
        de = [], e3.forEach(function(e4) {
          e4._PSD.onunhandled.call(null, e4._value, e4);
        });
        for (var t3 = we.slice(0), n3 = t3.length; n3; ) t3[--n3]();
      }
      function Te(e3) {
        return new _e(ae, false, e3);
      }
      function Ie(n3, r3) {
        var i3 = me;
        return function() {
          var e3 = je(), t3 = me;
          try {
            return We(i3, true), n3.apply(this, arguments);
          } catch (e4) {
            r3 && r3(e4);
          } finally {
            We(t3, false), e3 && Ae();
          }
        };
      }
      r2(_e.prototype, { then: xe, _then: function(e3, t3) {
        Ke(this, new ke(null, null, e3, t3, me));
      }, catch: function(e3) {
        if (1 === arguments.length) return this.then(null, e3);
        var t3 = e3, n3 = arguments[1];
        return "function" == typeof t3 ? this.then(null, function(e4) {
          return (e4 instanceof t3 ? n3 : Te)(e4);
        }) : this.then(null, function(e4) {
          return (e4 && e4.name === t3 ? n3 : Te)(e4);
        });
      }, finally: function(t3) {
        return this.then(function(e3) {
          return _e.resolve(t3()).then(function() {
            return e3;
          });
        }, function(e3) {
          return _e.resolve(t3()).then(function() {
            return Te(e3);
          });
        });
      }, timeout: function(r3, i3) {
        var o3 = this;
        return r3 < 1 / 0 ? new _e(function(e3, t3) {
          var n3 = setTimeout(function() {
            return t3(new Y2.Timeout(i3));
          }, r3);
          o3.then(e3, t3).finally(clearTimeout.bind(null, n3));
        }) : this;
      } }), "undefined" != typeof Symbol && Symbol.toStringTag && l2(_e.prototype, Symbol.toStringTag, "Dexie.Promise"), ve.env = Ye(), r2(_e, { all: function() {
        var o3 = D2.apply(null, arguments).map(Ve);
        return new _e(function(n3, r3) {
          0 === o3.length && n3([]);
          var i3 = o3.length;
          o3.forEach(function(e3, t3) {
            return _e.resolve(e3).then(function(e4) {
              o3[t3] = e4, --i3 || n3(o3);
            }, r3);
          });
        });
      }, resolve: function(n3) {
        return n3 instanceof _e ? n3 : n3 && "function" == typeof n3.then ? new _e(function(e3, t3) {
          n3.then(e3, t3);
        }) : new _e(ae, true, n3);
      }, reject: Te, race: function() {
        var e3 = D2.apply(null, arguments).map(Ve);
        return new _e(function(t3, n3) {
          e3.map(function(e4) {
            return _e.resolve(e4).then(t3, n3);
          });
        });
      }, PSD: { get: function() {
        return me;
      }, set: function(e3) {
        return me = e3;
      } }, totalEchoes: { get: function() {
        return Fe;
      } }, newPSD: Ne, usePSD: $e, scheduler: { get: function() {
        return le;
      }, set: function(e3) {
        le = e3;
      } }, rejectionMapper: { get: function() {
        return ye;
      }, set: function(e3) {
        ye = e3;
      } }, follow: function(i3, n3) {
        return new _e(function(e3, t3) {
          return Ne(function(n4, r3) {
            var e4 = me;
            e4.unhandleds = [], e4.onunhandled = r3, e4.finalize = J2(function() {
              var t4, e5 = this;
              t4 = function() {
                0 === e5.unhandleds.length ? n4() : r3(e5.unhandleds[0]);
              }, we.push(function e6() {
                t4(), we.splice(we.indexOf(e6), 1);
              }), ++ge, le(function() {
                0 == --ge && Ce();
              }, []);
            }, e4.finalize), i3();
          }, n3, e3, t3);
        });
      } }), se && (se.allSettled && l2(_e, "allSettled", function() {
        var e3 = D2.apply(null, arguments).map(Ve);
        return new _e(function(n3) {
          0 === e3.length && n3([]);
          var r3 = e3.length, i3 = new Array(r3);
          e3.forEach(function(e4, t3) {
            return _e.resolve(e4).then(function(e5) {
              return i3[t3] = { status: "fulfilled", value: e5 };
            }, function(e5) {
              return i3[t3] = { status: "rejected", reason: e5 };
            }).then(function() {
              return --r3 || n3(i3);
            });
          });
        });
      }), se.any && "undefined" != typeof AggregateError && l2(_e, "any", function() {
        var e3 = D2.apply(null, arguments).map(Ve);
        return new _e(function(n3, r3) {
          0 === e3.length && r3(new AggregateError([]));
          var i3 = e3.length, o3 = new Array(i3);
          e3.forEach(function(e4, t3) {
            return _e.resolve(e4).then(function(e5) {
              return n3(e5);
            }, function(e5) {
              o3[t3] = e5, --i3 || r3(new AggregateError(o3));
            });
          });
        });
      }), se.withResolvers && (_e.withResolvers = se.withResolvers));
      var qe = { awaits: 0, echoes: 0, id: 0 }, De = 0, Be = [], Re = 0, Fe = 0, Me = 0;
      function Ne(e3, t3, n3, r3) {
        var i3 = me, o3 = Object.create(i3);
        o3.parent = i3, o3.ref = 0, o3.global = false, o3.id = ++Me, ve.env, o3.env = ce ? { Promise: _e, PromiseProp: { value: _e, configurable: true, writable: true }, all: _e.all, race: _e.race, allSettled: _e.allSettled, any: _e.any, resolve: _e.resolve, reject: _e.reject } : {}, t3 && a2(o3, t3), ++i3.ref, o3.finalize = function() {
          --this.parent.ref || this.parent.finalize();
        };
        r3 = $e(o3, e3, n3, r3);
        return 0 === o3.ref && o3.finalize(), r3;
      }
      function Le() {
        return qe.id || (qe.id = ++De), ++qe.awaits, qe.echoes += ue, qe.id;
      }
      function Ue() {
        return !!qe.awaits && (0 == --qe.awaits && (qe.id = 0), qe.echoes = qe.awaits * ue, true);
      }
      function Ve(e3) {
        return qe.echoes && e3 && e3.constructor === se ? (Le(), e3.then(function(e4) {
          return Ue(), e4;
        }, function(e4) {
          return Ue(), Xe(e4);
        })) : e3;
      }
      function ze() {
        var e3 = Be[Be.length - 1];
        Be.pop(), We(e3, false);
      }
      function We(e3, t3) {
        var n3, r3 = me;
        (t3 ? !qe.echoes || Re++ && e3 === me : !Re || --Re && e3 === me) || queueMicrotask(t3 ? function(e4) {
          ++Fe, qe.echoes && 0 != --qe.echoes || (qe.echoes = qe.awaits = qe.id = 0), Be.push(me), We(e4, true);
        }.bind(null, e3) : ze), e3 !== me && (me = e3, r3 === ve && (ve.env = Ye()), ce && (n3 = ve.env.Promise, t3 = e3.env, (r3.global || e3.global) && (Object.defineProperty(f2, "Promise", t3.PromiseProp), n3.all = t3.all, n3.race = t3.race, n3.resolve = t3.resolve, n3.reject = t3.reject, t3.allSettled && (n3.allSettled = t3.allSettled), t3.any && (n3.any = t3.any))));
      }
      function Ye() {
        var e3 = f2.Promise;
        return ce ? { Promise: e3, PromiseProp: Object.getOwnPropertyDescriptor(f2, "Promise"), all: e3.all, race: e3.race, allSettled: e3.allSettled, any: e3.any, resolve: e3.resolve, reject: e3.reject } : {};
      }
      function $e(e3, t3, n3, r3, i3) {
        var o3 = me;
        try {
          return We(e3, true), t3(n3, r3, i3);
        } finally {
          We(o3, false);
        }
      }
      function Qe(t3, n3, r3, i3) {
        return "function" != typeof t3 ? t3 : function() {
          var e3 = me;
          r3 && Le(), We(n3, true);
          try {
            return t3.apply(this, arguments);
          } finally {
            We(e3, false), i3 && queueMicrotask(Ue);
          }
        };
      }
      function Ge(e3) {
        Promise === se && 0 === qe.echoes ? 0 === Re ? e3() : enqueueNativeMicroTask(e3) : setTimeout(e3, 0);
      }
      -1 === ("" + F2).indexOf("[native code]") && (Le = Ue = G2);
      var Xe = _e.reject;
      var He = String.fromCharCode(65535), Je = "Invalid key provided. Keys must be of type string, number, Date or Array<string | number | Date>.", Ze = "String expected.", et = [], tt = "__dbnames", nt = "readonly", rt = "readwrite";
      function it(e3, t3) {
        return e3 ? t3 ? function() {
          return e3.apply(this, arguments) && t3.apply(this, arguments);
        } : e3 : t3;
      }
      var ot = { type: 3, lower: -1 / 0, lowerOpen: false, upper: [[]], upperOpen: false };
      function at(t3) {
        return "string" != typeof t3 || /\./.test(t3) ? function(e3) {
          return e3;
        } : function(e3) {
          return void 0 === e3[t3] && t3 in e3 && delete (e3 = S2(e3))[t3], e3;
        };
      }
      function ut() {
        throw Y2.Type("Entity instances must never be new:ed. Instances are generated by the framework bypassing the constructor.");
      }
      function st(e3, t3) {
        try {
          var n3 = ct(e3), r3 = ct(t3);
          if (n3 !== r3) return "Array" === n3 ? 1 : "Array" === r3 ? -1 : "binary" === n3 ? 1 : "binary" === r3 ? -1 : "string" === n3 ? 1 : "string" === r3 ? -1 : "Date" === n3 ? 1 : "Date" !== r3 ? NaN : -1;
          switch (n3) {
            case "number":
            case "Date":
            case "string":
              return t3 < e3 ? 1 : e3 < t3 ? -1 : 0;
            case "binary":
              return (function(e4, t4) {
                for (var n4 = e4.length, r4 = t4.length, i3 = n4 < r4 ? n4 : r4, o3 = 0; o3 < i3; ++o3) if (e4[o3] !== t4[o3]) return e4[o3] < t4[o3] ? -1 : 1;
                return n4 === r4 ? 0 : n4 < r4 ? -1 : 1;
              })(lt(e3), lt(t3));
            case "Array":
              return (function(e4, t4) {
                for (var n4 = e4.length, r4 = t4.length, i3 = n4 < r4 ? n4 : r4, o3 = 0; o3 < i3; ++o3) {
                  var a3 = st(e4[o3], t4[o3]);
                  if (0 !== a3) return a3;
                }
                return n4 === r4 ? 0 : n4 < r4 ? -1 : 1;
              })(e3, t3);
          }
        } catch (e4) {
        }
        return NaN;
      }
      function ct(e3) {
        var t3 = typeof e3;
        if ("object" != t3) return t3;
        if (ArrayBuffer.isView(e3)) return "binary";
        e3 = A2(e3);
        return "ArrayBuffer" === e3 ? "binary" : e3;
      }
      function lt(e3) {
        return e3 instanceof Uint8Array ? e3 : ArrayBuffer.isView(e3) ? new Uint8Array(e3.buffer, e3.byteOffset, e3.byteLength) : new Uint8Array(e3);
      }
      function ft(t3, n3, r3) {
        var e3 = t3.schema.yProps;
        return e3 ? (n3 && 0 < r3.numFailures && (n3 = n3.filter(function(e4, t4) {
          return !r3.failures[t4];
        })), Promise.all(e3.map(function(e4) {
          e4 = e4.updatesTable;
          return n3 ? t3.db.table(e4).where("k").anyOf(n3).delete() : t3.db.table(e4).clear();
        })).then(function() {
          return r3;
        })) : r3;
      }
      var ht = (dt.prototype.execute = function(e3) {
        var t3 = this["@@propmod"];
        if (void 0 !== t3.add) {
          var n3 = t3.add;
          if (x2(n3)) return i2(i2([], x2(e3) ? e3 : [], true), n3).sort();
          if ("number" == typeof n3) return (Number(e3) || 0) + n3;
          if ("bigint" == typeof n3) try {
            return BigInt(e3) + n3;
          } catch (e4) {
            return BigInt(0) + n3;
          }
          throw new TypeError("Invalid term ".concat(n3));
        }
        if (void 0 !== t3.remove) {
          var r3 = t3.remove;
          if (x2(r3)) return x2(e3) ? e3.filter(function(e4) {
            return !r3.includes(e4);
          }).sort() : [];
          if ("number" == typeof r3) return Number(e3) - r3;
          if ("bigint" == typeof r3) try {
            return BigInt(e3) - r3;
          } catch (e4) {
            return BigInt(0) - r3;
          }
          throw new TypeError("Invalid subtrahend ".concat(r3));
        }
        n3 = null === (n3 = t3.replacePrefix) || void 0 === n3 ? void 0 : n3[0];
        return n3 && "string" == typeof e3 && e3.startsWith(n3) ? t3.replacePrefix[1] + e3.substring(n3.length) : e3;
      }, dt);
      function dt(e3) {
        this["@@propmod"] = e3;
      }
      function pt(e3, t3) {
        for (var n3 = O2(t3), r3 = n3.length, i3 = false, o3 = 0; o3 < r3; ++o3) {
          var a3 = n3[o3], u3 = t3[a3], s3 = g2(e3, a3);
          u3 instanceof ht ? (w2(e3, a3, u3.execute(s3)), i3 = true) : s3 !== u3 && (w2(e3, a3, u3), i3 = true);
        }
        return i3;
      }
      var yt = (vt.prototype._trans = function(e3, r3, t3) {
        var n3 = this._tx || me.trans, i3 = this.name, o3 = ie && "undefined" != typeof console && console.createTask && console.createTask("Dexie: ".concat("readonly" === e3 ? "read" : "write", " ").concat(this.name));
        function a3(e4, t4, n4) {
          if (!n4.schema[i3]) throw new Y2.NotFound("Table " + i3 + " not part of transaction");
          return r3(n4.idbtrans, n4);
        }
        var u3 = je();
        try {
          var s3 = n3 && n3.db._novip === this.db._novip ? n3 === me.trans ? n3._promise(e3, a3, t3) : Ne(function() {
            return n3._promise(e3, a3, t3);
          }, { trans: n3, transless: me.transless || me }) : (function t4(n4, r4, i4, o4) {
            if (n4.idbdb && (n4._state.openComplete || me.letThrough || n4._vip)) {
              var a4 = n4._createTransaction(r4, i4, n4._dbSchema);
              try {
                a4.create(), n4._state.PR1398_maxLoop = 3;
              } catch (e4) {
                return e4.name === z2.InvalidState && n4.isOpen() && 0 < --n4._state.PR1398_maxLoop ? (console.warn("Dexie: Need to reopen db"), n4.close({ disableAutoOpen: false }), n4.open().then(function() {
                  return t4(n4, r4, i4, o4);
                })) : Xe(e4);
              }
              return a4._promise(r4, function(e4, t5) {
                return Ne(function() {
                  return me.trans = a4, o4(e4, t5, a4);
                });
              }).then(function(e4) {
                if ("readwrite" === r4) try {
                  a4.idbtrans.commit();
                } catch (e5) {
                }
                return "readonly" === r4 ? e4 : a4._completion.then(function() {
                  return e4;
                });
              });
            }
            if (n4._state.openComplete) return Xe(new Y2.DatabaseClosed(n4._state.dbOpenError));
            if (!n4._state.isBeingOpened) {
              if (!n4._state.autoOpen) return Xe(new Y2.DatabaseClosed());
              n4.open().catch(G2);
            }
            return n4._state.dbReadyPromise.then(function() {
              return t4(n4, r4, i4, o4);
            });
          })(this.db, e3, [this.name], a3);
          return o3 && (s3._consoleTask = o3, s3 = s3.catch(function(e4) {
            return console.trace(e4), Xe(e4);
          })), s3;
        } finally {
          u3 && Ae();
        }
      }, vt.prototype.get = function(t3, e3) {
        var n3 = this;
        return t3 && t3.constructor === Object ? this.where(t3).first(e3) : null == t3 ? Xe(new Y2.Type("Invalid argument to Table.get()")) : this._trans("readonly", function(e4) {
          return n3.core.get({ trans: e4, key: t3 }).then(function(e5) {
            return n3.hook.reading.fire(e5);
          });
        }).then(e3);
      }, vt.prototype.where = function(o3) {
        if ("string" == typeof o3) return new this.db.WhereClause(this, o3);
        if (x2(o3)) return new this.db.WhereClause(this, "[".concat(o3.join("+"), "]"));
        var n3 = O2(o3);
        if (1 === n3.length) return this.where(n3[0]).equals(o3[n3[0]]);
        var e3 = this.schema.indexes.concat(this.schema.primKey).filter(function(t4) {
          if (t4.compound && n3.every(function(e5) {
            return 0 <= t4.keyPath.indexOf(e5);
          })) {
            for (var e4 = 0; e4 < n3.length; ++e4) if (-1 === n3.indexOf(t4.keyPath[e4])) return false;
            return true;
          }
          return false;
        }).sort(function(e4, t4) {
          return e4.keyPath.length - t4.keyPath.length;
        })[0];
        if (e3 && this.db._maxKey !== He) {
          var t3 = e3.keyPath.slice(0, n3.length);
          return this.where(t3).equals(t3.map(function(e4) {
            return o3[e4];
          }));
        }
        !e3 && ie && console.warn("The query ".concat(JSON.stringify(o3), " on ").concat(this.name, " would benefit from a ") + "compound index [".concat(n3.join("+"), "]"));
        var a3 = this.schema.idxByName;
        function u3(e4, t4) {
          return 0 === st(e4, t4);
        }
        var r3 = n3.reduce(function(e4, t4) {
          var n4 = e4[0], r4 = e4[1], e4 = a3[t4], i3 = o3[t4];
          return [n4 || e4, n4 || !e4 ? it(r4, e4 && e4.multi ? function(e5) {
            e5 = g2(e5, t4);
            return x2(e5) && e5.some(function(e6) {
              return u3(i3, e6);
            });
          } : function(e5) {
            return u3(i3, g2(e5, t4));
          }) : r4];
        }, [null, null]), t3 = r3[0], r3 = r3[1];
        return t3 ? this.where(t3.name).equals(o3[t3.keyPath]).filter(r3) : e3 ? this.filter(r3) : this.where(n3).equals("");
      }, vt.prototype.filter = function(e3) {
        return this.toCollection().and(e3);
      }, vt.prototype.count = function(e3) {
        return this.toCollection().count(e3);
      }, vt.prototype.offset = function(e3) {
        return this.toCollection().offset(e3);
      }, vt.prototype.limit = function(e3) {
        return this.toCollection().limit(e3);
      }, vt.prototype.each = function(e3) {
        return this.toCollection().each(e3);
      }, vt.prototype.toArray = function(e3) {
        return this.toCollection().toArray(e3);
      }, vt.prototype.toCollection = function() {
        return new this.db.Collection(new this.db.WhereClause(this));
      }, vt.prototype.orderBy = function(e3) {
        return new this.db.Collection(new this.db.WhereClause(this, x2(e3) ? "[".concat(e3.join("+"), "]") : e3));
      }, vt.prototype.reverse = function() {
        return this.toCollection().reverse();
      }, vt.prototype.mapToClass = function(r3) {
        var e3, t3 = this.db, n3 = this.name;
        function i3() {
          return null !== e3 && e3.apply(this, arguments) || this;
        }
        (this.schema.mappedClass = r3).prototype instanceof ut && ((function(e4, t4) {
          if ("function" != typeof t4 && null !== t4) throw new TypeError("Class extends value " + String(t4) + " is not a constructor or null");
          function n4() {
            this.constructor = e4;
          }
          s2(e4, t4), e4.prototype = null === t4 ? Object.create(t4) : (n4.prototype = t4.prototype, new n4());
        })(i3, e3 = r3), Object.defineProperty(i3.prototype, "db", { get: function() {
          return t3;
        }, enumerable: false, configurable: true }), i3.prototype.table = function() {
          return n3;
        }, r3 = i3);
        for (var o3 = /* @__PURE__ */ new Set(), a3 = r3.prototype; a3; a3 = c2(a3)) Object.getOwnPropertyNames(a3).forEach(function(e4) {
          return o3.add(e4);
        });
        function u3(e4) {
          if (!e4) return e4;
          var t4, n4 = Object.create(r3.prototype);
          for (t4 in e4) if (!o3.has(t4)) try {
            n4[t4] = e4[t4];
          } catch (e5) {
          }
          return n4;
        }
        return this.schema.readHook && this.hook.reading.unsubscribe(this.schema.readHook), this.schema.readHook = u3, this.hook("reading", u3), r3;
      }, vt.prototype.defineClass = function() {
        return this.mapToClass(function(e3) {
          a2(this, e3);
        });
      }, vt.prototype.add = function(t3, n3) {
        var r3 = this, e3 = this.schema.primKey, i3 = e3.auto, o3 = e3.keyPath, a3 = t3;
        return o3 && i3 && (a3 = at(o3)(t3)), this._trans("readwrite", function(e4) {
          return r3.core.mutate({ trans: e4, type: "add", keys: null != n3 ? [n3] : null, values: [a3] });
        }).then(function(e4) {
          return e4.numFailures ? _e.reject(e4.failures[0]) : e4.lastResult;
        }).then(function(e4) {
          if (o3) try {
            w2(t3, o3, e4);
          } catch (e5) {
          }
          return e4;
        });
      }, vt.prototype.upsert = function(r3, i3) {
        var o3 = this, a3 = this.schema.primKey.keyPath;
        return this._trans("readwrite", function(n3) {
          return o3.core.get({ trans: n3, key: r3 }).then(function(t3) {
            var e3 = null != t3 ? t3 : {};
            return pt(e3, i3), a3 && w2(e3, a3, r3), o3.core.mutate({ trans: n3, type: "put", values: [e3], keys: [r3], upsert: true, updates: { keys: [r3], changeSpecs: [i3] } }).then(function(e4) {
              return e4.numFailures ? _e.reject(e4.failures[0]) : !!t3;
            });
          });
        });
      }, vt.prototype.update = function(e3, t3) {
        if ("object" != typeof e3 || x2(e3)) return this.where(":id").equals(e3).modify(t3);
        e3 = g2(e3, this.schema.primKey.keyPath);
        return void 0 === e3 ? Xe(new Y2.InvalidArgument("Given object does not contain its primary key")) : this.where(":id").equals(e3).modify(t3);
      }, vt.prototype.put = function(t3, n3) {
        var r3 = this, e3 = this.schema.primKey, i3 = e3.auto, o3 = e3.keyPath, a3 = t3;
        return o3 && i3 && (a3 = at(o3)(t3)), this._trans("readwrite", function(e4) {
          return r3.core.mutate({ trans: e4, type: "put", values: [a3], keys: null != n3 ? [n3] : null });
        }).then(function(e4) {
          return e4.numFailures ? _e.reject(e4.failures[0]) : e4.lastResult;
        }).then(function(e4) {
          if (o3) try {
            w2(t3, o3, e4);
          } catch (e5) {
          }
          return e4;
        });
      }, vt.prototype.delete = function(t3) {
        var n3 = this;
        return this._trans("readwrite", function(e3) {
          return n3.core.mutate({ trans: e3, type: "delete", keys: [t3] }).then(function(e4) {
            return ft(n3, [t3], e4);
          }).then(function(e4) {
            return e4.numFailures ? _e.reject(e4.failures[0]) : void 0;
          });
        });
      }, vt.prototype.clear = function() {
        var t3 = this;
        return this._trans("readwrite", function(e3) {
          return t3.core.mutate({ trans: e3, type: "deleteRange", range: ot }).then(function(e4) {
            return ft(t3, null, e4);
          });
        }).then(function(e3) {
          return e3.numFailures ? _e.reject(e3.failures[0]) : void 0;
        });
      }, vt.prototype.bulkGet = function(t3) {
        var n3 = this;
        return this._trans("readonly", function(e3) {
          return n3.core.getMany({ keys: t3, trans: e3 }).then(function(e4) {
            return e4.map(function(e5) {
              return n3.hook.reading.fire(e5);
            });
          });
        });
      }, vt.prototype.bulkAdd = function(r3, e3, t3) {
        var o3 = this, a3 = Array.isArray(e3) ? e3 : void 0, u3 = (t3 = t3 || (a3 ? void 0 : e3)) ? t3.allKeys : void 0;
        return this._trans("readwrite", function(e4) {
          var t4 = o3.schema.primKey, n3 = t4.auto, t4 = t4.keyPath;
          if (t4 && a3) throw new Y2.InvalidArgument("bulkAdd(): keys argument invalid on tables with inbound keys");
          if (a3 && a3.length !== r3.length) throw new Y2.InvalidArgument("Arguments objects and keys must have the same length");
          var i3 = r3.length, t4 = t4 && n3 ? r3.map(at(t4)) : r3;
          return o3.core.mutate({ trans: e4, type: "add", keys: a3, values: t4, wantResults: u3 }).then(function(e5) {
            var t5 = e5.numFailures, n4 = e5.results, r4 = e5.lastResult, e5 = e5.failures;
            if (0 === t5) return u3 ? n4 : r4;
            throw new V2("".concat(o3.name, ".bulkAdd(): ").concat(t5, " of ").concat(i3, " operations failed"), e5);
          });
        });
      }, vt.prototype.bulkPut = function(r3, e3, t3) {
        var o3 = this, a3 = Array.isArray(e3) ? e3 : void 0, u3 = (t3 = t3 || (a3 ? void 0 : e3)) ? t3.allKeys : void 0;
        return this._trans("readwrite", function(e4) {
          var t4 = o3.schema.primKey, n3 = t4.auto, t4 = t4.keyPath;
          if (t4 && a3) throw new Y2.InvalidArgument("bulkPut(): keys argument invalid on tables with inbound keys");
          if (a3 && a3.length !== r3.length) throw new Y2.InvalidArgument("Arguments objects and keys must have the same length");
          var i3 = r3.length, t4 = t4 && n3 ? r3.map(at(t4)) : r3;
          return o3.core.mutate({ trans: e4, type: "put", keys: a3, values: t4, wantResults: u3 }).then(function(e5) {
            var t5 = e5.numFailures, n4 = e5.results, r4 = e5.lastResult, e5 = e5.failures;
            if (0 === t5) return u3 ? n4 : r4;
            throw new V2("".concat(o3.name, ".bulkPut(): ").concat(t5, " of ").concat(i3, " operations failed"), e5);
          });
        });
      }, vt.prototype.bulkUpdate = function(t3) {
        var h3 = this, n3 = this.core, r3 = t3.map(function(e3) {
          return e3.key;
        }), i3 = t3.map(function(e3) {
          return e3.changes;
        }), d3 = [];
        return this._trans("readwrite", function(e3) {
          return n3.getMany({ trans: e3, keys: r3, cache: "clone" }).then(function(c3) {
            var l3 = [], f3 = [];
            t3.forEach(function(e4, t4) {
              var n4 = e4.key, r4 = e4.changes, i4 = c3[t4];
              if (i4) {
                for (var o3 = 0, a3 = Object.keys(r4); o3 < a3.length; o3++) {
                  var u3 = a3[o3], s4 = r4[u3];
                  if (u3 === h3.schema.primKey.keyPath) {
                    if (0 !== st(s4, n4)) throw new Y2.Constraint("Cannot update primary key in bulkUpdate()");
                  } else w2(i4, u3, s4);
                }
                d3.push(t4), l3.push(n4), f3.push(i4);
              }
            });
            var s3 = l3.length;
            return n3.mutate({ trans: e3, type: "put", keys: l3, values: f3, updates: { keys: r3, changeSpecs: i3 } }).then(function(e4) {
              var t4 = e4.numFailures, n4 = e4.failures;
              if (0 === t4) return s3;
              for (var r4 = 0, i4 = Object.keys(n4); r4 < i4.length; r4++) {
                var o3, a3 = i4[r4], u3 = d3[Number(a3)];
                null != u3 && (o3 = n4[a3], delete n4[a3], n4[u3] = o3);
              }
              throw new V2("".concat(h3.name, ".bulkUpdate(): ").concat(t4, " of ").concat(s3, " operations failed"), n4);
            });
          });
        });
      }, vt.prototype.bulkDelete = function(t3) {
        var r3 = this, i3 = t3.length;
        return this._trans("readwrite", function(e3) {
          return r3.core.mutate({ trans: e3, type: "delete", keys: t3 }).then(function(e4) {
            return ft(r3, t3, e4);
          });
        }).then(function(e3) {
          var t4 = e3.numFailures, n3 = e3.lastResult, e3 = e3.failures;
          if (0 === t4) return n3;
          throw new V2("".concat(r3.name, ".bulkDelete(): ").concat(t4, " of ").concat(i3, " operations failed"), e3);
        });
      }, vt);
      function vt() {
      }
      function mt(i3) {
        function t3(e4, t4) {
          if (t4) {
            for (var n4 = arguments.length, r3 = new Array(n4 - 1); --n4; ) r3[n4 - 1] = arguments[n4];
            return a3[e4].subscribe.apply(null, r3), i3;
          }
          if ("string" == typeof e4) return a3[e4];
        }
        var a3 = {};
        t3.addEventType = u3;
        for (var e3 = 1, n3 = arguments.length; e3 < n3; ++e3) u3(arguments[e3]);
        return t3;
        function u3(e4, n4, r3) {
          if ("object" != typeof e4) {
            var i4;
            n4 = n4 || ne;
            var o3 = { subscribers: [], fire: r3 = r3 || G2, subscribe: function(e5) {
              -1 === o3.subscribers.indexOf(e5) && (o3.subscribers.push(e5), o3.fire = n4(o3.fire, e5));
            }, unsubscribe: function(t4) {
              o3.subscribers = o3.subscribers.filter(function(e5) {
                return e5 !== t4;
              }), o3.fire = o3.subscribers.reduce(n4, r3);
            } };
            return a3[e4] = t3[e4] = o3;
          }
          O2(i4 = e4).forEach(function(e5) {
            var t4 = i4[e5];
            if (x2(t4)) u3(e5, i4[e5][0], i4[e5][1]);
            else {
              if ("asap" !== t4) throw new Y2.InvalidArgument("Invalid event config");
              var n5 = u3(e5, X2, function() {
                for (var e6 = arguments.length, t5 = new Array(e6); e6--; ) t5[e6] = arguments[e6];
                n5.subscribers.forEach(function(e7) {
                  v2(function() {
                    e7.apply(null, t5);
                  });
                });
              });
            }
          });
        }
      }
      function bt(e3, t3) {
        return o2(t3).from({ prototype: e3 }), t3;
      }
      function gt(e3, t3) {
        return !(e3.filter || e3.algorithm || e3.or) && (t3 ? e3.justLimit : !e3.replayFilter);
      }
      function wt(e3, t3) {
        e3.filter = it(e3.filter, t3);
      }
      function _t(e3, t3, n3) {
        var r3 = e3.replayFilter;
        e3.replayFilter = r3 ? function() {
          return it(r3(), t3());
        } : t3, e3.justLimit = n3 && !r3;
      }
      function xt(e3, t3) {
        if (e3.isPrimKey) return t3.primaryKey;
        var n3 = t3.getIndexByKeyPath(e3.index);
        if (!n3) throw new Y2.Schema("KeyPath " + e3.index + " on object store " + t3.name + " is not indexed");
        return n3;
      }
      function kt(e3, t3, n3) {
        var r3 = xt(e3, t3.schema);
        return t3.openCursor({ trans: n3, values: !e3.keysOnly, reverse: "prev" === e3.dir, unique: !!e3.unique, query: { index: r3, range: e3.range } });
      }
      function Ot(e3, o3, t3, n3) {
        var a3 = e3.replayFilter ? it(e3.filter, e3.replayFilter()) : e3.filter;
        if (e3.or) {
          var u3 = {}, r3 = function(e4, t4, n4) {
            var r4, i3;
            a3 && !a3(t4, n4, function(e5) {
              return t4.stop(e5);
            }, function(e5) {
              return t4.fail(e5);
            }) || ("[object ArrayBuffer]" === (i3 = "" + (r4 = t4.primaryKey)) && (i3 = "" + new Uint8Array(r4)), m2(u3, i3) || (u3[i3] = true, o3(e4, t4, n4)));
          };
          return Promise.all([e3.or._iterate(r3, t3), Pt(kt(e3, n3, t3), e3.algorithm, r3, !e3.keysOnly && e3.valueMapper)]);
        }
        return Pt(kt(e3, n3, t3), it(e3.algorithm, a3), o3, !e3.keysOnly && e3.valueMapper);
      }
      function Pt(e3, r3, i3, o3) {
        var a3 = Ie(o3 ? function(e4, t3, n3) {
          return i3(o3(e4), t3, n3);
        } : i3);
        return e3.then(function(n3) {
          if (n3) return n3.start(function() {
            var t3 = function() {
              return n3.continue();
            };
            r3 && !r3(n3, function(e4) {
              return t3 = e4;
            }, function(e4) {
              n3.stop(e4), t3 = G2;
            }, function(e4) {
              n3.fail(e4), t3 = G2;
            }) || a3(n3.value, n3, function(e4) {
              return t3 = e4;
            }), t3();
          });
        });
      }
      var Kt = (Et.prototype._read = function(e3, t3) {
        var n3 = this._ctx;
        return n3.error ? n3.table._trans(null, Xe.bind(null, n3.error)) : n3.table._trans("readonly", e3).then(t3);
      }, Et.prototype._write = function(e3) {
        var t3 = this._ctx;
        return t3.error ? t3.table._trans(null, Xe.bind(null, t3.error)) : t3.table._trans("readwrite", e3, "locked");
      }, Et.prototype._addAlgorithm = function(e3) {
        var t3 = this._ctx;
        t3.algorithm = it(t3.algorithm, e3);
      }, Et.prototype._iterate = function(e3, t3) {
        return Ot(this._ctx, e3, t3, this._ctx.table.core);
      }, Et.prototype.clone = function(e3) {
        var t3 = Object.create(this.constructor.prototype), n3 = Object.create(this._ctx);
        return e3 && a2(n3, e3), t3._ctx = n3, t3;
      }, Et.prototype.raw = function() {
        return this._ctx.valueMapper = null, this;
      }, Et.prototype.each = function(t3) {
        var n3 = this._ctx;
        return this._read(function(e3) {
          return Ot(n3, t3, e3, n3.table.core);
        });
      }, Et.prototype.count = function(e3) {
        var i3 = this;
        return this._read(function(e4) {
          var t3 = i3._ctx, n3 = t3.table.core;
          if (gt(t3, true)) return n3.count({ trans: e4, query: { index: xt(t3, n3.schema), range: t3.range } }).then(function(e5) {
            return Math.min(e5, t3.limit);
          });
          var r3 = 0;
          return Ot(t3, function() {
            return ++r3, false;
          }, e4, n3).then(function() {
            return r3;
          });
        }).then(e3);
      }, Et.prototype.sortBy = function(e3, t3) {
        var n3 = e3.split(".").reverse(), r3 = n3[0], i3 = n3.length - 1;
        function o3(e4, t4) {
          return t4 ? o3(e4[n3[t4]], t4 - 1) : e4[r3];
        }
        var a3 = "next" === this._ctx.dir ? 1 : -1;
        function u3(e4, t4) {
          return st(o3(e4, i3), o3(t4, i3)) * a3;
        }
        return this.toArray(function(e4) {
          return e4.sort(u3);
        }).then(t3);
      }, Et.prototype.toArray = function(e3) {
        var o3 = this;
        return this._read(function(e4) {
          var t3 = o3._ctx;
          if ("next" === t3.dir && gt(t3, true) && 0 < t3.limit) {
            var n3 = t3.valueMapper, r3 = xt(t3, t3.table.core.schema);
            return t3.table.core.query({ trans: e4, limit: t3.limit, values: true, query: { index: r3, range: t3.range } }).then(function(e5) {
              e5 = e5.result;
              return n3 ? e5.map(n3) : e5;
            });
          }
          var i3 = [];
          return Ot(t3, function(e5) {
            return i3.push(e5);
          }, e4, t3.table.core).then(function() {
            return i3;
          });
        }, e3);
      }, Et.prototype.offset = function(t3) {
        var e3 = this._ctx;
        return t3 <= 0 || (e3.offset += t3, gt(e3) ? _t(e3, function() {
          var n3 = t3;
          return function(e4, t4) {
            return 0 === n3 || (1 === n3 ? --n3 : t4(function() {
              e4.advance(n3), n3 = 0;
            }), false);
          };
        }) : _t(e3, function() {
          var e4 = t3;
          return function() {
            return --e4 < 0;
          };
        })), this;
      }, Et.prototype.limit = function(e3) {
        return this._ctx.limit = Math.min(this._ctx.limit, e3), _t(this._ctx, function() {
          var r3 = e3;
          return function(e4, t3, n3) {
            return --r3 <= 0 && t3(n3), 0 <= r3;
          };
        }, true), this;
      }, Et.prototype.until = function(r3, i3) {
        return wt(this._ctx, function(e3, t3, n3) {
          return !r3(e3.value) || (t3(n3), i3);
        }), this;
      }, Et.prototype.first = function(e3) {
        return this.limit(1).toArray(function(e4) {
          return e4[0];
        }).then(e3);
      }, Et.prototype.last = function(e3) {
        return this.reverse().first(e3);
      }, Et.prototype.filter = function(t3) {
        var e3;
        return wt(this._ctx, function(e4) {
          return t3(e4.value);
        }), (e3 = this._ctx).isMatch = it(e3.isMatch, t3), this;
      }, Et.prototype.and = function(e3) {
        return this.filter(e3);
      }, Et.prototype.or = function(e3) {
        return new this.db.WhereClause(this._ctx.table, e3, this);
      }, Et.prototype.reverse = function() {
        return this._ctx.dir = "prev" === this._ctx.dir ? "next" : "prev", this._ondirectionchange && this._ondirectionchange(this._ctx.dir), this;
      }, Et.prototype.desc = function() {
        return this.reverse();
      }, Et.prototype.eachKey = function(n3) {
        var e3 = this._ctx;
        return e3.keysOnly = !e3.isMatch, this.each(function(e4, t3) {
          n3(t3.key, t3);
        });
      }, Et.prototype.eachUniqueKey = function(e3) {
        return this._ctx.unique = "unique", this.eachKey(e3);
      }, Et.prototype.eachPrimaryKey = function(n3) {
        var e3 = this._ctx;
        return e3.keysOnly = !e3.isMatch, this.each(function(e4, t3) {
          n3(t3.primaryKey, t3);
        });
      }, Et.prototype.keys = function(e3) {
        var t3 = this._ctx;
        t3.keysOnly = !t3.isMatch;
        var n3 = [];
        return this.each(function(e4, t4) {
          n3.push(t4.key);
        }).then(function() {
          return n3;
        }).then(e3);
      }, Et.prototype.primaryKeys = function(e3) {
        var n3 = this._ctx;
        if ("next" === n3.dir && gt(n3, true) && 0 < n3.limit) return this._read(function(e4) {
          var t3 = xt(n3, n3.table.core.schema);
          return n3.table.core.query({ trans: e4, values: false, limit: n3.limit, query: { index: t3, range: n3.range } });
        }).then(function(e4) {
          return e4.result;
        }).then(e3);
        n3.keysOnly = !n3.isMatch;
        var r3 = [];
        return this.each(function(e4, t3) {
          r3.push(t3.primaryKey);
        }).then(function() {
          return r3;
        }).then(e3);
      }, Et.prototype.uniqueKeys = function(e3) {
        return this._ctx.unique = "unique", this.keys(e3);
      }, Et.prototype.firstKey = function(e3) {
        return this.limit(1).keys(function(e4) {
          return e4[0];
        }).then(e3);
      }, Et.prototype.lastKey = function(e3) {
        return this.reverse().firstKey(e3);
      }, Et.prototype.distinct = function() {
        var e3 = this._ctx, e3 = e3.index && e3.table.schema.idxByName[e3.index];
        if (!e3 || !e3.multi) return this;
        var n3 = {};
        return wt(this._ctx, function(e4) {
          var t3 = e4.primaryKey.toString(), e4 = m2(n3, t3);
          return n3[t3] = true, !e4;
        }), this;
      }, Et.prototype.modify = function(x3) {
        var n3 = this, k3 = this._ctx;
        return this._write(function(p3) {
          var y3 = "function" == typeof x3 ? x3 : function(e4) {
            return pt(e4, x3);
          }, v3 = k3.table.core, e3 = v3.schema.primaryKey, m3 = e3.outbound, b3 = e3.extractKey, g3 = 200, e3 = n3.db._options.modifyChunkSize;
          e3 && (g3 = "object" == typeof e3 ? e3[v3.name] || e3["*"] || 200 : e3);
          function w3(e4, t4) {
            var n4 = t4.failures, t4 = t4.numFailures;
            u3 += e4 - t4;
            for (var r3 = 0, i3 = O2(n4); r3 < i3.length; r3++) {
              var o3 = i3[r3];
              a3.push(n4[o3]);
            }
          }
          var a3 = [], u3 = 0, t3 = [], _3 = x3 === St;
          return n3.clone().primaryKeys().then(function(f3) {
            function h3(s3) {
              var c3 = Math.min(g3, f3.length - s3), l3 = f3.slice(s3, s3 + c3);
              return (_3 ? Promise.resolve([]) : v3.getMany({ trans: p3, keys: l3, cache: "immutable" })).then(function(e4) {
                var n4 = [], t4 = [], r3 = m3 ? [] : null, i3 = _3 ? l3 : [];
                if (!_3) for (var o3 = 0; o3 < c3; ++o3) {
                  var a4 = e4[o3], u4 = { value: S2(a4), primKey: f3[s3 + o3] };
                  false !== y3.call(u4, u4.value, u4) && (null == u4.value ? i3.push(f3[s3 + o3]) : m3 || 0 === st(b3(a4), b3(u4.value)) ? (t4.push(u4.value), m3 && r3.push(f3[s3 + o3])) : (i3.push(f3[s3 + o3]), n4.push(u4.value)));
                }
                return Promise.resolve(0 < n4.length && v3.mutate({ trans: p3, type: "add", values: n4 }).then(function(e5) {
                  for (var t5 in e5.failures) i3.splice(parseInt(t5), 1);
                  w3(n4.length, e5);
                })).then(function() {
                  return (0 < t4.length || d3 && "object" == typeof x3) && v3.mutate({ trans: p3, type: "put", keys: r3, values: t4, criteria: d3, changeSpec: "function" != typeof x3 && x3, isAdditionalChunk: 0 < s3 }).then(function(e5) {
                    return w3(t4.length, e5);
                  });
                }).then(function() {
                  return (0 < i3.length || d3 && _3) && v3.mutate({ trans: p3, type: "delete", keys: i3, criteria: d3, isAdditionalChunk: 0 < s3 }).then(function(e5) {
                    return ft(k3.table, i3, e5);
                  }).then(function(e5) {
                    return w3(i3.length, e5);
                  });
                }).then(function() {
                  return f3.length > s3 + c3 && h3(s3 + g3);
                });
              });
            }
            var d3 = gt(k3) && k3.limit === 1 / 0 && ("function" != typeof x3 || _3) && { index: k3.index, range: k3.range };
            return h3(0).then(function() {
              if (0 < a3.length) throw new U2("Error modifying one or more objects", a3, u3, t3);
              return f3.length;
            });
          });
        });
      }, Et.prototype.delete = function() {
        var i3 = this._ctx, n3 = i3.range;
        return !gt(i3) || i3.table.schema.yProps || !i3.isPrimKey && 3 !== n3.type ? this.modify(St) : this._write(function(e3) {
          var t3 = i3.table.core.schema.primaryKey, r3 = n3;
          return i3.table.core.count({ trans: e3, query: { index: t3, range: r3 } }).then(function(n4) {
            return i3.table.core.mutate({ trans: e3, type: "deleteRange", range: r3 }).then(function(e4) {
              var t4 = e4.failures, e4 = e4.numFailures;
              if (e4) throw new U2("Could not delete some values", Object.keys(t4).map(function(e5) {
                return t4[e5];
              }), n4 - e4);
              return n4 - e4;
            });
          });
        });
      }, Et);
      function Et() {
      }
      var St = function(e3, t3) {
        return t3.value = null;
      };
      function jt(e3, t3) {
        return e3 < t3 ? -1 : e3 === t3 ? 0 : 1;
      }
      function At(e3, t3) {
        return t3 < e3 ? -1 : e3 === t3 ? 0 : 1;
      }
      function Ct(e3, t3, n3) {
        e3 = e3 instanceof Bt ? new e3.Collection(e3) : e3;
        return e3._ctx.error = new (n3 || TypeError)(t3), e3;
      }
      function Tt(e3) {
        return new e3.Collection(e3, function() {
          return Dt("");
        }).limit(0);
      }
      function It(e3, s3, n3, r3) {
        var i3, c3, l3, f3, h3, d3, p3, y3 = n3.length;
        if (!n3.every(function(e4) {
          return "string" == typeof e4;
        })) return Ct(e3, Ze);
        function t3(e4) {
          i3 = "next" === e4 ? function(e5) {
            return e5.toUpperCase();
          } : function(e5) {
            return e5.toLowerCase();
          }, c3 = "next" === e4 ? function(e5) {
            return e5.toLowerCase();
          } : function(e5) {
            return e5.toUpperCase();
          }, l3 = "next" === e4 ? jt : At;
          var t4 = n3.map(function(e5) {
            return { lower: c3(e5), upper: i3(e5) };
          }).sort(function(e5, t5) {
            return l3(e5.lower, t5.lower);
          });
          f3 = t4.map(function(e5) {
            return e5.upper;
          }), h3 = t4.map(function(e5) {
            return e5.lower;
          }), p3 = "next" === (d3 = e4) ? "" : r3;
        }
        t3("next");
        e3 = new e3.Collection(e3, function() {
          return qt(f3[0], h3[y3 - 1] + r3);
        });
        e3._ondirectionchange = function(e4) {
          t3(e4);
        };
        var v3 = 0;
        return e3._addAlgorithm(function(e4, t4, n4) {
          var r4 = e4.key;
          if ("string" != typeof r4) return false;
          var i4 = c3(r4);
          if (s3(i4, h3, v3)) return true;
          for (var o3 = null, a3 = v3; a3 < y3; ++a3) {
            var u3 = (function(e5, t5, n5, r5, i5, o4) {
              for (var a4 = Math.min(e5.length, r5.length), u4 = -1, s4 = 0; s4 < a4; ++s4) {
                var c4 = t5[s4];
                if (c4 !== r5[s4]) return i5(e5[s4], n5[s4]) < 0 ? e5.substr(0, s4) + n5[s4] + n5.substr(s4 + 1) : i5(e5[s4], r5[s4]) < 0 ? e5.substr(0, s4) + r5[s4] + n5.substr(s4 + 1) : 0 <= u4 ? e5.substr(0, u4) + t5[u4] + n5.substr(u4 + 1) : null;
                i5(e5[s4], c4) < 0 && (u4 = s4);
              }
              return a4 < r5.length && "next" === o4 ? e5 + n5.substr(e5.length) : a4 < e5.length && "prev" === o4 ? e5.substr(0, n5.length) : u4 < 0 ? null : e5.substr(0, u4) + r5[u4] + n5.substr(u4 + 1);
            })(r4, i4, f3[a3], h3[a3], l3, d3);
            null === u3 && null === o3 ? v3 = a3 + 1 : (null === o3 || 0 < l3(o3, u3)) && (o3 = u3);
          }
          return t4(null !== o3 ? function() {
            e4.continue(o3 + p3);
          } : n4), false;
        }), e3;
      }
      function qt(e3, t3, n3, r3) {
        return { type: 2, lower: e3, upper: t3, lowerOpen: n3, upperOpen: r3 };
      }
      function Dt(e3) {
        return { type: 1, lower: e3, upper: e3 };
      }
      var Bt = (Object.defineProperty(Rt.prototype, "Collection", { get: function() {
        return this._ctx.table.db.Collection;
      }, enumerable: false, configurable: true }), Rt.prototype.between = function(e3, t3, n3, r3) {
        n3 = false !== n3, r3 = true === r3;
        try {
          return 0 < this._cmp(e3, t3) || 0 === this._cmp(e3, t3) && (n3 || r3) && (!n3 || !r3) ? Tt(this) : new this.Collection(this, function() {
            return qt(e3, t3, !n3, !r3);
          });
        } catch (e4) {
          return Ct(this, Je);
        }
      }, Rt.prototype.equals = function(e3) {
        return null == e3 ? Ct(this, Je) : new this.Collection(this, function() {
          return Dt(e3);
        });
      }, Rt.prototype.above = function(e3) {
        return null == e3 ? Ct(this, Je) : new this.Collection(this, function() {
          return qt(e3, void 0, true);
        });
      }, Rt.prototype.aboveOrEqual = function(e3) {
        return null == e3 ? Ct(this, Je) : new this.Collection(this, function() {
          return qt(e3, void 0, false);
        });
      }, Rt.prototype.below = function(e3) {
        return null == e3 ? Ct(this, Je) : new this.Collection(this, function() {
          return qt(void 0, e3, false, true);
        });
      }, Rt.prototype.belowOrEqual = function(e3) {
        return null == e3 ? Ct(this, Je) : new this.Collection(this, function() {
          return qt(void 0, e3);
        });
      }, Rt.prototype.startsWith = function(e3) {
        return "string" != typeof e3 ? Ct(this, Ze) : this.between(e3, e3 + He, true, true);
      }, Rt.prototype.startsWithIgnoreCase = function(e3) {
        return "" === e3 ? this.startsWith(e3) : It(this, function(e4, t3) {
          return 0 === e4.indexOf(t3[0]);
        }, [e3], He);
      }, Rt.prototype.equalsIgnoreCase = function(e3) {
        return It(this, function(e4, t3) {
          return e4 === t3[0];
        }, [e3], "");
      }, Rt.prototype.anyOfIgnoreCase = function() {
        var e3 = D2.apply(q2, arguments);
        return 0 === e3.length ? Tt(this) : It(this, function(e4, t3) {
          return -1 !== t3.indexOf(e4);
        }, e3, "");
      }, Rt.prototype.startsWithAnyOfIgnoreCase = function() {
        var e3 = D2.apply(q2, arguments);
        return 0 === e3.length ? Tt(this) : It(this, function(t3, e4) {
          return e4.some(function(e5) {
            return 0 === t3.indexOf(e5);
          });
        }, e3, He);
      }, Rt.prototype.anyOf = function() {
        var t3 = this, i3 = D2.apply(q2, arguments), o3 = this._cmp;
        try {
          i3.sort(o3);
        } catch (e4) {
          return Ct(this, Je);
        }
        if (0 === i3.length) return Tt(this);
        var e3 = new this.Collection(this, function() {
          return qt(i3[0], i3[i3.length - 1]);
        });
        e3._ondirectionchange = function(e4) {
          o3 = "next" === e4 ? t3._ascending : t3._descending, i3.sort(o3);
        };
        var a3 = 0;
        return e3._addAlgorithm(function(e4, t4, n3) {
          for (var r3 = e4.key; 0 < o3(r3, i3[a3]); ) if (++a3 === i3.length) return t4(n3), false;
          return 0 === o3(r3, i3[a3]) || (t4(function() {
            e4.continue(i3[a3]);
          }), false);
        }), e3;
      }, Rt.prototype.notEqual = function(e3) {
        return this.inAnyRange([[-1 / 0, e3], [e3, this.db._maxKey]], { includeLowers: false, includeUppers: false });
      }, Rt.prototype.noneOf = function() {
        var e3 = D2.apply(q2, arguments);
        if (0 === e3.length) return new this.Collection(this);
        try {
          e3.sort(this._ascending);
        } catch (e4) {
          return Ct(this, Je);
        }
        var t3 = e3.reduce(function(e4, t4) {
          return e4 ? e4.concat([[e4[e4.length - 1][1], t4]]) : [[-1 / 0, t4]];
        }, null);
        return t3.push([e3[e3.length - 1], this.db._maxKey]), this.inAnyRange(t3, { includeLowers: false, includeUppers: false });
      }, Rt.prototype.inAnyRange = function(e3, t3) {
        var o3 = this, a3 = this._cmp, u3 = this._ascending, n3 = this._descending, s3 = this._min, c3 = this._max;
        if (0 === e3.length) return Tt(this);
        if (!e3.every(function(e4) {
          return void 0 !== e4[0] && void 0 !== e4[1] && u3(e4[0], e4[1]) <= 0;
        })) return Ct(this, "First argument to inAnyRange() must be an Array of two-value Arrays [lower,upper] where upper must not be lower than lower", Y2.InvalidArgument);
        var r3 = !t3 || false !== t3.includeLowers, i3 = t3 && true === t3.includeUppers;
        var l3, f3 = u3;
        function h3(e4, t4) {
          return f3(e4[0], t4[0]);
        }
        try {
          (l3 = e3.reduce(function(e4, t4) {
            for (var n4 = 0, r4 = e4.length; n4 < r4; ++n4) {
              var i4 = e4[n4];
              if (a3(t4[0], i4[1]) < 0 && 0 < a3(t4[1], i4[0])) {
                i4[0] = s3(i4[0], t4[0]), i4[1] = c3(i4[1], t4[1]);
                break;
              }
            }
            return n4 === r4 && e4.push(t4), e4;
          }, [])).sort(h3);
        } catch (e4) {
          return Ct(this, Je);
        }
        var d3 = 0, p3 = i3 ? function(e4) {
          return 0 < u3(e4, l3[d3][1]);
        } : function(e4) {
          return 0 <= u3(e4, l3[d3][1]);
        }, y3 = r3 ? function(e4) {
          return 0 < n3(e4, l3[d3][0]);
        } : function(e4) {
          return 0 <= n3(e4, l3[d3][0]);
        };
        var v3 = p3, e3 = new this.Collection(this, function() {
          return qt(l3[0][0], l3[l3.length - 1][1], !r3, !i3);
        });
        return e3._ondirectionchange = function(e4) {
          f3 = "next" === e4 ? (v3 = p3, u3) : (v3 = y3, n3), l3.sort(h3);
        }, e3._addAlgorithm(function(e4, t4, n4) {
          for (var r4, i4 = e4.key; v3(i4); ) if (++d3 === l3.length) return t4(n4), false;
          return !p3(r4 = i4) && !y3(r4) || (0 === o3._cmp(i4, l3[d3][1]) || 0 === o3._cmp(i4, l3[d3][0]) || t4(function() {
            f3 === u3 ? e4.continue(l3[d3][0]) : e4.continue(l3[d3][1]);
          }), false);
        }), e3;
      }, Rt.prototype.startsWithAnyOf = function() {
        var e3 = D2.apply(q2, arguments);
        return e3.every(function(e4) {
          return "string" == typeof e4;
        }) ? 0 === e3.length ? Tt(this) : this.inAnyRange(e3.map(function(e4) {
          return [e4, e4 + He];
        })) : Ct(this, "startsWithAnyOf() only works with strings");
      }, Rt);
      function Rt() {
      }
      function Ft(t3) {
        return Ie(function(e3) {
          return Mt(e3), t3(e3.target.error), false;
        });
      }
      function Mt(e3) {
        e3.stopPropagation && e3.stopPropagation(), e3.preventDefault && e3.preventDefault();
      }
      var Nt = "storagemutated", Lt = "x-storagemutated-1", Ut = mt(null, Nt), Vt = (zt.prototype._lock = function() {
        return y2(!me.global), ++this._reculock, 1 !== this._reculock || me.global || (me.lockOwnerFor = this), this;
      }, zt.prototype._unlock = function() {
        if (y2(!me.global), 0 == --this._reculock) for (me.global || (me.lockOwnerFor = null); 0 < this._blockedFuncs.length && !this._locked(); ) {
          var e3 = this._blockedFuncs.shift();
          try {
            $e(e3[1], e3[0]);
          } catch (e4) {
          }
        }
        return this;
      }, zt.prototype._locked = function() {
        return this._reculock && me.lockOwnerFor !== this;
      }, zt.prototype.create = function(t3) {
        var n3 = this;
        if (!this.mode) return this;
        var e3 = this.db.idbdb, r3 = this.db._state.dbOpenError;
        if (y2(!this.idbtrans), !t3 && !e3) switch (r3 && r3.name) {
          case "DatabaseClosedError":
            throw new Y2.DatabaseClosed(r3);
          case "MissingAPIError":
            throw new Y2.MissingAPI(r3.message, r3);
          default:
            throw new Y2.OpenFailed(r3);
        }
        if (!this.active) throw new Y2.TransactionInactive();
        return y2(null === this._completion._state), (t3 = this.idbtrans = t3 || (this.db.core || e3).transaction(this.storeNames, this.mode, { durability: this.chromeTransactionDurability })).onerror = Ie(function(e4) {
          Mt(e4), n3._reject(t3.error);
        }), t3.onabort = Ie(function(e4) {
          Mt(e4), n3.active && n3._reject(new Y2.Abort(t3.error)), n3.active = false, n3.on("abort").fire(e4);
        }), t3.oncomplete = Ie(function() {
          n3.active = false, n3._resolve(), "mutatedParts" in t3 && Ut.storagemutated.fire(t3.mutatedParts);
        }), this;
      }, zt.prototype._promise = function(n3, r3, i3) {
        var o3 = this;
        if ("readwrite" === n3 && "readwrite" !== this.mode) return Xe(new Y2.ReadOnly("Transaction is readonly"));
        if (!this.active) return Xe(new Y2.TransactionInactive());
        if (this._locked()) return new _e(function(e4, t3) {
          o3._blockedFuncs.push([function() {
            o3._promise(n3, r3, i3).then(e4, t3);
          }, me]);
        });
        if (i3) return Ne(function() {
          var e4 = new _e(function(e5, t3) {
            o3._lock();
            var n4 = r3(e5, t3, o3);
            n4 && n4.then && n4.then(e5, t3);
          });
          return e4.finally(function() {
            return o3._unlock();
          }), e4._lib = true, e4;
        });
        var e3 = new _e(function(e4, t3) {
          var n4 = r3(e4, t3, o3);
          n4 && n4.then && n4.then(e4, t3);
        });
        return e3._lib = true, e3;
      }, zt.prototype._root = function() {
        return this.parent ? this.parent._root() : this;
      }, zt.prototype.waitFor = function(e3) {
        var t3, r3 = this._root(), i3 = _e.resolve(e3);
        r3._waitingFor ? r3._waitingFor = r3._waitingFor.then(function() {
          return i3;
        }) : (r3._waitingFor = i3, r3._waitingQueue = [], t3 = r3.idbtrans.objectStore(r3.storeNames[0]), (function e4() {
          for (++r3._spinCount; r3._waitingQueue.length; ) r3._waitingQueue.shift()();
          r3._waitingFor && (t3.get(-1 / 0).onsuccess = e4);
        })());
        var o3 = r3._waitingFor;
        return new _e(function(t4, n3) {
          i3.then(function(e4) {
            return r3._waitingQueue.push(Ie(t4.bind(null, e4)));
          }, function(e4) {
            return r3._waitingQueue.push(Ie(n3.bind(null, e4)));
          }).finally(function() {
            r3._waitingFor === o3 && (r3._waitingFor = null);
          });
        });
      }, zt.prototype.abort = function() {
        this.active && (this.active = false, this.idbtrans && this.idbtrans.abort(), this._reject(new Y2.Abort()));
      }, zt.prototype.table = function(e3) {
        var t3 = this._memoizedTables || (this._memoizedTables = {});
        if (m2(t3, e3)) return t3[e3];
        var n3 = this.schema[e3];
        if (!n3) throw new Y2.NotFound("Table " + e3 + " not part of transaction");
        n3 = new this.db.Table(e3, n3, this);
        return n3.core = this.db.core.table(e3), t3[e3] = n3;
      }, zt);
      function zt() {
      }
      function Wt(e3, t3, n3, r3, i3, o3, a3, u3) {
        return { name: e3, keyPath: t3, unique: n3, multi: r3, auto: i3, compound: o3, src: (n3 && !a3 ? "&" : "") + (r3 ? "*" : "") + (i3 ? "++" : "") + Yt(t3), type: u3 };
      }
      function Yt(e3) {
        return "string" == typeof e3 ? e3 : e3 ? "[" + [].join.call(e3, "+") + "]" : "";
      }
      function $t(e3, t3, n3) {
        return { name: e3, primKey: t3, indexes: n3, mappedClass: null, idxByName: (r3 = function(e4) {
          return [e4.name, e4];
        }, n3.reduce(function(e4, t4, n4) {
          n4 = r3(t4, n4);
          return n4 && (e4[n4[0]] = n4[1]), e4;
        }, {})) };
        var r3;
      }
      var Qt = function(e3) {
        try {
          return e3.only([[]]), Qt = function() {
            return [[]];
          }, [[]];
        } catch (e4) {
          return Qt = function() {
            return He;
          }, He;
        }
      };
      function Gt(t3) {
        return null == t3 ? function() {
        } : "string" == typeof t3 ? 1 === (n3 = t3).split(".").length ? function(e3) {
          return e3[n3];
        } : function(e3) {
          return g2(e3, n3);
        } : function(e3) {
          return g2(e3, t3);
        };
        var n3;
      }
      function Xt(e3) {
        return [].slice.call(e3);
      }
      var Ht = 0;
      function Jt(e3) {
        return null == e3 ? ":id" : "string" == typeof e3 ? e3 : "[".concat(e3.join("+"), "]");
      }
      function Zt(e3, i3, t3) {
        function _3(e4) {
          if (3 === e4.type) return null;
          if (4 === e4.type) throw new Error("Cannot convert never type to IDBKeyRange");
          var t4 = e4.lower, n4 = e4.upper, r4 = e4.lowerOpen, e4 = e4.upperOpen;
          return void 0 === t4 ? void 0 === n4 ? null : i3.upperBound(n4, !!e4) : void 0 === n4 ? i3.lowerBound(t4, !!r4) : i3.bound(t4, n4, !!r4, !!e4);
        }
        function n3(e4) {
          var h3, w3 = e4.name;
          return { name: w3, schema: e4, mutate: function(e5) {
            var y3 = e5.trans, v3 = e5.type, m3 = e5.keys, b3 = e5.values, g3 = e5.range;
            return new Promise(function(t4, e6) {
              t4 = Ie(t4);
              var n4 = y3.objectStore(w3), r4 = null == n4.keyPath, i4 = "put" === v3 || "add" === v3;
              if (!i4 && "delete" !== v3 && "deleteRange" !== v3) throw new Error("Invalid operation type: " + v3);
              var o4, a4 = (m3 || b3 || { length: 1 }).length;
              if (m3 && b3 && m3.length !== b3.length) throw new Error("Given keys array must have same length as given values array.");
              if (0 === a4) return t4({ numFailures: 0, failures: {}, results: [], lastResult: void 0 });
              function u4(e7) {
                ++l3, Mt(e7);
              }
              var s4 = [], c4 = [], l3 = 0;
              if ("deleteRange" === v3) {
                if (4 === g3.type) return t4({ numFailures: l3, failures: c4, results: [], lastResult: void 0 });
                3 === g3.type ? s4.push(o4 = n4.clear()) : s4.push(o4 = n4.delete(_3(g3)));
              } else {
                var r4 = i4 ? r4 ? [b3, m3] : [b3, null] : [m3, null], f3 = r4[0], h4 = r4[1];
                if (i4) for (var d3 = 0; d3 < a4; ++d3) s4.push(o4 = h4 && void 0 !== h4[d3] ? n4[v3](f3[d3], h4[d3]) : n4[v3](f3[d3])), o4.onerror = u4;
                else for (d3 = 0; d3 < a4; ++d3) s4.push(o4 = n4[v3](f3[d3])), o4.onerror = u4;
              }
              function p3(e7) {
                e7 = e7.target.result, s4.forEach(function(e8, t5) {
                  return null != e8.error && (c4[t5] = e8.error);
                }), t4({ numFailures: l3, failures: c4, results: "delete" === v3 ? m3 : s4.map(function(e8) {
                  return e8.result;
                }), lastResult: e7 });
              }
              o4.onerror = function(e7) {
                u4(e7), p3(e7);
              }, o4.onsuccess = p3;
            });
          }, getMany: function(e5) {
            var f3 = e5.trans, h4 = e5.keys;
            return new Promise(function(t4, e6) {
              t4 = Ie(t4);
              for (var n4, r4 = f3.objectStore(w3), i4 = h4.length, o4 = new Array(i4), a4 = 0, u4 = 0, s4 = function(e7) {
                e7 = e7.target;
                o4[e7._pos] = e7.result, ++u4 === a4 && t4(o4);
              }, c4 = Ft(e6), l3 = 0; l3 < i4; ++l3) null != h4[l3] && ((n4 = r4.get(h4[l3]))._pos = l3, n4.onsuccess = s4, n4.onerror = c4, ++a4);
              0 === a4 && t4(o4);
            });
          }, get: function(e5) {
            var r4 = e5.trans, i4 = e5.key;
            return new Promise(function(t4, e6) {
              t4 = Ie(t4);
              var n4 = r4.objectStore(w3).get(i4);
              n4.onsuccess = function(e7) {
                return t4(e7.target.result);
              }, n4.onerror = Ft(e6);
            });
          }, query: (h3 = s3, function(f3) {
            return new Promise(function(n4, e5) {
              n4 = Ie(n4);
              var r4, i4, o4, t4 = f3.trans, a4 = f3.values, u4 = f3.limit, s4 = f3.query, c4 = u4 === 1 / 0 ? void 0 : u4, l3 = s4.index, s4 = s4.range, t4 = t4.objectStore(w3), l3 = l3.isPrimaryKey ? t4 : t4.index(l3.name), s4 = _3(s4);
              if (0 === u4) return n4({ result: [] });
              h3 ? ((c4 = a4 ? l3.getAll(s4, c4) : l3.getAllKeys(s4, c4)).onsuccess = function(e6) {
                return n4({ result: e6.target.result });
              }, c4.onerror = Ft(e5)) : (r4 = 0, i4 = !a4 && "openKeyCursor" in l3 ? l3.openKeyCursor(s4) : l3.openCursor(s4), o4 = [], i4.onsuccess = function(e6) {
                var t5 = i4.result;
                return t5 ? (o4.push(a4 ? t5.value : t5.primaryKey), ++r4 === u4 ? n4({ result: o4 }) : void t5.continue()) : n4({ result: o4 });
              }, i4.onerror = Ft(e5));
            });
          }), openCursor: function(e5) {
            var c4 = e5.trans, o4 = e5.values, a4 = e5.query, u4 = e5.reverse, l3 = e5.unique;
            return new Promise(function(t4, n4) {
              t4 = Ie(t4);
              var e6 = a4.index, r4 = a4.range, i4 = c4.objectStore(w3), i4 = e6.isPrimaryKey ? i4 : i4.index(e6.name), e6 = u4 ? l3 ? "prevunique" : "prev" : l3 ? "nextunique" : "next", s4 = !o4 && "openKeyCursor" in i4 ? i4.openKeyCursor(_3(r4), e6) : i4.openCursor(_3(r4), e6);
              s4.onerror = Ft(n4), s4.onsuccess = Ie(function(e7) {
                var r5, i5, o5, a5, u5 = s4.result;
                u5 ? (u5.___id = ++Ht, u5.done = false, r5 = u5.continue.bind(u5), i5 = (i5 = u5.continuePrimaryKey) && i5.bind(u5), o5 = u5.advance.bind(u5), a5 = function() {
                  throw new Error("Cursor not stopped");
                }, u5.trans = c4, u5.stop = u5.continue = u5.continuePrimaryKey = u5.advance = function() {
                  throw new Error("Cursor not started");
                }, u5.fail = Ie(n4), u5.next = function() {
                  var e8 = this, t5 = 1;
                  return this.start(function() {
                    return t5-- ? e8.continue() : e8.stop();
                  }).then(function() {
                    return e8;
                  });
                }, u5.start = function(e8) {
                  function t5() {
                    if (s4.result) try {
                      e8();
                    } catch (e9) {
                      u5.fail(e9);
                    }
                    else u5.done = true, u5.start = function() {
                      throw new Error("Cursor behind last entry");
                    }, u5.stop();
                  }
                  var n5 = new Promise(function(t6, e9) {
                    t6 = Ie(t6), s4.onerror = Ft(e9), u5.fail = e9, u5.stop = function(e10) {
                      u5.stop = u5.continue = u5.continuePrimaryKey = u5.advance = a5, t6(e10);
                    };
                  });
                  return s4.onsuccess = Ie(function(e9) {
                    s4.onsuccess = t5, t5();
                  }), u5.continue = r5, u5.continuePrimaryKey = i5, u5.advance = o5, t5(), n5;
                }, t4(u5)) : t4(null);
              }, n4);
            });
          }, count: function(e5) {
            var t4 = e5.query, i4 = e5.trans, o4 = t4.index, a4 = t4.range;
            return new Promise(function(t5, e6) {
              var n4 = i4.objectStore(w3), r4 = o4.isPrimaryKey ? n4 : n4.index(o4.name), n4 = _3(a4), r4 = n4 ? r4.count(n4) : r4.count();
              r4.onsuccess = Ie(function(e7) {
                return t5(e7.target.result);
              }), r4.onerror = Ft(e6);
            });
          } };
        }
        var r3, o3, a3, u3 = (o3 = t3, a3 = Xt((r3 = e3).objectStoreNames), { schema: { name: r3.name, tables: a3.map(function(e4) {
          return o3.objectStore(e4);
        }).map(function(t4) {
          var e4 = t4.keyPath, n4 = t4.autoIncrement, r4 = x2(e4), i4 = {}, n4 = { name: t4.name, primaryKey: { name: null, isPrimaryKey: true, outbound: null == e4, compound: r4, keyPath: e4, autoIncrement: n4, unique: true, extractKey: Gt(e4) }, indexes: Xt(t4.indexNames).map(function(e5) {
            return t4.index(e5);
          }).map(function(e5) {
            var t5 = e5.name, n5 = e5.unique, r5 = e5.multiEntry, e5 = e5.keyPath, r5 = { name: t5, compound: x2(e5), keyPath: e5, unique: n5, multiEntry: r5, extractKey: Gt(e5) };
            return i4[Jt(e5)] = r5;
          }), getIndexByKeyPath: function(e5) {
            return i4[Jt(e5)];
          } };
          return i4[":id"] = n4.primaryKey, null != e4 && (i4[Jt(e4)] = n4.primaryKey), n4;
        }) }, hasGetAll: 0 < a3.length && "getAll" in o3.objectStore(a3[0]) && !("undefined" != typeof navigator && /Safari/.test(navigator.userAgent) && !/(Chrome\/|Edge\/)/.test(navigator.userAgent) && [].concat(navigator.userAgent.match(/Safari\/(\d*)/))[1] < 604) }), t3 = u3.schema, s3 = u3.hasGetAll, u3 = t3.tables.map(n3), c3 = {};
        return u3.forEach(function(e4) {
          return c3[e4.name] = e4;
        }), { stack: "dbcore", transaction: e3.transaction.bind(e3), table: function(e4) {
          if (!c3[e4]) throw new Error("Table '".concat(e4, "' not found"));
          return c3[e4];
        }, MIN_KEY: -1 / 0, MAX_KEY: Qt(i3), schema: t3 };
      }
      function en2(e3, t3, n3, r3) {
        var i3 = n3.IDBKeyRange;
        return n3.indexedDB, { dbcore: (r3 = Zt(t3, i3, r3), e3.dbcore.reduce(function(e4, t4) {
          t4 = t4.create;
          return _2(_2({}, e4), t4(e4));
        }, r3)) };
      }
      function tn2(n3, e3) {
        var t3 = e3.db, e3 = en2(n3._middlewares, t3, n3._deps, e3);
        n3.core = e3.dbcore, n3.tables.forEach(function(e4) {
          var t4 = e4.name;
          n3.core.schema.tables.some(function(e5) {
            return e5.name === t4;
          }) && (e4.core = n3.core.table(t4), n3[t4] instanceof n3.Table && (n3[t4].core = e4.core));
        });
      }
      function nn2(i3, e3, t3, o3) {
        t3.forEach(function(n3) {
          var r3 = o3[n3];
          e3.forEach(function(e4) {
            var t4 = (function e5(t5, n4) {
              return h2(t5, n4) || (t5 = c2(t5)) && e5(t5, n4);
            })(e4, n3);
            (!t4 || "value" in t4 && void 0 === t4.value) && (e4 === i3.Transaction.prototype || e4 instanceof i3.Transaction ? l2(e4, n3, { get: function() {
              return this.table(n3);
            }, set: function(e5) {
              u2(this, n3, { value: e5, writable: true, configurable: true, enumerable: true });
            } }) : e4[n3] = new i3.Table(n3, r3));
          });
        });
      }
      function rn2(n3, e3) {
        e3.forEach(function(e4) {
          for (var t3 in e4) e4[t3] instanceof n3.Table && delete e4[t3];
        });
      }
      function on2(e3, t3) {
        return e3._cfg.version - t3._cfg.version;
      }
      function an2(n3, r3, i3, e3) {
        var o3 = n3._dbSchema;
        i3.objectStoreNames.contains("$meta") && !o3.$meta && (o3.$meta = $t("$meta", pn2("")[0], []), n3._storeNames.push("$meta"));
        var a3 = n3._createTransaction("readwrite", n3._storeNames, o3);
        a3.create(i3), a3._completion.catch(e3);
        var u3 = a3._reject.bind(a3), s3 = me.transless || me;
        Ne(function() {
          return me.trans = a3, me.transless = s3, 0 !== r3 ? (tn2(n3, i3), t3 = r3, ((e4 = a3).storeNames.includes("$meta") ? e4.table("$meta").get("version").then(function(e5) {
            return null != e5 ? e5 : t3;
          }) : _e.resolve(t3)).then(function(e5) {
            return c3 = e5, l3 = a3, f3 = i3, t4 = [], e5 = (s4 = n3)._versions, h3 = s4._dbSchema = hn2(0, s4.idbdb, f3), 0 !== (e5 = e5.filter(function(e6) {
              return e6._cfg.version >= c3;
            })).length ? (e5.forEach(function(u4) {
              t4.push(function() {
                var t5 = h3, e6 = u4._cfg.dbschema;
                dn2(s4, t5, f3), dn2(s4, e6, f3), h3 = s4._dbSchema = e6;
                var n4 = sn2(t5, e6);
                n4.add.forEach(function(e7) {
                  cn2(f3, e7[0], e7[1].primKey, e7[1].indexes);
                }), n4.change.forEach(function(e7) {
                  if (e7.recreate) throw new Y2.Upgrade("Not yet support for changing primary key");
                  var t6 = f3.objectStore(e7.name);
                  e7.add.forEach(function(e8) {
                    return fn2(t6, e8);
                  }), e7.change.forEach(function(e8) {
                    t6.deleteIndex(e8.name), fn2(t6, e8);
                  }), e7.del.forEach(function(e8) {
                    return t6.deleteIndex(e8);
                  });
                });
                var r4 = u4._cfg.contentUpgrade;
                if (r4 && u4._cfg.version > c3) {
                  tn2(s4, f3), l3._memoizedTables = {};
                  var i4 = k2(e6);
                  n4.del.forEach(function(e7) {
                    i4[e7] = t5[e7];
                  }), rn2(s4, [s4.Transaction.prototype]), nn2(s4, [s4.Transaction.prototype], O2(i4), i4), l3.schema = i4;
                  var o4, a4 = B2(r4);
                  a4 && Le();
                  n4 = _e.follow(function() {
                    var e7;
                    (o4 = r4(l3)) && a4 && (e7 = Ue.bind(null, null), o4.then(e7, e7));
                  });
                  return o4 && "function" == typeof o4.then ? _e.resolve(o4) : n4.then(function() {
                    return o4;
                  });
                }
              }), t4.push(function(e6) {
                var t5, n4, r4 = u4._cfg.dbschema;
                t5 = r4, n4 = e6, [].slice.call(n4.db.objectStoreNames).forEach(function(e7) {
                  return null == t5[e7] && n4.db.deleteObjectStore(e7);
                }), rn2(s4, [s4.Transaction.prototype]), nn2(s4, [s4.Transaction.prototype], s4._storeNames, s4._dbSchema), l3.schema = s4._dbSchema;
              }), t4.push(function(e6) {
                s4.idbdb.objectStoreNames.contains("$meta") && (Math.ceil(s4.idbdb.version / 10) === u4._cfg.version ? (s4.idbdb.deleteObjectStore("$meta"), delete s4._dbSchema.$meta, s4._storeNames = s4._storeNames.filter(function(e7) {
                  return "$meta" !== e7;
                })) : e6.objectStore("$meta").put(u4._cfg.version, "version"));
              });
            }), (function e6() {
              return t4.length ? _e.resolve(t4.shift()(l3.idbtrans)).then(e6) : _e.resolve();
            })().then(function() {
              ln2(h3, f3);
            })) : _e.resolve();
            var s4, c3, l3, f3, t4, h3;
          }).catch(u3)) : (O2(o3).forEach(function(e5) {
            cn2(i3, e5, o3[e5].primKey, o3[e5].indexes);
          }), tn2(n3, i3), void _e.follow(function() {
            return n3.on.populate.fire(a3);
          }).catch(u3));
          var e4, t3;
        });
      }
      function un2(e3, r3) {
        ln2(e3._dbSchema, r3), r3.db.version % 10 != 0 || r3.objectStoreNames.contains("$meta") || r3.db.createObjectStore("$meta").add(Math.ceil(r3.db.version / 10 - 1), "version");
        var t3 = hn2(0, e3.idbdb, r3);
        dn2(e3, e3._dbSchema, r3);
        for (var n3 = 0, i3 = sn2(t3, e3._dbSchema).change; n3 < i3.length; n3++) {
          var o3 = (function(t4) {
            if (t4.change.length || t4.recreate) return console.warn("Unable to patch indexes of table ".concat(t4.name, " because it has changes on the type of index or primary key.")), { value: void 0 };
            var n4 = r3.objectStore(t4.name);
            t4.add.forEach(function(e4) {
              ie && console.debug("Dexie upgrade patch: Creating missing index ".concat(t4.name, ".").concat(e4.src)), fn2(n4, e4);
            });
          })(i3[n3]);
          if ("object" == typeof o3) return o3.value;
        }
      }
      function sn2(e3, t3) {
        var n3, r3 = { del: [], add: [], change: [] };
        for (n3 in e3) t3[n3] || r3.del.push(n3);
        for (n3 in t3) {
          var i3 = e3[n3], o3 = t3[n3];
          if (i3) {
            var a3 = { name: n3, def: o3, recreate: false, del: [], add: [], change: [] };
            if ("" + (i3.primKey.keyPath || "") != "" + (o3.primKey.keyPath || "") || i3.primKey.auto !== o3.primKey.auto) a3.recreate = true, r3.change.push(a3);
            else {
              var u3 = i3.idxByName, s3 = o3.idxByName, c3 = void 0;
              for (c3 in u3) s3[c3] || a3.del.push(c3);
              for (c3 in s3) {
                var l3 = u3[c3], f3 = s3[c3];
                l3 ? l3.src !== f3.src && a3.change.push(f3) : a3.add.push(f3);
              }
              (0 < a3.del.length || 0 < a3.add.length || 0 < a3.change.length) && r3.change.push(a3);
            }
          } else r3.add.push([n3, o3]);
        }
        return r3;
      }
      function cn2(e3, t3, n3, r3) {
        var i3 = e3.db.createObjectStore(t3, n3.keyPath ? { keyPath: n3.keyPath, autoIncrement: n3.auto } : { autoIncrement: n3.auto });
        return r3.forEach(function(e4) {
          return fn2(i3, e4);
        }), i3;
      }
      function ln2(t3, n3) {
        O2(t3).forEach(function(e3) {
          n3.db.objectStoreNames.contains(e3) || (ie && console.debug("Dexie: Creating missing table", e3), cn2(n3, e3, t3[e3].primKey, t3[e3].indexes));
        });
      }
      function fn2(e3, t3) {
        e3.createIndex(t3.name, t3.keyPath, { unique: t3.unique, multiEntry: t3.multi });
      }
      function hn2(e3, t3, u3) {
        var s3 = {};
        return b2(t3.objectStoreNames, 0).forEach(function(e4) {
          for (var t4 = u3.objectStore(e4), n3 = Wt(Yt(a3 = t4.keyPath), a3 || "", true, false, !!t4.autoIncrement, a3 && "string" != typeof a3, true), r3 = [], i3 = 0; i3 < t4.indexNames.length; ++i3) {
            var o3 = t4.index(t4.indexNames[i3]), a3 = o3.keyPath, o3 = Wt(o3.name, a3, !!o3.unique, !!o3.multiEntry, false, a3 && "string" != typeof a3, false);
            r3.push(o3);
          }
          s3[e4] = $t(e4, n3, r3);
        }), s3;
      }
      function dn2(e3, t3, n3) {
        for (var r3 = n3.db.objectStoreNames, i3 = 0; i3 < r3.length; ++i3) {
          var o3 = r3[i3], a3 = n3.objectStore(o3);
          e3._hasGetAll = "getAll" in a3;
          for (var u3 = 0; u3 < a3.indexNames.length; ++u3) {
            var s3 = a3.indexNames[u3], c3 = a3.index(s3).keyPath, l3 = "string" == typeof c3 ? c3 : "[" + b2(c3).join("+") + "]";
            !t3[o3] || (c3 = t3[o3].idxByName[l3]) && (c3.name = s3, delete t3[o3].idxByName[l3], t3[o3].idxByName[s3] = c3);
          }
        }
        "undefined" != typeof navigator && /Safari/.test(navigator.userAgent) && !/(Chrome\/|Edge\/)/.test(navigator.userAgent) && f2.WorkerGlobalScope && f2 instanceof f2.WorkerGlobalScope && [].concat(navigator.userAgent.match(/Safari\/(\d*)/))[1] < 604 && (e3._hasGetAll = false);
      }
      function pn2(e3) {
        return e3.split(",").map(function(e4, t3) {
          var n3 = e4.split(":"), r3 = null === (i3 = n3[1]) || void 0 === i3 ? void 0 : i3.trim(), i3 = (e4 = n3[0].trim()).replace(/([&*]|\+\+)/g, ""), n3 = /^\[/.test(i3) ? i3.match(/^\[(.*)\]$/)[1].split("+") : i3;
          return Wt(i3, n3 || null, /\&/.test(e4), /\*/.test(e4), /\+\+/.test(e4), x2(n3), 0 === t3, r3);
        });
      }
      var yn2 = (vn2.prototype._createTableSchema = $t, vn2.prototype._parseIndexSyntax = pn2, vn2.prototype._parseStoresSpec = function(r3, i3) {
        var o3 = this;
        O2(r3).forEach(function(e3) {
          if (null !== r3[e3]) {
            var t3 = o3._parseIndexSyntax(r3[e3]), n3 = t3.shift();
            if (!n3) throw new Y2.Schema("Invalid schema for table " + e3 + ": " + r3[e3]);
            if (n3.unique = true, n3.multi) throw new Y2.Schema("Primary key cannot be multiEntry*");
            t3.forEach(function(e4) {
              if (e4.auto) throw new Y2.Schema("Only primary key can be marked as autoIncrement (++)");
              if (!e4.keyPath) throw new Y2.Schema("Index must have a name and cannot be an empty string");
            });
            t3 = o3._createTableSchema(e3, n3, t3);
            i3[e3] = t3;
          }
        });
      }, vn2.prototype.stores = function(e3) {
        var t3 = this.db;
        this._cfg.storesSource = this._cfg.storesSource ? a2(this._cfg.storesSource, e3) : e3;
        var e3 = t3._versions, n3 = {}, r3 = {};
        return e3.forEach(function(e4) {
          a2(n3, e4._cfg.storesSource), r3 = e4._cfg.dbschema = {}, e4._parseStoresSpec(n3, r3);
        }), t3._dbSchema = r3, rn2(t3, [t3._allTables, t3, t3.Transaction.prototype]), nn2(t3, [t3._allTables, t3, t3.Transaction.prototype, this._cfg.tables], O2(r3), r3), t3._storeNames = O2(r3), this;
      }, vn2.prototype.upgrade = function(e3) {
        return this._cfg.contentUpgrade = re(this._cfg.contentUpgrade || G2, e3), this;
      }, vn2);
      function vn2() {
      }
      function mn2(e3, t3) {
        var n3 = e3._dbNamesDB;
        return n3 || (n3 = e3._dbNamesDB = new nr(tt, { addons: [], indexedDB: e3, IDBKeyRange: t3 })).version(1).stores({ dbnames: "name" }), n3.table("dbnames");
      }
      function bn2(e3) {
        return e3 && "function" == typeof e3.databases;
      }
      function gn2(e3) {
        return Ne(function() {
          return me.letThrough = true, e3();
        });
      }
      function wn(e3) {
        return !("from" in e3);
      }
      var _n2 = function(e3, t3) {
        if (!this) {
          var n3 = new _n2();
          return e3 && "d" in e3 && a2(n3, e3), n3;
        }
        a2(this, arguments.length ? { d: 1, from: e3, to: 1 < arguments.length ? t3 : e3 } : { d: 0 });
      };
      function xn2(e3, t3, n3) {
        var r3 = st(t3, n3);
        if (!isNaN(r3)) {
          if (0 < r3) throw RangeError();
          if (wn(e3)) return a2(e3, { from: t3, to: n3, d: 1 });
          var i3 = e3.l, r3 = e3.r;
          if (st(n3, e3.from) < 0) return i3 ? xn2(i3, t3, n3) : e3.l = { from: t3, to: n3, d: 1, l: null, r: null }, Kn(e3);
          if (0 < st(t3, e3.to)) return r3 ? xn2(r3, t3, n3) : e3.r = { from: t3, to: n3, d: 1, l: null, r: null }, Kn(e3);
          st(t3, e3.from) < 0 && (e3.from = t3, e3.l = null, e3.d = r3 ? r3.d + 1 : 1), 0 < st(n3, e3.to) && (e3.to = n3, e3.r = null, e3.d = e3.l ? e3.l.d + 1 : 1);
          n3 = !e3.r;
          i3 && !e3.l && kn(e3, i3), r3 && n3 && kn(e3, r3);
        }
      }
      function kn(e3, t3) {
        wn(t3) || (function e4(t4, n3) {
          var r3 = n3.from, i3 = n3.to, o3 = n3.l, n3 = n3.r;
          xn2(t4, r3, i3), o3 && e4(t4, o3), n3 && e4(t4, n3);
        })(e3, t3);
      }
      function On(e3, t3) {
        var n3 = Pn(t3), r3 = n3.next();
        if (r3.done) return false;
        for (var i3 = r3.value, o3 = Pn(e3), a3 = o3.next(i3.from), u3 = a3.value; !r3.done && !a3.done; ) {
          if (st(u3.from, i3.to) <= 0 && 0 <= st(u3.to, i3.from)) return true;
          st(i3.from, u3.from) < 0 ? i3 = (r3 = n3.next(u3.from)).value : u3 = (a3 = o3.next(i3.from)).value;
        }
        return false;
      }
      function Pn(e3) {
        var n3 = wn(e3) ? null : { s: 0, n: e3 };
        return { next: function(e4) {
          for (var t3 = 0 < arguments.length; n3; ) switch (n3.s) {
            case 0:
              if (n3.s = 1, t3) for (; n3.n.l && st(e4, n3.n.from) < 0; ) n3 = { up: n3, n: n3.n.l, s: 1 };
              else for (; n3.n.l; ) n3 = { up: n3, n: n3.n.l, s: 1 };
            case 1:
              if (n3.s = 2, !t3 || st(e4, n3.n.to) <= 0) return { value: n3.n, done: false };
            case 2:
              if (n3.n.r) {
                n3.s = 3, n3 = { up: n3, n: n3.n.r, s: 0 };
                continue;
              }
            case 3:
              n3 = n3.up;
          }
          return { done: true };
        } };
      }
      function Kn(e3) {
        var t3, n3, r3 = ((null === (t3 = e3.r) || void 0 === t3 ? void 0 : t3.d) || 0) - ((null === (n3 = e3.l) || void 0 === n3 ? void 0 : n3.d) || 0), i3 = 1 < r3 ? "r" : r3 < -1 ? "l" : "";
        i3 && (t3 = "r" == i3 ? "l" : "r", n3 = _2({}, e3), r3 = e3[i3], e3.from = r3.from, e3.to = r3.to, e3[i3] = r3[i3], n3[i3] = r3[t3], (e3[t3] = n3).d = En2(n3)), e3.d = En2(e3);
      }
      function En2(e3) {
        var t3 = e3.r, e3 = e3.l;
        return (t3 ? e3 ? Math.max(t3.d, e3.d) : t3.d : e3 ? e3.d : 0) + 1;
      }
      function Sn2(t3, n3) {
        return O2(n3).forEach(function(e3) {
          t3[e3] ? kn(t3[e3], n3[e3]) : t3[e3] = (function e4(t4) {
            var n4, r3, i3 = {};
            for (n4 in t4) m2(t4, n4) && (r3 = t4[n4], i3[n4] = !r3 || "object" != typeof r3 || K2.has(r3.constructor) ? r3 : e4(r3));
            return i3;
          })(n3[e3]);
        }), t3;
      }
      function jn(t3, n3) {
        return t3.all || n3.all || Object.keys(t3).some(function(e3) {
          return n3[e3] && On(n3[e3], t3[e3]);
        });
      }
      r2(_n2.prototype, ((F2 = { add: function(e3) {
        return kn(this, e3), this;
      }, addKey: function(e3) {
        return xn2(this, e3, e3), this;
      }, addKeys: function(e3) {
        var t3 = this;
        return e3.forEach(function(e4) {
          return xn2(t3, e4, e4);
        }), this;
      }, hasKey: function(e3) {
        var t3 = Pn(this).next(e3).value;
        return t3 && st(t3.from, e3) <= 0 && 0 <= st(t3.to, e3);
      } })[C2] = function() {
        return Pn(this);
      }, F2));
      var An = {}, Cn2 = {}, Tn = false;
      function In(e3) {
        Sn2(Cn2, e3), Tn || (Tn = true, setTimeout(function() {
          Tn = false, qn(Cn2, !(Cn2 = {}));
        }, 0));
      }
      function qn(e3, t3) {
        void 0 === t3 && (t3 = false);
        var n3 = /* @__PURE__ */ new Set();
        if (e3.all) for (var r3 = 0, i3 = Object.values(An); r3 < i3.length; r3++) Dn(a3 = i3[r3], e3, n3, t3);
        else for (var o3 in e3) {
          var a3, u3 = /^idb\:\/\/(.*)\/(.*)\//.exec(o3);
          u3 && (o3 = u3[1], u3 = u3[2], (a3 = An["idb://".concat(o3, "/").concat(u3)]) && Dn(a3, e3, n3, t3));
        }
        n3.forEach(function(e4) {
          return e4();
        });
      }
      function Dn(e3, t3, n3, r3) {
        for (var i3 = [], o3 = 0, a3 = Object.entries(e3.queries.query); o3 < a3.length; o3++) {
          for (var u3 = a3[o3], s3 = u3[0], c3 = [], l3 = 0, f3 = u3[1]; l3 < f3.length; l3++) {
            var h3 = f3[l3];
            jn(t3, h3.obsSet) ? h3.subscribers.forEach(function(e4) {
              return n3.add(e4);
            }) : r3 && c3.push(h3);
          }
          r3 && i3.push([s3, c3]);
        }
        if (r3) for (var d3 = 0, p3 = i3; d3 < p3.length; d3++) {
          var y3 = p3[d3], s3 = y3[0], c3 = y3[1];
          e3.queries.query[s3] = c3;
        }
      }
      function Bn(f3) {
        var h3 = f3._state, r3 = f3._deps.indexedDB;
        if (h3.isBeingOpened || f3.idbdb) return h3.dbReadyPromise.then(function() {
          return h3.dbOpenError ? Xe(h3.dbOpenError) : f3;
        });
        h3.isBeingOpened = true, h3.dbOpenError = null, h3.openComplete = false;
        var t3 = h3.openCanceller, d3 = Math.round(10 * f3.verno), p3 = false;
        function e3() {
          if (h3.openCanceller !== t3) throw new Y2.DatabaseClosed("db.open() was cancelled");
        }
        function y3() {
          return new _e(function(s3, n4) {
            if (e3(), !r3) throw new Y2.MissingAPI();
            var c3 = f3.name, l3 = h3.autoSchema || !d3 ? r3.open(c3) : r3.open(c3, d3);
            if (!l3) throw new Y2.MissingAPI();
            l3.onerror = Ft(n4), l3.onblocked = Ie(f3._fireOnBlocked), l3.onupgradeneeded = Ie(function(e4) {
              var t4;
              v3 = l3.transaction, h3.autoSchema && !f3._options.allowEmptyDB ? (l3.onerror = Mt, v3.abort(), l3.result.close(), (t4 = r3.deleteDatabase(c3)).onsuccess = t4.onerror = Ie(function() {
                n4(new Y2.NoSuchDatabase("Database ".concat(c3, " doesnt exist")));
              })) : (v3.onerror = Ft(n4), e4 = e4.oldVersion > Math.pow(2, 62) ? 0 : e4.oldVersion, m3 = e4 < 1, f3.idbdb = l3.result, p3 && un2(f3, v3), an2(f3, e4 / 10, v3, n4));
            }, n4), l3.onsuccess = Ie(function() {
              v3 = null;
              var e4, t4, n5, r4, i4, o3 = f3.idbdb = l3.result, a3 = b2(o3.objectStoreNames);
              if (0 < a3.length) try {
                var u3 = o3.transaction(1 === (r4 = a3).length ? r4[0] : r4, "readonly");
                if (h3.autoSchema) t4 = o3, n5 = u3, (e4 = f3).verno = t4.version / 10, n5 = e4._dbSchema = hn2(0, t4, n5), e4._storeNames = b2(t4.objectStoreNames, 0), nn2(e4, [e4._allTables], O2(n5), n5);
                else if (dn2(f3, f3._dbSchema, u3), ((i4 = sn2(hn2(0, (i4 = f3).idbdb, u3), i4._dbSchema)).add.length || i4.change.some(function(e5) {
                  return e5.add.length || e5.change.length;
                })) && !p3) return console.warn("Dexie SchemaDiff: Schema was extended without increasing the number passed to db.version(). Dexie will add missing parts and increment native version number to workaround this."), o3.close(), d3 = o3.version + 1, p3 = true, s3(y3());
                tn2(f3, u3);
              } catch (e5) {
              }
              et.push(f3), o3.onversionchange = Ie(function(e5) {
                h3.vcFired = true, f3.on("versionchange").fire(e5);
              }), o3.onclose = Ie(function() {
                f3.close({ disableAutoOpen: false });
              }), m3 && (i4 = f3._deps, u3 = c3, o3 = i4.indexedDB, i4 = i4.IDBKeyRange, bn2(o3) || u3 === tt || mn2(o3, i4).put({ name: u3 }).catch(G2)), s3();
            }, n4);
          }).catch(function(e4) {
            switch (null == e4 ? void 0 : e4.name) {
              case "UnknownError":
                if (0 < h3.PR1398_maxLoop) return h3.PR1398_maxLoop--, console.warn("Dexie: Workaround for Chrome UnknownError on open()"), y3();
                break;
              case "VersionError":
                if (0 < d3) return d3 = 0, y3();
            }
            return _e.reject(e4);
          });
        }
        var n3, i3 = h3.dbReadyResolve, v3 = null, m3 = false;
        return _e.race([t3, ("undefined" == typeof navigator ? _e.resolve() : !navigator.userAgentData && /Safari\//.test(navigator.userAgent) && !/Chrom(e|ium)\//.test(navigator.userAgent) && indexedDB.databases ? new Promise(function(e4) {
          function t4() {
            return indexedDB.databases().finally(e4);
          }
          n3 = setInterval(t4, 100), t4();
        }).finally(function() {
          return clearInterval(n3);
        }) : Promise.resolve()).then(y3)]).then(function() {
          return e3(), h3.onReadyBeingFired = [], _e.resolve(gn2(function() {
            return f3.on.ready.fire(f3.vip);
          })).then(function e4() {
            if (0 < h3.onReadyBeingFired.length) {
              var t4 = h3.onReadyBeingFired.reduce(re, G2);
              return h3.onReadyBeingFired = [], _e.resolve(gn2(function() {
                return t4(f3.vip);
              })).then(e4);
            }
          });
        }).finally(function() {
          h3.openCanceller === t3 && (h3.onReadyBeingFired = null, h3.isBeingOpened = false);
        }).catch(function(e4) {
          h3.dbOpenError = e4;
          try {
            v3 && v3.abort();
          } catch (e5) {
          }
          return t3 === h3.openCanceller && f3._close(), Xe(e4);
        }).finally(function() {
          h3.openComplete = true, i3();
        }).then(function() {
          var n4;
          return m3 && (n4 = {}, f3.tables.forEach(function(t4) {
            t4.schema.indexes.forEach(function(e4) {
              e4.name && (n4["idb://".concat(f3.name, "/").concat(t4.name, "/").concat(e4.name)] = new _n2(-1 / 0, [[[]]]));
            }), n4["idb://".concat(f3.name, "/").concat(t4.name, "/")] = n4["idb://".concat(f3.name, "/").concat(t4.name, "/:dels")] = new _n2(-1 / 0, [[[]]]);
          }), Ut(Nt).fire(n4), qn(n4, true)), f3;
        });
      }
      function Rn2(t3) {
        function e3(e4) {
          return t3.next(e4);
        }
        var r3 = n3(e3), i3 = n3(function(e4) {
          return t3.throw(e4);
        });
        function n3(n4) {
          return function(e4) {
            var t4 = n4(e4), e4 = t4.value;
            return t4.done ? e4 : e4 && "function" == typeof e4.then ? e4.then(r3, i3) : x2(e4) ? Promise.all(e4).then(r3, i3) : r3(e4);
          };
        }
        return n3(e3)();
      }
      function Fn(e3, t3, n3) {
        for (var r3 = x2(e3) ? e3.slice() : [e3], i3 = 0; i3 < n3; ++i3) r3.push(t3);
        return r3;
      }
      var Mn = { stack: "dbcore", name: "VirtualIndexMiddleware", level: 1, create: function(f3) {
        return _2(_2({}, f3), { table: function(e3) {
          var a3 = f3.table(e3), t3 = a3.schema, u3 = {}, s3 = [];
          function c3(e4, t4, n4) {
            var r4 = Jt(e4), i4 = u3[r4] = u3[r4] || [], o3 = null == e4 ? 0 : "string" == typeof e4 ? 1 : e4.length, a4 = 0 < t4, a4 = _2(_2({}, n4), { name: a4 ? "".concat(r4, "(virtual-from:").concat(n4.name, ")") : n4.name, lowLevelIndex: n4, isVirtual: a4, keyTail: t4, keyLength: o3, extractKey: Gt(e4), unique: !a4 && n4.unique });
            return i4.push(a4), a4.isPrimaryKey || s3.push(a4), 1 < o3 && c3(2 === o3 ? e4[0] : e4.slice(0, o3 - 1), t4 + 1, n4), i4.sort(function(e5, t5) {
              return e5.keyTail - t5.keyTail;
            }), a4;
          }
          e3 = c3(t3.primaryKey.keyPath, 0, t3.primaryKey);
          u3[":id"] = [e3];
          for (var n3 = 0, r3 = t3.indexes; n3 < r3.length; n3++) {
            var i3 = r3[n3];
            c3(i3.keyPath, 0, i3);
          }
          function l3(e4) {
            var t4, n4 = e4.query.index;
            return n4.isVirtual ? _2(_2({}, e4), { query: { index: n4.lowLevelIndex, range: (t4 = e4.query.range, n4 = n4.keyTail, { type: 1 === t4.type ? 2 : t4.type, lower: Fn(t4.lower, t4.lowerOpen ? f3.MAX_KEY : f3.MIN_KEY, n4), lowerOpen: true, upper: Fn(t4.upper, t4.upperOpen ? f3.MIN_KEY : f3.MAX_KEY, n4), upperOpen: true }) } }) : e4;
          }
          return _2(_2({}, a3), { schema: _2(_2({}, t3), { primaryKey: e3, indexes: s3, getIndexByKeyPath: function(e4) {
            return (e4 = u3[Jt(e4)]) && e4[0];
          } }), count: function(e4) {
            return a3.count(l3(e4));
          }, query: function(e4) {
            return a3.query(l3(e4));
          }, openCursor: function(t4) {
            var e4 = t4.query.index, r4 = e4.keyTail, n4 = e4.isVirtual, i4 = e4.keyLength;
            return n4 ? a3.openCursor(l3(t4)).then(function(e5) {
              return e5 && o3(e5);
            }) : a3.openCursor(t4);
            function o3(n5) {
              return Object.create(n5, { continue: { value: function(e5) {
                null != e5 ? n5.continue(Fn(e5, t4.reverse ? f3.MAX_KEY : f3.MIN_KEY, r4)) : t4.unique ? n5.continue(n5.key.slice(0, i4).concat(t4.reverse ? f3.MIN_KEY : f3.MAX_KEY, r4)) : n5.continue();
              } }, continuePrimaryKey: { value: function(e5, t5) {
                n5.continuePrimaryKey(Fn(e5, f3.MAX_KEY, r4), t5);
              } }, primaryKey: { get: function() {
                return n5.primaryKey;
              } }, key: { get: function() {
                var e5 = n5.key;
                return 1 === i4 ? e5[0] : e5.slice(0, i4);
              } }, value: { get: function() {
                return n5.value;
              } } });
            }
          } });
        } });
      } };
      function Nn(i3, o3, a3, u3) {
        return a3 = a3 || {}, u3 = u3 || "", O2(i3).forEach(function(e3) {
          var t3, n3, r3;
          m2(o3, e3) ? (t3 = i3[e3], n3 = o3[e3], "object" == typeof t3 && "object" == typeof n3 && t3 && n3 ? (r3 = A2(t3)) !== A2(n3) ? a3[u3 + e3] = o3[e3] : "Object" === r3 ? Nn(t3, n3, a3, u3 + e3 + ".") : t3 !== n3 && (a3[u3 + e3] = o3[e3]) : t3 !== n3 && (a3[u3 + e3] = o3[e3])) : a3[u3 + e3] = void 0;
        }), O2(o3).forEach(function(e3) {
          m2(i3, e3) || (a3[u3 + e3] = o3[e3]);
        }), a3;
      }
      function Ln(e3, t3) {
        return "delete" === t3.type ? t3.keys : t3.keys || t3.values.map(e3.extractKey);
      }
      var Un = { stack: "dbcore", name: "HooksMiddleware", level: 2, create: function(e3) {
        return _2(_2({}, e3), { table: function(r3) {
          var y3 = e3.table(r3), v3 = y3.schema.primaryKey;
          return _2(_2({}, y3), { mutate: function(e4) {
            var t3 = me.trans, n3 = t3.table(r3).hook, h3 = n3.deleting, d3 = n3.creating, p3 = n3.updating;
            switch (e4.type) {
              case "add":
                if (d3.fire === G2) break;
                return t3._promise("readwrite", function() {
                  return a3(e4);
                }, true);
              case "put":
                if (d3.fire === G2 && p3.fire === G2) break;
                return t3._promise("readwrite", function() {
                  return a3(e4);
                }, true);
              case "delete":
                if (h3.fire === G2) break;
                return t3._promise("readwrite", function() {
                  return a3(e4);
                }, true);
              case "deleteRange":
                if (h3.fire === G2) break;
                return t3._promise("readwrite", function() {
                  return (function n4(r4, i3, o3) {
                    return y3.query({ trans: r4, values: false, query: { index: v3, range: i3 }, limit: o3 }).then(function(e5) {
                      var t4 = e5.result;
                      return a3({ type: "delete", keys: t4, trans: r4 }).then(function(e6) {
                        return 0 < e6.numFailures ? Promise.reject(e6.failures[0]) : t4.length < o3 ? { failures: [], numFailures: 0, lastResult: void 0 } : n4(r4, _2(_2({}, i3), { lower: t4[t4.length - 1], lowerOpen: true }), o3);
                      });
                    });
                  })(e4.trans, e4.range, 1e4);
                }, true);
            }
            return y3.mutate(e4);
            function a3(c3) {
              var e5, t4, n4, l3 = me.trans, f3 = c3.keys || Ln(v3, c3);
              if (!f3) throw new Error("Keys missing");
              return "delete" !== (c3 = "add" === c3.type || "put" === c3.type ? _2(_2({}, c3), { keys: f3 }) : _2({}, c3)).type && (c3.values = i2([], c3.values)), c3.keys && (c3.keys = i2([], c3.keys)), e5 = y3, n4 = f3, ("add" === (t4 = c3).type ? Promise.resolve([]) : e5.getMany({ trans: t4.trans, keys: n4, cache: "immutable" })).then(function(u3) {
                var s3 = f3.map(function(e6, t5) {
                  var n5, r4, i3, o3 = u3[t5], a4 = { onerror: null, onsuccess: null };
                  return "delete" === c3.type ? h3.fire.call(a4, e6, o3, l3) : "add" === c3.type || void 0 === o3 ? (n5 = d3.fire.call(a4, e6, c3.values[t5], l3), null == e6 && null != n5 && (c3.keys[t5] = e6 = n5, v3.outbound || w2(c3.values[t5], v3.keyPath, e6))) : (n5 = Nn(o3, c3.values[t5]), (r4 = p3.fire.call(a4, n5, e6, o3, l3)) && (i3 = c3.values[t5], Object.keys(r4).forEach(function(e7) {
                    m2(i3, e7) ? i3[e7] = r4[e7] : w2(i3, e7, r4[e7]);
                  }))), a4;
                });
                return y3.mutate(c3).then(function(e6) {
                  for (var t5 = e6.failures, n5 = e6.results, r4 = e6.numFailures, e6 = e6.lastResult, i3 = 0; i3 < f3.length; ++i3) {
                    var o3 = (n5 || f3)[i3], a4 = s3[i3];
                    null == o3 ? a4.onerror && a4.onerror(t5[i3]) : a4.onsuccess && a4.onsuccess("put" === c3.type && u3[i3] ? c3.values[i3] : o3);
                  }
                  return { failures: t5, results: n5, numFailures: r4, lastResult: e6 };
                }).catch(function(t5) {
                  return s3.forEach(function(e6) {
                    return e6.onerror && e6.onerror(t5);
                  }), Promise.reject(t5);
                });
              });
            }
          } });
        } });
      } };
      function Vn(e3, t3, n3) {
        try {
          if (!t3) return null;
          if (t3.keys.length < e3.length) return null;
          for (var r3 = [], i3 = 0, o3 = 0; i3 < t3.keys.length && o3 < e3.length; ++i3) 0 === st(t3.keys[i3], e3[o3]) && (r3.push(n3 ? S2(t3.values[i3]) : t3.values[i3]), ++o3);
          return r3.length === e3.length ? r3 : null;
        } catch (e4) {
          return null;
        }
      }
      var zn = { stack: "dbcore", level: -1, create: function(t3) {
        return { table: function(e3) {
          var n3 = t3.table(e3);
          return _2(_2({}, n3), { getMany: function(t4) {
            if (!t4.cache) return n3.getMany(t4);
            var e4 = Vn(t4.keys, t4.trans._cache, "clone" === t4.cache);
            return e4 ? _e.resolve(e4) : n3.getMany(t4).then(function(e5) {
              return t4.trans._cache = { keys: t4.keys, values: "clone" === t4.cache ? S2(e5) : e5 }, e5;
            });
          }, mutate: function(e4) {
            return "add" !== e4.type && (e4.trans._cache = null), n3.mutate(e4);
          } });
        } };
      } };
      function Wn(e3, t3) {
        return "readonly" === e3.trans.mode && !!e3.subscr && !e3.trans.explicit && "disabled" !== e3.trans.db._options.cache && !t3.schema.primaryKey.outbound;
      }
      function Yn(e3, t3) {
        switch (e3) {
          case "query":
            return t3.values && !t3.unique;
          case "get":
          case "getMany":
          case "count":
          case "openCursor":
            return false;
        }
      }
      var $n = { stack: "dbcore", level: 0, name: "Observability", create: function(b3) {
        var g3 = b3.schema.name, w3 = new _n2(b3.MIN_KEY, b3.MAX_KEY);
        return _2(_2({}, b3), { transaction: function(e3, t3, n3) {
          if (me.subscr && "readonly" !== t3) throw new Y2.ReadOnly("Readwrite transaction in liveQuery context. Querier source: ".concat(me.querier));
          return b3.transaction(e3, t3, n3);
        }, table: function(d3) {
          var p3 = b3.table(d3), y3 = p3.schema, v3 = y3.primaryKey, e3 = y3.indexes, c3 = v3.extractKey, l3 = v3.outbound, m3 = v3.autoIncrement && e3.filter(function(e4) {
            return e4.compound && e4.keyPath.includes(v3.keyPath);
          }), t3 = _2(_2({}, p3), { mutate: function(a3) {
            function u3(e5) {
              return e5 = "idb://".concat(g3, "/").concat(d3, "/").concat(e5), n3[e5] || (n3[e5] = new _n2());
            }
            var e4, o3, s3, t4 = a3.trans, n3 = a3.mutatedParts || (a3.mutatedParts = {}), r3 = u3(""), i3 = u3(":dels"), c4 = a3.type, l4 = "deleteRange" === a3.type ? [a3.range] : "delete" === a3.type ? [a3.keys] : a3.values.length < 50 ? [Ln(v3, a3).filter(function(e5) {
              return e5;
            }), a3.values] : [], f4 = l4[0], h3 = l4[1], l4 = a3.trans._cache;
            return x2(f4) ? (r3.addKeys(f4), (l4 = "delete" === c4 || f4.length === h3.length ? Vn(f4, l4) : null) || i3.addKeys(f4), (l4 || h3) && (e4 = u3, o3 = l4, s3 = h3, y3.indexes.forEach(function(t5) {
              var n4 = e4(t5.name || "");
              function r4(e5) {
                return null != e5 ? t5.extractKey(e5) : null;
              }
              function i4(e5) {
                return t5.multiEntry && x2(e5) ? e5.forEach(function(e6) {
                  return n4.addKey(e6);
                }) : n4.addKey(e5);
              }
              (o3 || s3).forEach(function(e5, t6) {
                var n5 = o3 && r4(o3[t6]), t6 = s3 && r4(s3[t6]);
                0 !== st(n5, t6) && (null != n5 && i4(n5), null != t6 && i4(t6));
              });
            }))) : f4 ? (h3 = { from: null !== (h3 = f4.lower) && void 0 !== h3 ? h3 : b3.MIN_KEY, to: null !== (h3 = f4.upper) && void 0 !== h3 ? h3 : b3.MAX_KEY }, i3.add(h3), r3.add(h3)) : (r3.add(w3), i3.add(w3), y3.indexes.forEach(function(e5) {
              return u3(e5.name).add(w3);
            })), p3.mutate(a3).then(function(o4) {
              return !f4 || "add" !== a3.type && "put" !== a3.type || (r3.addKeys(o4.results), m3 && m3.forEach(function(t5) {
                for (var e5 = a3.values.map(function(e6) {
                  return t5.extractKey(e6);
                }), n4 = t5.keyPath.findIndex(function(e6) {
                  return e6 === v3.keyPath;
                }), r4 = 0, i4 = o4.results.length; r4 < i4; ++r4) e5[r4][n4] = o4.results[r4];
                u3(t5.name).addKeys(e5);
              })), t4.mutatedParts = Sn2(t4.mutatedParts || {}, n3), o4;
            });
          } }), e3 = function(e4) {
            var t4 = e4.query, e4 = t4.index, t4 = t4.range;
            return [e4, new _n2(null !== (e4 = t4.lower) && void 0 !== e4 ? e4 : b3.MIN_KEY, null !== (t4 = t4.upper) && void 0 !== t4 ? t4 : b3.MAX_KEY)];
          }, f3 = { get: function(e4) {
            return [v3, new _n2(e4.key)];
          }, getMany: function(e4) {
            return [v3, new _n2().addKeys(e4.keys)];
          }, count: e3, query: e3, openCursor: e3 };
          return O2(f3).forEach(function(s3) {
            t3[s3] = function(i3) {
              var e4 = me.subscr, t4 = !!e4, n3 = Wn(me, p3) && Yn(s3, i3) ? i3.obsSet = {} : e4;
              if (t4) {
                var r3 = function(e5) {
                  e5 = "idb://".concat(g3, "/").concat(d3, "/").concat(e5);
                  return n3[e5] || (n3[e5] = new _n2());
                }, o3 = r3(""), a3 = r3(":dels"), e4 = f3[s3](i3), t4 = e4[0], e4 = e4[1];
                if (("query" === s3 && t4.isPrimaryKey && !i3.values ? a3 : r3(t4.name || "")).add(e4), !t4.isPrimaryKey) {
                  if ("count" !== s3) {
                    var u3 = "query" === s3 && l3 && i3.values && p3.query(_2(_2({}, i3), { values: false }));
                    return p3[s3].apply(this, arguments).then(function(t5) {
                      if ("query" === s3) {
                        if (l3 && i3.values) return u3.then(function(e6) {
                          e6 = e6.result;
                          return o3.addKeys(e6), t5;
                        });
                        var e5 = i3.values ? t5.result.map(c3) : t5.result;
                        (i3.values ? o3 : a3).addKeys(e5);
                      } else if ("openCursor" === s3) {
                        var n4 = t5, r4 = i3.values;
                        return n4 && Object.create(n4, { key: { get: function() {
                          return a3.addKey(n4.primaryKey), n4.key;
                        } }, primaryKey: { get: function() {
                          var e6 = n4.primaryKey;
                          return a3.addKey(e6), e6;
                        } }, value: { get: function() {
                          return r4 && o3.addKey(n4.primaryKey), n4.value;
                        } } });
                      }
                      return t5;
                    });
                  }
                  a3.add(w3);
                }
              }
              return p3[s3].apply(this, arguments);
            };
          }), t3;
        } });
      } };
      function Qn(e3, t3, n3) {
        if (0 === n3.numFailures) return t3;
        if ("deleteRange" === t3.type) return null;
        var r3 = t3.keys ? t3.keys.length : "values" in t3 && t3.values ? t3.values.length : 1;
        if (n3.numFailures === r3) return null;
        t3 = _2({}, t3);
        return x2(t3.keys) && (t3.keys = t3.keys.filter(function(e4, t4) {
          return !(t4 in n3.failures);
        })), "values" in t3 && x2(t3.values) && (t3.values = t3.values.filter(function(e4, t4) {
          return !(t4 in n3.failures);
        })), t3;
      }
      function Gn(e3, t3) {
        return n3 = e3, (void 0 === (r3 = t3).lower || (r3.lowerOpen ? 0 < st(n3, r3.lower) : 0 <= st(n3, r3.lower))) && (e3 = e3, void 0 === (t3 = t3).upper || (t3.upperOpen ? st(e3, t3.upper) < 0 : st(e3, t3.upper) <= 0));
        var n3, r3;
      }
      function Xn(e3, d3, t3, n3, r3, i3) {
        if (!t3 || 0 === t3.length) return e3;
        var o3 = d3.query.index, p3 = o3.multiEntry, y3 = d3.query.range, v3 = n3.schema.primaryKey.extractKey, m3 = o3.extractKey, a3 = (o3.lowLevelIndex || o3).extractKey, t3 = t3.reduce(function(e4, t4) {
          var n4 = e4, r4 = [];
          if ("add" === t4.type || "put" === t4.type) for (var i4 = new _n2(), o4 = t4.values.length - 1; 0 <= o4; --o4) {
            var a4, u3 = t4.values[o4], s3 = v3(u3);
            i4.hasKey(s3) || (a4 = m3(u3), (p3 && x2(a4) ? a4.some(function(e5) {
              return Gn(e5, y3);
            }) : Gn(a4, y3)) && (i4.addKey(s3), r4.push(u3)));
          }
          switch (t4.type) {
            case "add":
              var c3 = new _n2().addKeys(d3.values ? e4.map(function(e5) {
                return v3(e5);
              }) : e4), n4 = e4.concat(d3.values ? r4.filter(function(e5) {
                e5 = v3(e5);
                return !c3.hasKey(e5) && (c3.addKey(e5), true);
              }) : r4.map(function(e5) {
                return v3(e5);
              }).filter(function(e5) {
                return !c3.hasKey(e5) && (c3.addKey(e5), true);
              }));
              break;
            case "put":
              var l3 = new _n2().addKeys(t4.values.map(function(e5) {
                return v3(e5);
              }));
              n4 = e4.filter(function(e5) {
                return !l3.hasKey(d3.values ? v3(e5) : e5);
              }).concat(d3.values ? r4 : r4.map(function(e5) {
                return v3(e5);
              }));
              break;
            case "delete":
              var f3 = new _n2().addKeys(t4.keys);
              n4 = e4.filter(function(e5) {
                return !f3.hasKey(d3.values ? v3(e5) : e5);
              });
              break;
            case "deleteRange":
              var h3 = t4.range;
              n4 = e4.filter(function(e5) {
                return !Gn(v3(e5), h3);
              });
          }
          return n4;
        }, e3);
        return t3 === e3 ? e3 : (t3.sort(function(e4, t4) {
          return st(a3(e4), a3(t4)) || st(v3(e4), v3(t4));
        }), d3.limit && d3.limit < 1 / 0 && (t3.length > d3.limit ? t3.length = d3.limit : e3.length === d3.limit && t3.length < d3.limit && (r3.dirty = true)), i3 ? Object.freeze(t3) : t3);
      }
      function Hn(e3, t3) {
        return 0 === st(e3.lower, t3.lower) && 0 === st(e3.upper, t3.upper) && !!e3.lowerOpen == !!t3.lowerOpen && !!e3.upperOpen == !!t3.upperOpen;
      }
      function Jn(e3, t3) {
        return (function(e4, t4, n3, r3) {
          if (void 0 === e4) return void 0 !== t4 ? -1 : 0;
          if (void 0 === t4) return 1;
          if (0 === (t4 = st(e4, t4))) {
            if (n3 && r3) return 0;
            if (n3) return 1;
            if (r3) return -1;
          }
          return t4;
        })(e3.lower, t3.lower, e3.lowerOpen, t3.lowerOpen) <= 0 && 0 <= (function(e4, t4, n3, r3) {
          if (void 0 === e4) return void 0 !== t4 ? 1 : 0;
          if (void 0 === t4) return -1;
          if (0 === (t4 = st(e4, t4))) {
            if (n3 && r3) return 0;
            if (n3) return -1;
            if (r3) return 1;
          }
          return t4;
        })(e3.upper, t3.upper, e3.upperOpen, t3.upperOpen);
      }
      function Zn(n3, r3, i3, e3) {
        n3.subscribers.add(i3), e3.addEventListener("abort", function() {
          var e4, t3;
          n3.subscribers.delete(i3), 0 === n3.subscribers.size && (e4 = n3, t3 = r3, setTimeout(function() {
            0 === e4.subscribers.size && I2(t3, e4);
          }, 3e3));
        });
      }
      var er = { stack: "dbcore", level: 0, name: "Cache", create: function(k3) {
        var O3 = k3.schema.name;
        return _2(_2({}, k3), { transaction: function(g3, w3, e3) {
          var _3, t3, x3 = k3.transaction(g3, w3, e3);
          return "readwrite" === w3 && (t3 = (_3 = new AbortController()).signal, e3 = function(b3) {
            return function() {
              if (_3.abort(), "readwrite" === w3) {
                for (var t4 = /* @__PURE__ */ new Set(), e4 = 0, n3 = g3; e4 < n3.length; e4++) {
                  var r3 = n3[e4], i3 = An["idb://".concat(O3, "/").concat(r3)];
                  if (i3) {
                    var o3 = k3.table(r3), a3 = i3.optimisticOps.filter(function(e5) {
                      return e5.trans === x3;
                    });
                    if (x3._explicit && b3 && x3.mutatedParts) for (var u3 = 0, s3 = Object.values(i3.queries.query); u3 < s3.length; u3++) for (var c3 = 0, l3 = (d3 = s3[u3]).slice(); c3 < l3.length; c3++) jn((p3 = l3[c3]).obsSet, x3.mutatedParts) && (I2(d3, p3), p3.subscribers.forEach(function(e5) {
                      return t4.add(e5);
                    }));
                    else if (0 < a3.length) {
                      i3.optimisticOps = i3.optimisticOps.filter(function(e5) {
                        return e5.trans !== x3;
                      });
                      for (var f3 = 0, h3 = Object.values(i3.queries.query); f3 < h3.length; f3++) for (var d3, p3, y3, v3 = 0, m3 = (d3 = h3[f3]).slice(); v3 < m3.length; v3++) null != (p3 = m3[v3]).res && x3.mutatedParts && (b3 && !p3.dirty ? (y3 = Object.isFrozen(p3.res), y3 = Xn(p3.res, p3.req, a3, o3, p3, y3), p3.dirty ? (I2(d3, p3), p3.subscribers.forEach(function(e5) {
                        return t4.add(e5);
                      })) : y3 !== p3.res && (p3.res = y3, p3.promise = _e.resolve({ result: y3 }))) : (p3.dirty && I2(d3, p3), p3.subscribers.forEach(function(e5) {
                        return t4.add(e5);
                      })));
                    }
                  }
                }
                t4.forEach(function(e5) {
                  return e5();
                });
              }
            };
          }, x3.addEventListener("abort", e3(false), { signal: t3 }), x3.addEventListener("error", e3(false), { signal: t3 }), x3.addEventListener("complete", e3(true), { signal: t3 })), x3;
        }, table: function(c3) {
          var l3 = k3.table(c3), i3 = l3.schema.primaryKey;
          return _2(_2({}, l3), { mutate: function(t3) {
            var e3 = me.trans;
            if (i3.outbound || "disabled" === e3.db._options.cache || e3.explicit || "readwrite" !== e3.idbtrans.mode) return l3.mutate(t3);
            var n3 = An["idb://".concat(O3, "/").concat(c3)];
            if (!n3) return l3.mutate(t3);
            e3 = l3.mutate(t3);
            return "add" !== t3.type && "put" !== t3.type || !(50 <= t3.values.length || Ln(i3, t3).some(function(e4) {
              return null == e4;
            })) ? (n3.optimisticOps.push(t3), t3.mutatedParts && In(t3.mutatedParts), e3.then(function(e4) {
              0 < e4.numFailures && (I2(n3.optimisticOps, t3), (e4 = Qn(0, t3, e4)) && n3.optimisticOps.push(e4), t3.mutatedParts && In(t3.mutatedParts));
            }), e3.catch(function() {
              I2(n3.optimisticOps, t3), t3.mutatedParts && In(t3.mutatedParts);
            })) : e3.then(function(r3) {
              var e4 = Qn(0, _2(_2({}, t3), { values: t3.values.map(function(e5, t4) {
                var n4;
                if (r3.failures[t4]) return e5;
                e5 = null !== (n4 = i3.keyPath) && void 0 !== n4 && n4.includes(".") ? S2(e5) : _2({}, e5);
                return w2(e5, i3.keyPath, r3.results[t4]), e5;
              }) }), r3);
              n3.optimisticOps.push(e4), queueMicrotask(function() {
                return t3.mutatedParts && In(t3.mutatedParts);
              });
            }), e3;
          }, query: function(t3) {
            if (!Wn(me, l3) || !Yn("query", t3)) return l3.query(t3);
            var i4 = "immutable" === (null === (o3 = me.trans) || void 0 === o3 ? void 0 : o3.db._options.cache), e3 = me, n3 = e3.requery, r3 = e3.signal, o3 = (function(e4, t4, n4, r4) {
              var i5 = An["idb://".concat(e4, "/").concat(t4)];
              if (!i5) return [];
              if (!(t4 = i5.queries[n4])) return [null, false, i5, null];
              var o4 = t4[(r4.query ? r4.query.index.name : null) || ""];
              if (!o4) return [null, false, i5, null];
              switch (n4) {
                case "query":
                  var a4 = o4.find(function(e5) {
                    return e5.req.limit === r4.limit && e5.req.values === r4.values && Hn(e5.req.query.range, r4.query.range);
                  });
                  return a4 ? [a4, true, i5, o4] : [o4.find(function(e5) {
                    return ("limit" in e5.req ? e5.req.limit : 1 / 0) >= r4.limit && (!r4.values || e5.req.values) && Jn(e5.req.query.range, r4.query.range);
                  }), false, i5, o4];
                case "count":
                  a4 = o4.find(function(e5) {
                    return Hn(e5.req.query.range, r4.query.range);
                  });
                  return [a4, !!a4, i5, o4];
              }
            })(O3, c3, "query", t3), a3 = o3[0], e3 = o3[1], u3 = o3[2], s3 = o3[3];
            return a3 && e3 ? a3.obsSet = t3.obsSet : (e3 = l3.query(t3).then(function(e4) {
              var t4 = e4.result;
              if (a3 && (a3.res = t4), i4) {
                for (var n4 = 0, r4 = t4.length; n4 < r4; ++n4) Object.freeze(t4[n4]);
                Object.freeze(t4);
              } else e4.result = S2(t4);
              return e4;
            }).catch(function(e4) {
              return s3 && a3 && I2(s3, a3), Promise.reject(e4);
            }), a3 = { obsSet: t3.obsSet, promise: e3, subscribers: /* @__PURE__ */ new Set(), type: "query", req: t3, dirty: false }, s3 ? s3.push(a3) : (s3 = [a3], (u3 = u3 || (An["idb://".concat(O3, "/").concat(c3)] = { queries: { query: {}, count: {} }, objs: /* @__PURE__ */ new Map(), optimisticOps: [], unsignaledParts: {} })).queries.query[t3.query.index.name || ""] = s3)), Zn(a3, s3, n3, r3), a3.promise.then(function(e4) {
              return { result: Xn(e4.result, t3, null == u3 ? void 0 : u3.optimisticOps, l3, a3, i4) };
            });
          } });
        } });
      } };
      function tr(e3, r3) {
        return new Proxy(e3, { get: function(e4, t3, n3) {
          return "db" === t3 ? r3 : Reflect.get(e4, t3, n3);
        } });
      }
      var nr = (rr.prototype.version = function(t3) {
        if (isNaN(t3) || t3 < 0.1) throw new Y2.Type("Given version is not a positive number");
        if (t3 = Math.round(10 * t3) / 10, this.idbdb || this._state.isBeingOpened) throw new Y2.Schema("Cannot add version when database is open");
        this.verno = Math.max(this.verno, t3);
        var e3 = this._versions, n3 = e3.filter(function(e4) {
          return e4._cfg.version === t3;
        })[0];
        return n3 || (n3 = new this.Version(t3), e3.push(n3), e3.sort(on2), n3.stores({}), this._state.autoSchema = false, n3);
      }, rr.prototype._whenReady = function(e3) {
        var n3 = this;
        return this.idbdb && (this._state.openComplete || me.letThrough || this._vip) ? e3() : new _e(function(e4, t3) {
          if (n3._state.openComplete) return t3(new Y2.DatabaseClosed(n3._state.dbOpenError));
          if (!n3._state.isBeingOpened) {
            if (!n3._state.autoOpen) return void t3(new Y2.DatabaseClosed());
            n3.open().catch(G2);
          }
          n3._state.dbReadyPromise.then(e4, t3);
        }).then(e3);
      }, rr.prototype.use = function(e3) {
        var t3 = e3.stack, n3 = e3.create, r3 = e3.level, i3 = e3.name;
        i3 && this.unuse({ stack: t3, name: i3 });
        e3 = this._middlewares[t3] || (this._middlewares[t3] = []);
        return e3.push({ stack: t3, create: n3, level: null == r3 ? 10 : r3, name: i3 }), e3.sort(function(e4, t4) {
          return e4.level - t4.level;
        }), this;
      }, rr.prototype.unuse = function(e3) {
        var t3 = e3.stack, n3 = e3.name, r3 = e3.create;
        return t3 && this._middlewares[t3] && (this._middlewares[t3] = this._middlewares[t3].filter(function(e4) {
          return r3 ? e4.create !== r3 : !!n3 && e4.name !== n3;
        })), this;
      }, rr.prototype.open = function() {
        var e3 = this;
        return $e(ve, function() {
          return Bn(e3);
        });
      }, rr.prototype._close = function() {
        this.on.close.fire(new CustomEvent("close"));
        var n3 = this._state, e3 = et.indexOf(this);
        if (0 <= e3 && et.splice(e3, 1), this.idbdb) {
          try {
            this.idbdb.close();
          } catch (e4) {
          }
          this.idbdb = null;
        }
        n3.isBeingOpened || (n3.dbReadyPromise = new _e(function(e4) {
          n3.dbReadyResolve = e4;
        }), n3.openCanceller = new _e(function(e4, t3) {
          n3.cancelOpen = t3;
        }));
      }, rr.prototype.close = function(e3) {
        var t3 = (void 0 === e3 ? { disableAutoOpen: true } : e3).disableAutoOpen, e3 = this._state;
        t3 ? (e3.isBeingOpened && e3.cancelOpen(new Y2.DatabaseClosed()), this._close(), e3.autoOpen = false, e3.dbOpenError = new Y2.DatabaseClosed()) : (this._close(), e3.autoOpen = this._options.autoOpen || e3.isBeingOpened, e3.openComplete = false, e3.dbOpenError = null);
      }, rr.prototype.delete = function(n3) {
        var i3 = this;
        void 0 === n3 && (n3 = { disableAutoOpen: true });
        var o3 = 0 < arguments.length && "object" != typeof arguments[0], a3 = this._state;
        return new _e(function(r3, t3) {
          function e3() {
            i3.close(n3);
            var e4 = i3._deps.indexedDB.deleteDatabase(i3.name);
            e4.onsuccess = Ie(function() {
              var e5, t4, n4;
              e5 = i3._deps, t4 = i3.name, n4 = e5.indexedDB, e5 = e5.IDBKeyRange, bn2(n4) || t4 === tt || mn2(n4, e5).delete(t4).catch(G2), r3();
            }), e4.onerror = Ft(t3), e4.onblocked = i3._fireOnBlocked;
          }
          if (o3) throw new Y2.InvalidArgument("Invalid closeOptions argument to db.delete()");
          a3.isBeingOpened ? a3.dbReadyPromise.then(e3) : e3();
        });
      }, rr.prototype.backendDB = function() {
        return this.idbdb;
      }, rr.prototype.isOpen = function() {
        return null !== this.idbdb;
      }, rr.prototype.hasBeenClosed = function() {
        var e3 = this._state.dbOpenError;
        return e3 && "DatabaseClosed" === e3.name;
      }, rr.prototype.hasFailed = function() {
        return null !== this._state.dbOpenError;
      }, rr.prototype.dynamicallyOpened = function() {
        return this._state.autoSchema;
      }, Object.defineProperty(rr.prototype, "tables", { get: function() {
        var t3 = this;
        return O2(this._allTables).map(function(e3) {
          return t3._allTables[e3];
        });
      }, enumerable: false, configurable: true }), rr.prototype.transaction = function() {
        var e3 = function(e4, t3, n3) {
          var r3 = arguments.length;
          if (r3 < 2) throw new Y2.InvalidArgument("Too few arguments");
          for (var i3 = new Array(r3 - 1); --r3; ) i3[r3 - 1] = arguments[r3];
          return n3 = i3.pop(), [e4, P2(i3), n3];
        }.apply(this, arguments);
        return this._transaction.apply(this, e3);
      }, rr.prototype._transaction = function(e3, t3, n3) {
        var r3 = this, i3 = me.trans;
        i3 && i3.db === this && -1 === e3.indexOf("!") || (i3 = null);
        var o3, a3, u3 = -1 !== e3.indexOf("?");
        e3 = e3.replace("!", "").replace("?", "");
        try {
          if (a3 = t3.map(function(e4) {
            e4 = e4 instanceof r3.Table ? e4.name : e4;
            if ("string" != typeof e4) throw new TypeError("Invalid table argument to Dexie.transaction(). Only Table or String are allowed");
            return e4;
          }), "r" == e3 || e3 === nt) o3 = nt;
          else {
            if ("rw" != e3 && e3 != rt) throw new Y2.InvalidArgument("Invalid transaction mode: " + e3);
            o3 = rt;
          }
          if (i3) {
            if (i3.mode === nt && o3 === rt) {
              if (!u3) throw new Y2.SubTransaction("Cannot enter a sub-transaction with READWRITE mode when parent transaction is READONLY");
              i3 = null;
            }
            i3 && a3.forEach(function(e4) {
              if (i3 && -1 === i3.storeNames.indexOf(e4)) {
                if (!u3) throw new Y2.SubTransaction("Table " + e4 + " not included in parent transaction.");
                i3 = null;
              }
            }), u3 && i3 && !i3.active && (i3 = null);
          }
        } catch (n4) {
          return i3 ? i3._promise(null, function(e4, t4) {
            t4(n4);
          }) : Xe(n4);
        }
        var s3 = function i4(o4, a4, u4, s4, c3) {
          return _e.resolve().then(function() {
            var e4 = me.transless || me, t4 = o4._createTransaction(a4, u4, o4._dbSchema, s4);
            if (t4.explicit = true, e4 = { trans: t4, transless: e4 }, s4) t4.idbtrans = s4.idbtrans;
            else try {
              t4.create(), t4.idbtrans._explicit = true, o4._state.PR1398_maxLoop = 3;
            } catch (e5) {
              return e5.name === z2.InvalidState && o4.isOpen() && 0 < --o4._state.PR1398_maxLoop ? (console.warn("Dexie: Need to reopen db"), o4.close({ disableAutoOpen: false }), o4.open().then(function() {
                return i4(o4, a4, u4, null, c3);
              })) : Xe(e5);
            }
            var n4, r4 = B2(c3);
            return r4 && Le(), e4 = _e.follow(function() {
              var e5;
              (n4 = c3.call(t4, t4)) && (r4 ? (e5 = Ue.bind(null, null), n4.then(e5, e5)) : "function" == typeof n4.next && "function" == typeof n4.throw && (n4 = Rn2(n4)));
            }, e4), (n4 && "function" == typeof n4.then ? _e.resolve(n4).then(function(e5) {
              return t4.active ? e5 : Xe(new Y2.PrematureCommit("Transaction committed too early. See http://bit.ly/2kdckMn"));
            }) : e4.then(function() {
              return n4;
            })).then(function(e5) {
              return s4 && t4._resolve(), t4._completion.then(function() {
                return e5;
              });
            }).catch(function(e5) {
              return t4._reject(e5), Xe(e5);
            });
          });
        }.bind(null, this, o3, a3, i3, n3);
        return i3 ? i3._promise(o3, s3, "lock") : me.trans ? $e(me.transless, function() {
          return r3._whenReady(s3);
        }) : this._whenReady(s3);
      }, rr.prototype.table = function(e3) {
        if (!m2(this._allTables, e3)) throw new Y2.InvalidTable("Table ".concat(e3, " does not exist"));
        return this._allTables[e3];
      }, rr);
      function rr(e3, t3) {
        var o3 = this;
        this._middlewares = {}, this.verno = 0;
        var n3 = rr.dependencies;
        this._options = t3 = _2({ addons: rr.addons, autoOpen: true, indexedDB: n3.indexedDB, IDBKeyRange: n3.IDBKeyRange, cache: "cloned" }, t3), this._deps = { indexedDB: t3.indexedDB, IDBKeyRange: t3.IDBKeyRange };
        n3 = t3.addons;
        this._dbSchema = {}, this._versions = [], this._storeNames = [], this._allTables = {}, this.idbdb = null, this._novip = this;
        var a3, r3, u3, i3, s3, c3 = { dbOpenError: null, isBeingOpened: false, onReadyBeingFired: null, openComplete: false, dbReadyResolve: G2, dbReadyPromise: null, cancelOpen: G2, openCanceller: null, autoSchema: true, PR1398_maxLoop: 3, autoOpen: t3.autoOpen };
        c3.dbReadyPromise = new _e(function(e4) {
          c3.dbReadyResolve = e4;
        }), c3.openCanceller = new _e(function(e4, t4) {
          c3.cancelOpen = t4;
        }), this._state = c3, this.name = e3, this.on = mt(this, "populate", "blocked", "versionchange", "close", { ready: [re, G2] }), this.once = function(n4, r4) {
          var i4 = function() {
            for (var e4 = [], t4 = 0; t4 < arguments.length; t4++) e4[t4] = arguments[t4];
            o3.on(n4).unsubscribe(i4), r4.apply(o3, e4);
          };
          return o3.on(n4, i4);
        }, this.on.ready.subscribe = p2(this.on.ready.subscribe, function(i4) {
          return function(n4, r4) {
            rr.vip(function() {
              var t4, e4 = o3._state;
              e4.openComplete ? (e4.dbOpenError || _e.resolve().then(n4), r4 && i4(n4)) : e4.onReadyBeingFired ? (e4.onReadyBeingFired.push(n4), r4 && i4(n4)) : (i4(n4), t4 = o3, r4 || i4(function e5() {
                t4.on.ready.unsubscribe(n4), t4.on.ready.unsubscribe(e5);
              }));
            });
          };
        }), this.Collection = (a3 = this, bt(Kt.prototype, function(e4, t4) {
          this.db = a3;
          var n4 = ot, r4 = null;
          if (t4) try {
            n4 = t4();
          } catch (e5) {
            r4 = e5;
          }
          var i4 = e4._ctx, t4 = i4.table, e4 = t4.hook.reading.fire;
          this._ctx = { table: t4, index: i4.index, isPrimKey: !i4.index || t4.schema.primKey.keyPath && i4.index === t4.schema.primKey.name, range: n4, keysOnly: false, dir: "next", unique: "", algorithm: null, filter: null, replayFilter: null, justLimit: true, isMatch: null, offset: 0, limit: 1 / 0, error: r4, or: i4.or, valueMapper: e4 !== X2 ? e4 : null };
        })), this.Table = (r3 = this, bt(yt.prototype, function(e4, t4, n4) {
          this.db = r3, this._tx = n4, this.name = e4, this.schema = t4, this.hook = r3._allTables[e4] ? r3._allTables[e4].hook : mt(null, { creating: [Z2, G2], reading: [H2, X2], updating: [te, G2], deleting: [ee, G2] });
        })), this.Transaction = (u3 = this, bt(Vt.prototype, function(e4, t4, n4, r4, i4) {
          var o4 = this;
          "readonly" !== e4 && t4.forEach(function(e5) {
            e5 = null === (e5 = n4[e5]) || void 0 === e5 ? void 0 : e5.yProps;
            e5 && (t4 = t4.concat(e5.map(function(e6) {
              return e6.updatesTable;
            })));
          }), this.db = u3, this.mode = e4, this.storeNames = t4, this.schema = n4, this.chromeTransactionDurability = r4, this.idbtrans = null, this.on = mt(this, "complete", "error", "abort"), this.parent = i4 || null, this.active = true, this._reculock = 0, this._blockedFuncs = [], this._resolve = null, this._reject = null, this._waitingFor = null, this._waitingQueue = null, this._spinCount = 0, this._completion = new _e(function(e5, t5) {
            o4._resolve = e5, o4._reject = t5;
          }), this._completion.then(function() {
            o4.active = false, o4.on.complete.fire();
          }, function(e5) {
            var t5 = o4.active;
            return o4.active = false, o4.on.error.fire(e5), o4.parent ? o4.parent._reject(e5) : t5 && o4.idbtrans && o4.idbtrans.abort(), Xe(e5);
          });
        })), this.Version = (i3 = this, bt(yn2.prototype, function(e4) {
          this.db = i3, this._cfg = { version: e4, storesSource: null, dbschema: {}, tables: {}, contentUpgrade: null };
        })), this.WhereClause = (s3 = this, bt(Bt.prototype, function(e4, t4, n4) {
          if (this.db = s3, this._ctx = { table: e4, index: ":id" === t4 ? null : t4, or: n4 }, this._cmp = this._ascending = st, this._descending = function(e5, t5) {
            return st(t5, e5);
          }, this._max = function(e5, t5) {
            return 0 < st(e5, t5) ? e5 : t5;
          }, this._min = function(e5, t5) {
            return st(e5, t5) < 0 ? e5 : t5;
          }, this._IDBKeyRange = s3._deps.IDBKeyRange, !this._IDBKeyRange) throw new Y2.MissingAPI();
        })), this.on("versionchange", function(e4) {
          0 < e4.newVersion ? console.warn("Another connection wants to upgrade database '".concat(o3.name, "'. Closing db now to resume the upgrade.")) : console.warn("Another connection wants to delete database '".concat(o3.name, "'. Closing db now to resume the delete request.")), o3.close({ disableAutoOpen: false });
        }), this.on("blocked", function(e4) {
          !e4.newVersion || e4.newVersion < e4.oldVersion ? console.warn("Dexie.delete('".concat(o3.name, "') was blocked")) : console.warn("Upgrade '".concat(o3.name, "' blocked by other connection holding version ").concat(e4.oldVersion / 10));
        }), this._maxKey = Qt(t3.IDBKeyRange), this._createTransaction = function(e4, t4, n4, r4) {
          return new o3.Transaction(e4, t4, n4, o3._options.chromeTransactionDurability, r4);
        }, this._fireOnBlocked = function(t4) {
          o3.on("blocked").fire(t4), et.filter(function(e4) {
            return e4.name === o3.name && e4 !== o3 && !e4._state.vcFired;
          }).map(function(e4) {
            return e4.on("versionchange").fire(t4);
          });
        }, this.use(zn), this.use(er), this.use($n), this.use(Mn), this.use(Un);
        var l3 = new Proxy(this, { get: function(e4, t4, n4) {
          if ("_vip" === t4) return true;
          if ("table" === t4) return function(e5) {
            return tr(o3.table(e5), l3);
          };
          var r4 = Reflect.get(e4, t4, n4);
          return r4 instanceof yt ? tr(r4, l3) : "tables" === t4 ? r4.map(function(e5) {
            return tr(e5, l3);
          }) : "_createTransaction" === t4 ? function() {
            return tr(r4.apply(this, arguments), l3);
          } : r4;
        } });
        this.vip = l3, n3.forEach(function(e4) {
          return e4(o3);
        });
      }
      var ir, F2 = "undefined" != typeof Symbol && "observable" in Symbol ? Symbol.observable : "@@observable", or = (ar.prototype.subscribe = function(e3, t3, n3) {
        return this._subscribe(e3 && "function" != typeof e3 ? e3 : { next: e3, error: t3, complete: n3 });
      }, ar.prototype[F2] = function() {
        return this;
      }, ar);
      function ar(e3) {
        this._subscribe = e3;
      }
      try {
        ir = { indexedDB: f2.indexedDB || f2.mozIndexedDB || f2.webkitIndexedDB || f2.msIndexedDB, IDBKeyRange: f2.IDBKeyRange || f2.webkitIDBKeyRange };
      } catch (e3) {
        ir = { indexedDB: null, IDBKeyRange: null };
      }
      function ur(h3) {
        var d3, p3 = false, e3 = new or(function(r3) {
          var i3 = B2(h3);
          var o3, a3 = false, u3 = {}, s3 = {}, e4 = { get closed() {
            return a3;
          }, unsubscribe: function() {
            a3 || (a3 = true, o3 && o3.abort(), c3 && Ut.storagemutated.unsubscribe(f3));
          } };
          r3.start && r3.start(e4);
          var c3 = false, l3 = function() {
            return Ge(t3);
          };
          var f3 = function(e5) {
            Sn2(u3, e5), jn(s3, u3) && l3();
          }, t3 = function() {
            var t4, n3, e5;
            !a3 && ir.indexedDB && (u3 = {}, t4 = {}, o3 && o3.abort(), o3 = new AbortController(), e5 = (function(e6) {
              var t5 = je();
              try {
                i3 && Le();
                var n4 = Ne(h3, e6);
                return n4 = i3 ? n4.finally(Ue) : n4;
              } finally {
                t5 && Ae();
              }
            })(n3 = { subscr: t4, signal: o3.signal, requery: l3, querier: h3, trans: null }), Promise.resolve(e5).then(function(e6) {
              p3 = true, d3 = e6, a3 || n3.signal.aborted || (u3 = {}, (function(e7) {
                for (var t5 in e7) if (m2(e7, t5)) return;
                return 1;
              })(s3 = t4) || c3 || (Ut(Nt, f3), c3 = true), Ge(function() {
                return !a3 && r3.next && r3.next(e6);
              }));
            }, function(e6) {
              p3 = false, ["DatabaseClosedError", "AbortError"].includes(null == e6 ? void 0 : e6.name) || a3 || Ge(function() {
                a3 || r3.error && r3.error(e6);
              });
            }));
          };
          return setTimeout(l3, 0), e4;
        });
        return e3.hasValue = function() {
          return p3;
        }, e3.getValue = function() {
          return d3;
        }, e3;
      }
      var sr = nr;
      function cr(e3) {
        var t3 = fr;
        try {
          fr = true, Ut.storagemutated.fire(e3), qn(e3, true);
        } finally {
          fr = t3;
        }
      }
      r2(sr, _2(_2({}, Q2), { delete: function(e3) {
        return new sr(e3, { addons: [] }).delete();
      }, exists: function(e3) {
        return new sr(e3, { addons: [] }).open().then(function(e4) {
          return e4.close(), true;
        }).catch("NoSuchDatabaseError", function() {
          return false;
        });
      }, getDatabaseNames: function(e3) {
        try {
          return t3 = sr.dependencies, n3 = t3.indexedDB, t3 = t3.IDBKeyRange, (bn2(n3) ? Promise.resolve(n3.databases()).then(function(e4) {
            return e4.map(function(e5) {
              return e5.name;
            }).filter(function(e5) {
              return e5 !== tt;
            });
          }) : mn2(n3, t3).toCollection().primaryKeys()).then(e3);
        } catch (e4) {
          return Xe(new Y2.MissingAPI());
        }
        var t3, n3;
      }, defineClass: function() {
        return function(e3) {
          a2(this, e3);
        };
      }, ignoreTransaction: function(e3) {
        return me.trans ? $e(me.transless, e3) : e3();
      }, vip: gn2, async: function(t3) {
        return function() {
          try {
            var e3 = Rn2(t3.apply(this, arguments));
            return e3 && "function" == typeof e3.then ? e3 : _e.resolve(e3);
          } catch (e4) {
            return Xe(e4);
          }
        };
      }, spawn: function(e3, t3, n3) {
        try {
          var r3 = Rn2(e3.apply(n3, t3 || []));
          return r3 && "function" == typeof r3.then ? r3 : _e.resolve(r3);
        } catch (e4) {
          return Xe(e4);
        }
      }, currentTransaction: { get: function() {
        return me.trans || null;
      } }, waitFor: function(e3, t3) {
        t3 = _e.resolve("function" == typeof e3 ? sr.ignoreTransaction(e3) : e3).timeout(t3 || 6e4);
        return me.trans ? me.trans.waitFor(t3) : t3;
      }, Promise: _e, debug: { get: function() {
        return ie;
      }, set: function(e3) {
        oe(e3);
      } }, derive: o2, extend: a2, props: r2, override: p2, Events: mt, on: Ut, liveQuery: ur, extendObservabilitySet: Sn2, getByKeyPath: g2, setByKeyPath: w2, delByKeyPath: function(t3, e3) {
        "string" == typeof e3 ? w2(t3, e3, void 0) : "length" in e3 && [].map.call(e3, function(e4) {
          w2(t3, e4, void 0);
        });
      }, shallowClone: k2, deepClone: S2, getObjectDiff: Nn, cmp: st, asap: v2, minKey: -1 / 0, addons: [], connections: et, errnames: z2, dependencies: ir, cache: An, semVer: "4.2.1", version: "4.2.1".split(".").map(function(e3) {
        return parseInt(e3);
      }).reduce(function(e3, t3, n3) {
        return e3 + t3 / Math.pow(10, 2 * n3);
      }) })), sr.maxKey = Qt(sr.dependencies.IDBKeyRange), "undefined" != typeof dispatchEvent && "undefined" != typeof addEventListener && (Ut(Nt, function(e3) {
        fr || (e3 = new CustomEvent(Lt, { detail: e3 }), fr = true, dispatchEvent(e3), fr = false);
      }), addEventListener(Lt, function(e3) {
        e3 = e3.detail;
        fr || cr(e3);
      }));
      var lr, fr = false, hr = function() {
      };
      return "undefined" != typeof BroadcastChannel && ((hr = function() {
        (lr = new BroadcastChannel(Lt)).onmessage = function(e3) {
          return e3.data && cr(e3.data);
        };
      })(), "function" == typeof lr.unref && lr.unref(), Ut(Nt, function(e3) {
        fr || lr.postMessage(e3);
      })), "undefined" != typeof addEventListener && (addEventListener("pagehide", function(e3) {
        if (!nr.disableBfCache && e3.persisted) {
          ie && console.debug("Dexie: handling persisted pagehide"), null != lr && lr.close();
          for (var t3 = 0, n3 = et; t3 < n3.length; t3++) n3[t3].close({ disableAutoOpen: false });
        }
      }), addEventListener("pageshow", function(e3) {
        !nr.disableBfCache && e3.persisted && (ie && console.debug("Dexie: handling persisted pageshow"), hr(), cr({ all: new _n2(-1 / 0, [[]]) }));
      })), _e.rejectionMapper = function(e3, t3) {
        return !e3 || e3 instanceof N2 || e3 instanceof TypeError || e3 instanceof SyntaxError || !e3.name || !$2[e3.name] ? e3 : (t3 = new $2[e3.name](t3 || e3.message, e3), "stack" in e3 && l2(t3, "stack", { get: function() {
          return this.inner.stack;
        } }), t3);
      }, oe(ie), _2(nr, Object.freeze({ __proto__: null, Dexie: nr, liveQuery: ur, Entity: ut, cmp: st, PropModification: ht, replacePrefix: function(e3, t3) {
        return new ht({ replacePrefix: [e3, t3] });
      }, add: function(e3) {
        return new ht({ add: e3 });
      }, remove: function(e3) {
        return new ht({ remove: e3 });
      }, default: nr, RangeSet: _n2, mergeRanges: kn, rangesOverlap: On }), { default: nr }), nr;
    });
  })(dexie_min$1);
  return dexie_min$1.exports;
}
var dexie_minExports = requireDexie_min();
const _Dexie = /* @__PURE__ */ getDefaultExportFromCjs(dexie_minExports);
const DexieSymbol = /* @__PURE__ */ Symbol.for("Dexie");
const Dexie = globalThis[DexieSymbol] || (globalThis[DexieSymbol] = _Dexie);
if (_Dexie.semVer !== Dexie.semVer) {
  throw new Error(`Two different versions of Dexie loaded in the same app: ${_Dexie.semVer} and ${Dexie.semVer}`);
}
const {
  liveQuery,
  mergeRanges,
  rangesOverlap,
  RangeSet,
  cmp,
  Entity,
  PropModification,
  replacePrefix,
  add,
  remove,
  DexieYProvider
} = Dexie;
function useObservable(observableFactory, arg2, arg3) {
  var deps;
  var defaultResult;
  if (typeof observableFactory === "function") {
    deps = arg2 || [];
    defaultResult = arg3;
  } else {
    deps = [];
    defaultResult = arg2;
  }
  var monitor = Rn.useRef({
    hasResult: false,
    result: defaultResult,
    error: null
  });
  var _a = Rn.useReducer(function(x2) {
    return x2 + 1;
  }, 0);
  _a[0];
  var triggerUpdate = _a[1];
  var observable = Rn.useMemo(function() {
    var observable2 = typeof observableFactory === "function" ? observableFactory() : observableFactory;
    if (!observable2 || typeof observable2.subscribe !== "function") {
      if (observableFactory === observable2) {
        throw new TypeError("Given argument to useObservable() was neither a valid observable nor a function.");
      } else {
        throw new TypeError("Observable factory given to useObservable() did not return a valid observable.");
      }
    }
    if (!monitor.current.hasResult && typeof window !== "undefined") {
      if (typeof observable2.hasValue !== "function" || observable2.hasValue()) {
        if (typeof observable2.getValue === "function") {
          monitor.current.result = observable2.getValue();
          monitor.current.hasResult = true;
        } else {
          var subscription = observable2.subscribe(function(val) {
            monitor.current.result = val;
            monitor.current.hasResult = true;
          });
          if (typeof subscription === "function") {
            subscription();
          } else {
            subscription.unsubscribe();
          }
        }
      }
    }
    return observable2;
  }, deps);
  Rn.useDebugValue(monitor.current.result);
  Rn.useEffect(function() {
    var subscription = observable.subscribe(function(val) {
      var current = monitor.current;
      if (current.error !== null || current.result !== val) {
        current.error = null;
        current.result = val;
        current.hasResult = true;
        triggerUpdate();
      }
    }, function(err) {
      var current = monitor.current;
      if (current.error !== err) {
        current.error = err;
        triggerUpdate();
      }
    });
    return typeof subscription === "function" ? subscription : subscription.unsubscribe.bind(subscription);
  }, deps);
  if (monitor.current.error)
    throw monitor.current.error;
  return monitor.current.result;
}
function useLiveQuery(querier, deps, defaultResult) {
  return useObservable(function() {
    return Dexie.liveQuery(querier);
  }, deps || [], defaultResult);
}
typeof FinalizationRegistry !== "undefined" && new FinalizationRegistry(function(doc) {
  var DexieYProvider2 = Dexie["DexieYProvider"];
  if (DexieYProvider2)
    DexieYProvider2.release(doc);
});
function TaskProvider({
  keywords,
  statuses,
  files,
  children,
  database
}) {
  const [tasks, setTasks] = d({ tasks: null });
  useLiveQuery(async () => {
    setTasks({
      tasks: await database.getAllTasks({
        keywords,
        statuses,
        files
      })
    });
  }, [statuses, keywords]);
  return /* @__PURE__ */ u$1(TaskContext.Provider, { value: tasks, children });
}
const TaskContext = Q$1({
  tasks: null
});
function useTaskContext() {
  const context = x$1(TaskContext);
  if (context === void 0) {
    throw new Error("useTaskContext must be used within a TaskProvider");
  }
  return context;
}
function functionalUpdate(updater, input) {
  return typeof updater === "function" ? updater(input) : updater;
}
function makeStateUpdater(key, instance) {
  return (updater) => {
    instance.setState((old) => {
      return {
        ...old,
        [key]: functionalUpdate(updater, old[key])
      };
    });
  };
}
function isFunction(d2) {
  return d2 instanceof Function;
}
function isNumberArray(d2) {
  return Array.isArray(d2) && d2.every((val) => typeof val === "number");
}
function flattenBy(arr, getChildren) {
  const flat = [];
  const recurse = (subArr) => {
    subArr.forEach((item) => {
      flat.push(item);
      const children = getChildren(item);
      if (children != null && children.length) {
        recurse(children);
      }
    });
  };
  recurse(arr);
  return flat;
}
function memo(getDeps, fn2, opts) {
  let deps = [];
  let result;
  return (depArgs) => {
    let depTime;
    if (opts.key && opts.debug) depTime = Date.now();
    const newDeps = getDeps(depArgs);
    const depsChanged = newDeps.length !== deps.length || newDeps.some((dep, index) => deps[index] !== dep);
    if (!depsChanged) {
      return result;
    }
    deps = newDeps;
    let resultTime;
    if (opts.key && opts.debug) resultTime = Date.now();
    result = fn2(...newDeps);
    opts == null || opts.onChange == null || opts.onChange(result);
    if (opts.key && opts.debug) {
      if (opts != null && opts.debug()) {
        const depEndTime = Math.round((Date.now() - depTime) * 100) / 100;
        const resultEndTime = Math.round((Date.now() - resultTime) * 100) / 100;
        const resultFpsPercentage = resultEndTime / 16;
        const pad = (str, num) => {
          str = String(str);
          while (str.length < num) {
            str = " " + str;
          }
          return str;
        };
        console.info(`%câ± ${pad(resultEndTime, 5)} /${pad(depEndTime, 5)} ms`, `
            font-size: .6rem;
            font-weight: bold;
            color: hsl(${Math.max(0, Math.min(120 - 120 * resultFpsPercentage, 120))}deg 100% 31%);`, opts == null ? void 0 : opts.key);
      }
    }
    return result;
  };
}
function getMemoOptions(tableOptions, debugLevel, key, onChange) {
  return {
    debug: () => {
      var _tableOptions$debugAl;
      return (_tableOptions$debugAl = tableOptions == null ? void 0 : tableOptions.debugAll) != null ? _tableOptions$debugAl : tableOptions[debugLevel];
    },
    key: process.env.NODE_ENV === "development" && key,
    onChange
  };
}
function createCell(table, row, column, columnId) {
  const getRenderValue = () => {
    var _cell$getValue;
    return (_cell$getValue = cell.getValue()) != null ? _cell$getValue : table.options.renderFallbackValue;
  };
  const cell = {
    id: `${row.id}_${column.id}`,
    row,
    column,
    getValue: () => row.getValue(columnId),
    renderValue: getRenderValue,
    getContext: memo(() => [table, column, row, cell], (table2, column2, row2, cell2) => ({
      table: table2,
      column: column2,
      row: row2,
      cell: cell2,
      getValue: cell2.getValue,
      renderValue: cell2.renderValue
    }), getMemoOptions(table.options, "debugCells", "cell.getContext"))
  };
  table._features.forEach((feature) => {
    feature.createCell == null || feature.createCell(cell, column, row, table);
  }, {});
  return cell;
}
function createColumn(table, columnDef, depth, parent) {
  var _ref, _resolvedColumnDef$id;
  const defaultColumn = table._getDefaultColumnDef();
  const resolvedColumnDef = {
    ...defaultColumn,
    ...columnDef
  };
  const accessorKey = resolvedColumnDef.accessorKey;
  let id = (_ref = (_resolvedColumnDef$id = resolvedColumnDef.id) != null ? _resolvedColumnDef$id : accessorKey ? typeof String.prototype.replaceAll === "function" ? accessorKey.replaceAll(".", "_") : accessorKey.replace(/\./g, "_") : void 0) != null ? _ref : typeof resolvedColumnDef.header === "string" ? resolvedColumnDef.header : void 0;
  let accessorFn;
  if (resolvedColumnDef.accessorFn) {
    accessorFn = resolvedColumnDef.accessorFn;
  } else if (accessorKey) {
    if (accessorKey.includes(".")) {
      accessorFn = (originalRow) => {
        let result = originalRow;
        for (const key of accessorKey.split(".")) {
          var _result;
          result = (_result = result) == null ? void 0 : _result[key];
          if (process.env.NODE_ENV !== "production" && result === void 0) {
            console.warn(`"${key}" in deeply nested key "${accessorKey}" returned undefined.`);
          }
        }
        return result;
      };
    } else {
      accessorFn = (originalRow) => originalRow[resolvedColumnDef.accessorKey];
    }
  }
  if (!id) {
    if (process.env.NODE_ENV !== "production") {
      throw new Error(resolvedColumnDef.accessorFn ? `Columns require an id when using an accessorFn` : `Columns require an id when using a non-string header`);
    }
    throw new Error();
  }
  let column = {
    id: `${String(id)}`,
    accessorFn,
    parent,
    depth,
    columnDef: resolvedColumnDef,
    columns: [],
    getFlatColumns: memo(() => [true], () => {
      var _column$columns;
      return [column, ...(_column$columns = column.columns) == null ? void 0 : _column$columns.flatMap((d2) => d2.getFlatColumns())];
    }, getMemoOptions(table.options, "debugColumns", "column.getFlatColumns")),
    getLeafColumns: memo(() => [table._getOrderColumnsFn()], (orderColumns2) => {
      var _column$columns2;
      if ((_column$columns2 = column.columns) != null && _column$columns2.length) {
        let leafColumns = column.columns.flatMap((column2) => column2.getLeafColumns());
        return orderColumns2(leafColumns);
      }
      return [column];
    }, getMemoOptions(table.options, "debugColumns", "column.getLeafColumns"))
  };
  for (const feature of table._features) {
    feature.createColumn == null || feature.createColumn(column, table);
  }
  return column;
}
const debug = "debugHeaders";
function createHeader(table, column, options) {
  var _options$id;
  const id = (_options$id = options.id) != null ? _options$id : column.id;
  let header = {
    id,
    column,
    index: options.index,
    isPlaceholder: !!options.isPlaceholder,
    placeholderId: options.placeholderId,
    depth: options.depth,
    subHeaders: [],
    colSpan: 0,
    rowSpan: 0,
    headerGroup: null,
    getLeafHeaders: () => {
      const leafHeaders = [];
      const recurseHeader = (h2) => {
        if (h2.subHeaders && h2.subHeaders.length) {
          h2.subHeaders.map(recurseHeader);
        }
        leafHeaders.push(h2);
      };
      recurseHeader(header);
      return leafHeaders;
    },
    getContext: () => ({
      table,
      header,
      column
    })
  };
  table._features.forEach((feature) => {
    feature.createHeader == null || feature.createHeader(header, table);
  });
  return header;
}
const Headers = {
  createTable: (table) => {
    table.getHeaderGroups = memo(() => [table.getAllColumns(), table.getVisibleLeafColumns(), table.getState().columnPinning.left, table.getState().columnPinning.right], (allColumns, leafColumns, left, right) => {
      var _left$map$filter, _right$map$filter;
      const leftColumns = (_left$map$filter = left == null ? void 0 : left.map((columnId) => leafColumns.find((d2) => d2.id === columnId)).filter(Boolean)) != null ? _left$map$filter : [];
      const rightColumns = (_right$map$filter = right == null ? void 0 : right.map((columnId) => leafColumns.find((d2) => d2.id === columnId)).filter(Boolean)) != null ? _right$map$filter : [];
      const centerColumns = leafColumns.filter((column) => !(left != null && left.includes(column.id)) && !(right != null && right.includes(column.id)));
      const headerGroups = buildHeaderGroups(allColumns, [...leftColumns, ...centerColumns, ...rightColumns], table);
      return headerGroups;
    }, getMemoOptions(table.options, debug, "getHeaderGroups"));
    table.getCenterHeaderGroups = memo(() => [table.getAllColumns(), table.getVisibleLeafColumns(), table.getState().columnPinning.left, table.getState().columnPinning.right], (allColumns, leafColumns, left, right) => {
      leafColumns = leafColumns.filter((column) => !(left != null && left.includes(column.id)) && !(right != null && right.includes(column.id)));
      return buildHeaderGroups(allColumns, leafColumns, table, "center");
    }, getMemoOptions(table.options, debug, "getCenterHeaderGroups"));
    table.getLeftHeaderGroups = memo(() => [table.getAllColumns(), table.getVisibleLeafColumns(), table.getState().columnPinning.left], (allColumns, leafColumns, left) => {
      var _left$map$filter2;
      const orderedLeafColumns = (_left$map$filter2 = left == null ? void 0 : left.map((columnId) => leafColumns.find((d2) => d2.id === columnId)).filter(Boolean)) != null ? _left$map$filter2 : [];
      return buildHeaderGroups(allColumns, orderedLeafColumns, table, "left");
    }, getMemoOptions(table.options, debug, "getLeftHeaderGroups"));
    table.getRightHeaderGroups = memo(() => [table.getAllColumns(), table.getVisibleLeafColumns(), table.getState().columnPinning.right], (allColumns, leafColumns, right) => {
      var _right$map$filter2;
      const orderedLeafColumns = (_right$map$filter2 = right == null ? void 0 : right.map((columnId) => leafColumns.find((d2) => d2.id === columnId)).filter(Boolean)) != null ? _right$map$filter2 : [];
      return buildHeaderGroups(allColumns, orderedLeafColumns, table, "right");
    }, getMemoOptions(table.options, debug, "getRightHeaderGroups"));
    table.getFooterGroups = memo(() => [table.getHeaderGroups()], (headerGroups) => {
      return [...headerGroups].reverse();
    }, getMemoOptions(table.options, debug, "getFooterGroups"));
    table.getLeftFooterGroups = memo(() => [table.getLeftHeaderGroups()], (headerGroups) => {
      return [...headerGroups].reverse();
    }, getMemoOptions(table.options, debug, "getLeftFooterGroups"));
    table.getCenterFooterGroups = memo(() => [table.getCenterHeaderGroups()], (headerGroups) => {
      return [...headerGroups].reverse();
    }, getMemoOptions(table.options, debug, "getCenterFooterGroups"));
    table.getRightFooterGroups = memo(() => [table.getRightHeaderGroups()], (headerGroups) => {
      return [...headerGroups].reverse();
    }, getMemoOptions(table.options, debug, "getRightFooterGroups"));
    table.getFlatHeaders = memo(() => [table.getHeaderGroups()], (headerGroups) => {
      return headerGroups.map((headerGroup) => {
        return headerGroup.headers;
      }).flat();
    }, getMemoOptions(table.options, debug, "getFlatHeaders"));
    table.getLeftFlatHeaders = memo(() => [table.getLeftHeaderGroups()], (left) => {
      return left.map((headerGroup) => {
        return headerGroup.headers;
      }).flat();
    }, getMemoOptions(table.options, debug, "getLeftFlatHeaders"));
    table.getCenterFlatHeaders = memo(() => [table.getCenterHeaderGroups()], (left) => {
      return left.map((headerGroup) => {
        return headerGroup.headers;
      }).flat();
    }, getMemoOptions(table.options, debug, "getCenterFlatHeaders"));
    table.getRightFlatHeaders = memo(() => [table.getRightHeaderGroups()], (left) => {
      return left.map((headerGroup) => {
        return headerGroup.headers;
      }).flat();
    }, getMemoOptions(table.options, debug, "getRightFlatHeaders"));
    table.getCenterLeafHeaders = memo(() => [table.getCenterFlatHeaders()], (flatHeaders) => {
      return flatHeaders.filter((header) => {
        var _header$subHeaders;
        return !((_header$subHeaders = header.subHeaders) != null && _header$subHeaders.length);
      });
    }, getMemoOptions(table.options, debug, "getCenterLeafHeaders"));
    table.getLeftLeafHeaders = memo(() => [table.getLeftFlatHeaders()], (flatHeaders) => {
      return flatHeaders.filter((header) => {
        var _header$subHeaders2;
        return !((_header$subHeaders2 = header.subHeaders) != null && _header$subHeaders2.length);
      });
    }, getMemoOptions(table.options, debug, "getLeftLeafHeaders"));
    table.getRightLeafHeaders = memo(() => [table.getRightFlatHeaders()], (flatHeaders) => {
      return flatHeaders.filter((header) => {
        var _header$subHeaders3;
        return !((_header$subHeaders3 = header.subHeaders) != null && _header$subHeaders3.length);
      });
    }, getMemoOptions(table.options, debug, "getRightLeafHeaders"));
    table.getLeafHeaders = memo(() => [table.getLeftHeaderGroups(), table.getCenterHeaderGroups(), table.getRightHeaderGroups()], (left, center, right) => {
      var _left$0$headers, _left$, _center$0$headers, _center$, _right$0$headers, _right$;
      return [...(_left$0$headers = (_left$ = left[0]) == null ? void 0 : _left$.headers) != null ? _left$0$headers : [], ...(_center$0$headers = (_center$ = center[0]) == null ? void 0 : _center$.headers) != null ? _center$0$headers : [], ...(_right$0$headers = (_right$ = right[0]) == null ? void 0 : _right$.headers) != null ? _right$0$headers : []].map((header) => {
        return header.getLeafHeaders();
      }).flat();
    }, getMemoOptions(table.options, debug, "getLeafHeaders"));
  }
};
function buildHeaderGroups(allColumns, columnsToGroup, table, headerFamily) {
  var _headerGroups$0$heade, _headerGroups$;
  let maxDepth = 0;
  const findMaxDepth = function(columns2, depth) {
    if (depth === void 0) {
      depth = 1;
    }
    maxDepth = Math.max(maxDepth, depth);
    columns2.filter((column) => column.getIsVisible()).forEach((column) => {
      var _column$columns;
      if ((_column$columns = column.columns) != null && _column$columns.length) {
        findMaxDepth(column.columns, depth + 1);
      }
    }, 0);
  };
  findMaxDepth(allColumns);
  let headerGroups = [];
  const createHeaderGroup = (headersToGroup, depth) => {
    const headerGroup = {
      depth,
      id: [headerFamily, `${depth}`].filter(Boolean).join("_"),
      headers: []
    };
    const pendingParentHeaders = [];
    headersToGroup.forEach((headerToGroup) => {
      const latestPendingParentHeader = [...pendingParentHeaders].reverse()[0];
      const isLeafHeader = headerToGroup.column.depth === headerGroup.depth;
      let column;
      let isPlaceholder = false;
      if (isLeafHeader && headerToGroup.column.parent) {
        column = headerToGroup.column.parent;
      } else {
        column = headerToGroup.column;
        isPlaceholder = true;
      }
      if (latestPendingParentHeader && (latestPendingParentHeader == null ? void 0 : latestPendingParentHeader.column) === column) {
        latestPendingParentHeader.subHeaders.push(headerToGroup);
      } else {
        const header = createHeader(table, column, {
          id: [headerFamily, depth, column.id, headerToGroup == null ? void 0 : headerToGroup.id].filter(Boolean).join("_"),
          isPlaceholder,
          placeholderId: isPlaceholder ? `${pendingParentHeaders.filter((d2) => d2.column === column).length}` : void 0,
          depth,
          index: pendingParentHeaders.length
        });
        header.subHeaders.push(headerToGroup);
        pendingParentHeaders.push(header);
      }
      headerGroup.headers.push(headerToGroup);
      headerToGroup.headerGroup = headerGroup;
    });
    headerGroups.push(headerGroup);
    if (depth > 0) {
      createHeaderGroup(pendingParentHeaders, depth - 1);
    }
  };
  const bottomHeaders = columnsToGroup.map((column, index) => createHeader(table, column, {
    depth: maxDepth,
    index
  }));
  createHeaderGroup(bottomHeaders, maxDepth - 1);
  headerGroups.reverse();
  const recurseHeadersForSpans = (headers) => {
    const filteredHeaders = headers.filter((header) => header.column.getIsVisible());
    return filteredHeaders.map((header) => {
      let colSpan = 0;
      let rowSpan = 0;
      let childRowSpans = [0];
      if (header.subHeaders && header.subHeaders.length) {
        childRowSpans = [];
        recurseHeadersForSpans(header.subHeaders).forEach((_ref) => {
          let {
            colSpan: childColSpan,
            rowSpan: childRowSpan
          } = _ref;
          colSpan += childColSpan;
          childRowSpans.push(childRowSpan);
        });
      } else {
        colSpan = 1;
      }
      const minChildRowSpan = Math.min(...childRowSpans);
      rowSpan = rowSpan + minChildRowSpan;
      header.colSpan = colSpan;
      header.rowSpan = rowSpan;
      return {
        colSpan,
        rowSpan
      };
    });
  };
  recurseHeadersForSpans((_headerGroups$0$heade = (_headerGroups$ = headerGroups[0]) == null ? void 0 : _headerGroups$.headers) != null ? _headerGroups$0$heade : []);
  return headerGroups;
}
const createRow = (table, id, original, rowIndex, depth, subRows, parentId) => {
  let row = {
    id,
    index: rowIndex,
    original,
    depth,
    parentId,
    _valuesCache: {},
    _uniqueValuesCache: {},
    getValue: (columnId) => {
      if (row._valuesCache.hasOwnProperty(columnId)) {
        return row._valuesCache[columnId];
      }
      const column = table.getColumn(columnId);
      if (!(column != null && column.accessorFn)) {
        return void 0;
      }
      row._valuesCache[columnId] = column.accessorFn(row.original, rowIndex);
      return row._valuesCache[columnId];
    },
    getUniqueValues: (columnId) => {
      if (row._uniqueValuesCache.hasOwnProperty(columnId)) {
        return row._uniqueValuesCache[columnId];
      }
      const column = table.getColumn(columnId);
      if (!(column != null && column.accessorFn)) {
        return void 0;
      }
      if (!column.columnDef.getUniqueValues) {
        row._uniqueValuesCache[columnId] = [row.getValue(columnId)];
        return row._uniqueValuesCache[columnId];
      }
      row._uniqueValuesCache[columnId] = column.columnDef.getUniqueValues(row.original, rowIndex);
      return row._uniqueValuesCache[columnId];
    },
    renderValue: (columnId) => {
      var _row$getValue;
      return (_row$getValue = row.getValue(columnId)) != null ? _row$getValue : table.options.renderFallbackValue;
    },
    subRows: [],
    getLeafRows: () => flattenBy(row.subRows, (d2) => d2.subRows),
    getParentRow: () => row.parentId ? table.getRow(row.parentId, true) : void 0,
    getParentRows: () => {
      let parentRows = [];
      let currentRow = row;
      while (true) {
        const parentRow = currentRow.getParentRow();
        if (!parentRow) break;
        parentRows.push(parentRow);
        currentRow = parentRow;
      }
      return parentRows.reverse();
    },
    getAllCells: memo(() => [table.getAllLeafColumns()], (leafColumns) => {
      return leafColumns.map((column) => {
        return createCell(table, row, column, column.id);
      });
    }, getMemoOptions(table.options, "debugRows", "getAllCells")),
    _getAllCellsByColumnId: memo(() => [row.getAllCells()], (allCells) => {
      return allCells.reduce((acc, cell) => {
        acc[cell.column.id] = cell;
        return acc;
      }, {});
    }, getMemoOptions(table.options, "debugRows", "getAllCellsByColumnId"))
  };
  for (let i2 = 0; i2 < table._features.length; i2++) {
    const feature = table._features[i2];
    feature == null || feature.createRow == null || feature.createRow(row, table);
  }
  return row;
};
const ColumnFaceting = {
  createColumn: (column, table) => {
    column._getFacetedRowModel = table.options.getFacetedRowModel && table.options.getFacetedRowModel(table, column.id);
    column.getFacetedRowModel = () => {
      if (!column._getFacetedRowModel) {
        return table.getPreFilteredRowModel();
      }
      return column._getFacetedRowModel();
    };
    column._getFacetedUniqueValues = table.options.getFacetedUniqueValues && table.options.getFacetedUniqueValues(table, column.id);
    column.getFacetedUniqueValues = () => {
      if (!column._getFacetedUniqueValues) {
        return /* @__PURE__ */ new Map();
      }
      return column._getFacetedUniqueValues();
    };
    column._getFacetedMinMaxValues = table.options.getFacetedMinMaxValues && table.options.getFacetedMinMaxValues(table, column.id);
    column.getFacetedMinMaxValues = () => {
      if (!column._getFacetedMinMaxValues) {
        return void 0;
      }
      return column._getFacetedMinMaxValues();
    };
  }
};
const includesString = (row, columnId, filterValue) => {
  var _filterValue$toString, _row$getValue;
  const search = filterValue == null || (_filterValue$toString = filterValue.toString()) == null ? void 0 : _filterValue$toString.toLowerCase();
  return Boolean((_row$getValue = row.getValue(columnId)) == null || (_row$getValue = _row$getValue.toString()) == null || (_row$getValue = _row$getValue.toLowerCase()) == null ? void 0 : _row$getValue.includes(search));
};
includesString.autoRemove = (val) => testFalsey(val);
const includesStringSensitive = (row, columnId, filterValue) => {
  var _row$getValue2;
  return Boolean((_row$getValue2 = row.getValue(columnId)) == null || (_row$getValue2 = _row$getValue2.toString()) == null ? void 0 : _row$getValue2.includes(filterValue));
};
includesStringSensitive.autoRemove = (val) => testFalsey(val);
const equalsString = (row, columnId, filterValue) => {
  var _row$getValue3;
  return ((_row$getValue3 = row.getValue(columnId)) == null || (_row$getValue3 = _row$getValue3.toString()) == null ? void 0 : _row$getValue3.toLowerCase()) === (filterValue == null ? void 0 : filterValue.toLowerCase());
};
equalsString.autoRemove = (val) => testFalsey(val);
const arrIncludes = (row, columnId, filterValue) => {
  var _row$getValue4;
  return (_row$getValue4 = row.getValue(columnId)) == null ? void 0 : _row$getValue4.includes(filterValue);
};
arrIncludes.autoRemove = (val) => testFalsey(val);
const arrIncludesAll = (row, columnId, filterValue) => {
  return !filterValue.some((val) => {
    var _row$getValue5;
    return !((_row$getValue5 = row.getValue(columnId)) != null && _row$getValue5.includes(val));
  });
};
arrIncludesAll.autoRemove = (val) => testFalsey(val) || !(val != null && val.length);
const arrIncludesSome = (row, columnId, filterValue) => {
  return filterValue.some((val) => {
    var _row$getValue6;
    return (_row$getValue6 = row.getValue(columnId)) == null ? void 0 : _row$getValue6.includes(val);
  });
};
arrIncludesSome.autoRemove = (val) => testFalsey(val) || !(val != null && val.length);
const equals = (row, columnId, filterValue) => {
  return row.getValue(columnId) === filterValue;
};
equals.autoRemove = (val) => testFalsey(val);
const weakEquals = (row, columnId, filterValue) => {
  return row.getValue(columnId) == filterValue;
};
weakEquals.autoRemove = (val) => testFalsey(val);
const inNumberRange = (row, columnId, filterValue) => {
  let [min2, max2] = filterValue;
  const rowValue = row.getValue(columnId);
  return rowValue >= min2 && rowValue <= max2;
};
inNumberRange.resolveFilterValue = (val) => {
  let [unsafeMin, unsafeMax] = val;
  let parsedMin = typeof unsafeMin !== "number" ? parseFloat(unsafeMin) : unsafeMin;
  let parsedMax = typeof unsafeMax !== "number" ? parseFloat(unsafeMax) : unsafeMax;
  let min2 = unsafeMin === null || Number.isNaN(parsedMin) ? -Infinity : parsedMin;
  let max2 = unsafeMax === null || Number.isNaN(parsedMax) ? Infinity : parsedMax;
  if (min2 > max2) {
    const temp = min2;
    min2 = max2;
    max2 = temp;
  }
  return [min2, max2];
};
inNumberRange.autoRemove = (val) => testFalsey(val) || testFalsey(val[0]) && testFalsey(val[1]);
const filterFns = {
  includesString,
  includesStringSensitive,
  equalsString,
  arrIncludes,
  arrIncludesAll,
  arrIncludesSome,
  equals,
  weakEquals,
  inNumberRange
};
function testFalsey(val) {
  return val === void 0 || val === null || val === "";
}
const ColumnFiltering = {
  getDefaultColumnDef: () => {
    return {
      filterFn: "auto"
    };
  },
  getInitialState: (state2) => {
    return {
      columnFilters: [],
      ...state2
    };
  },
  getDefaultOptions: (table) => {
    return {
      onColumnFiltersChange: makeStateUpdater("columnFilters", table),
      filterFromLeafRows: false,
      maxLeafRowFilterDepth: 100
    };
  },
  createColumn: (column, table) => {
    column.getAutoFilterFn = () => {
      const firstRow = table.getCoreRowModel().flatRows[0];
      const value = firstRow == null ? void 0 : firstRow.getValue(column.id);
      if (typeof value === "string") {
        return filterFns.includesString;
      }
      if (typeof value === "number") {
        return filterFns.inNumberRange;
      }
      if (typeof value === "boolean") {
        return filterFns.equals;
      }
      if (value !== null && typeof value === "object") {
        return filterFns.equals;
      }
      if (Array.isArray(value)) {
        return filterFns.arrIncludes;
      }
      return filterFns.weakEquals;
    };
    column.getFilterFn = () => {
      var _table$options$filter, _table$options$filter2;
      return isFunction(column.columnDef.filterFn) ? column.columnDef.filterFn : column.columnDef.filterFn === "auto" ? column.getAutoFilterFn() : (
        // @ts-ignore
        (_table$options$filter = (_table$options$filter2 = table.options.filterFns) == null ? void 0 : _table$options$filter2[column.columnDef.filterFn]) != null ? _table$options$filter : filterFns[column.columnDef.filterFn]
      );
    };
    column.getCanFilter = () => {
      var _column$columnDef$ena, _table$options$enable, _table$options$enable2;
      return ((_column$columnDef$ena = column.columnDef.enableColumnFilter) != null ? _column$columnDef$ena : true) && ((_table$options$enable = table.options.enableColumnFilters) != null ? _table$options$enable : true) && ((_table$options$enable2 = table.options.enableFilters) != null ? _table$options$enable2 : true) && !!column.accessorFn;
    };
    column.getIsFiltered = () => column.getFilterIndex() > -1;
    column.getFilterValue = () => {
      var _table$getState$colum;
      return (_table$getState$colum = table.getState().columnFilters) == null || (_table$getState$colum = _table$getState$colum.find((d2) => d2.id === column.id)) == null ? void 0 : _table$getState$colum.value;
    };
    column.getFilterIndex = () => {
      var _table$getState$colum2, _table$getState$colum3;
      return (_table$getState$colum2 = (_table$getState$colum3 = table.getState().columnFilters) == null ? void 0 : _table$getState$colum3.findIndex((d2) => d2.id === column.id)) != null ? _table$getState$colum2 : -1;
    };
    column.setFilterValue = (value) => {
      table.setColumnFilters((old) => {
        const filterFn = column.getFilterFn();
        const previousFilter = old == null ? void 0 : old.find((d2) => d2.id === column.id);
        const newFilter = functionalUpdate(value, previousFilter ? previousFilter.value : void 0);
        if (shouldAutoRemoveFilter(filterFn, newFilter, column)) {
          var _old$filter;
          return (_old$filter = old == null ? void 0 : old.filter((d2) => d2.id !== column.id)) != null ? _old$filter : [];
        }
        const newFilterObj = {
          id: column.id,
          value: newFilter
        };
        if (previousFilter) {
          var _old$map;
          return (_old$map = old == null ? void 0 : old.map((d2) => {
            if (d2.id === column.id) {
              return newFilterObj;
            }
            return d2;
          })) != null ? _old$map : [];
        }
        if (old != null && old.length) {
          return [...old, newFilterObj];
        }
        return [newFilterObj];
      });
    };
  },
  createRow: (row, _table) => {
    row.columnFilters = {};
    row.columnFiltersMeta = {};
  },
  createTable: (table) => {
    table.setColumnFilters = (updater) => {
      const leafColumns = table.getAllLeafColumns();
      const updateFn = (old) => {
        var _functionalUpdate;
        return (_functionalUpdate = functionalUpdate(updater, old)) == null ? void 0 : _functionalUpdate.filter((filter) => {
          const column = leafColumns.find((d2) => d2.id === filter.id);
          if (column) {
            const filterFn = column.getFilterFn();
            if (shouldAutoRemoveFilter(filterFn, filter.value, column)) {
              return false;
            }
          }
          return true;
        });
      };
      table.options.onColumnFiltersChange == null || table.options.onColumnFiltersChange(updateFn);
    };
    table.resetColumnFilters = (defaultState) => {
      var _table$initialState$c, _table$initialState;
      table.setColumnFilters(defaultState ? [] : (_table$initialState$c = (_table$initialState = table.initialState) == null ? void 0 : _table$initialState.columnFilters) != null ? _table$initialState$c : []);
    };
    table.getPreFilteredRowModel = () => table.getCoreRowModel();
    table.getFilteredRowModel = () => {
      if (!table._getFilteredRowModel && table.options.getFilteredRowModel) {
        table._getFilteredRowModel = table.options.getFilteredRowModel(table);
      }
      if (table.options.manualFiltering || !table._getFilteredRowModel) {
        return table.getPreFilteredRowModel();
      }
      return table._getFilteredRowModel();
    };
  }
};
function shouldAutoRemoveFilter(filterFn, value, column) {
  return (filterFn && filterFn.autoRemove ? filterFn.autoRemove(value, column) : false) || typeof value === "undefined" || typeof value === "string" && !value;
}
const sum = (columnId, _leafRows, childRows) => {
  return childRows.reduce((sum2, next) => {
    const nextValue = next.getValue(columnId);
    return sum2 + (typeof nextValue === "number" ? nextValue : 0);
  }, 0);
};
const min = (columnId, _leafRows, childRows) => {
  let min2;
  childRows.forEach((row) => {
    const value = row.getValue(columnId);
    if (value != null && (min2 > value || min2 === void 0 && value >= value)) {
      min2 = value;
    }
  });
  return min2;
};
const max = (columnId, _leafRows, childRows) => {
  let max2;
  childRows.forEach((row) => {
    const value = row.getValue(columnId);
    if (value != null && (max2 < value || max2 === void 0 && value >= value)) {
      max2 = value;
    }
  });
  return max2;
};
const extent = (columnId, _leafRows, childRows) => {
  let min2;
  let max2;
  childRows.forEach((row) => {
    const value = row.getValue(columnId);
    if (value != null) {
      if (min2 === void 0) {
        if (value >= value) min2 = max2 = value;
      } else {
        if (min2 > value) min2 = value;
        if (max2 < value) max2 = value;
      }
    }
  });
  return [min2, max2];
};
const mean = (columnId, leafRows) => {
  let count2 = 0;
  let sum2 = 0;
  leafRows.forEach((row) => {
    let value = row.getValue(columnId);
    if (value != null && (value = +value) >= value) {
      ++count2, sum2 += value;
    }
  });
  if (count2) return sum2 / count2;
  return;
};
const median = (columnId, leafRows) => {
  if (!leafRows.length) {
    return;
  }
  const values = leafRows.map((row) => row.getValue(columnId));
  if (!isNumberArray(values)) {
    return;
  }
  if (values.length === 1) {
    return values[0];
  }
  const mid = Math.floor(values.length / 2);
  const nums = values.sort((a2, b2) => a2 - b2);
  return values.length % 2 !== 0 ? nums[mid] : (nums[mid - 1] + nums[mid]) / 2;
};
const unique = (columnId, leafRows) => {
  return Array.from(new Set(leafRows.map((d2) => d2.getValue(columnId))).values());
};
const uniqueCount = (columnId, leafRows) => {
  return new Set(leafRows.map((d2) => d2.getValue(columnId))).size;
};
const count = (_columnId, leafRows) => {
  return leafRows.length;
};
const aggregationFns = {
  sum,
  min,
  max,
  extent,
  mean,
  median,
  unique,
  uniqueCount,
  count
};
const ColumnGrouping = {
  getDefaultColumnDef: () => {
    return {
      aggregatedCell: (props) => {
        var _toString, _props$getValue;
        return (_toString = (_props$getValue = props.getValue()) == null || _props$getValue.toString == null ? void 0 : _props$getValue.toString()) != null ? _toString : null;
      },
      aggregationFn: "auto"
    };
  },
  getInitialState: (state2) => {
    return {
      grouping: [],
      ...state2
    };
  },
  getDefaultOptions: (table) => {
    return {
      onGroupingChange: makeStateUpdater("grouping", table),
      groupedColumnMode: "reorder"
    };
  },
  createColumn: (column, table) => {
    column.toggleGrouping = () => {
      table.setGrouping((old) => {
        if (old != null && old.includes(column.id)) {
          return old.filter((d2) => d2 !== column.id);
        }
        return [...old != null ? old : [], column.id];
      });
    };
    column.getCanGroup = () => {
      var _column$columnDef$ena, _table$options$enable;
      return ((_column$columnDef$ena = column.columnDef.enableGrouping) != null ? _column$columnDef$ena : true) && ((_table$options$enable = table.options.enableGrouping) != null ? _table$options$enable : true) && (!!column.accessorFn || !!column.columnDef.getGroupingValue);
    };
    column.getIsGrouped = () => {
      var _table$getState$group;
      return (_table$getState$group = table.getState().grouping) == null ? void 0 : _table$getState$group.includes(column.id);
    };
    column.getGroupedIndex = () => {
      var _table$getState$group2;
      return (_table$getState$group2 = table.getState().grouping) == null ? void 0 : _table$getState$group2.indexOf(column.id);
    };
    column.getToggleGroupingHandler = () => {
      const canGroup = column.getCanGroup();
      return () => {
        if (!canGroup) return;
        column.toggleGrouping();
      };
    };
    column.getAutoAggregationFn = () => {
      const firstRow = table.getCoreRowModel().flatRows[0];
      const value = firstRow == null ? void 0 : firstRow.getValue(column.id);
      if (typeof value === "number") {
        return aggregationFns.sum;
      }
      if (Object.prototype.toString.call(value) === "[object Date]") {
        return aggregationFns.extent;
      }
    };
    column.getAggregationFn = () => {
      var _table$options$aggreg, _table$options$aggreg2;
      if (!column) {
        throw new Error();
      }
      return isFunction(column.columnDef.aggregationFn) ? column.columnDef.aggregationFn : column.columnDef.aggregationFn === "auto" ? column.getAutoAggregationFn() : (_table$options$aggreg = (_table$options$aggreg2 = table.options.aggregationFns) == null ? void 0 : _table$options$aggreg2[column.columnDef.aggregationFn]) != null ? _table$options$aggreg : aggregationFns[column.columnDef.aggregationFn];
    };
  },
  createTable: (table) => {
    table.setGrouping = (updater) => table.options.onGroupingChange == null ? void 0 : table.options.onGroupingChange(updater);
    table.resetGrouping = (defaultState) => {
      var _table$initialState$g, _table$initialState;
      table.setGrouping(defaultState ? [] : (_table$initialState$g = (_table$initialState = table.initialState) == null ? void 0 : _table$initialState.grouping) != null ? _table$initialState$g : []);
    };
    table.getPreGroupedRowModel = () => table.getFilteredRowModel();
    table.getGroupedRowModel = () => {
      if (!table._getGroupedRowModel && table.options.getGroupedRowModel) {
        table._getGroupedRowModel = table.options.getGroupedRowModel(table);
      }
      if (table.options.manualGrouping || !table._getGroupedRowModel) {
        return table.getPreGroupedRowModel();
      }
      return table._getGroupedRowModel();
    };
  },
  createRow: (row, table) => {
    row.getIsGrouped = () => !!row.groupingColumnId;
    row.getGroupingValue = (columnId) => {
      if (row._groupingValuesCache.hasOwnProperty(columnId)) {
        return row._groupingValuesCache[columnId];
      }
      const column = table.getColumn(columnId);
      if (!(column != null && column.columnDef.getGroupingValue)) {
        return row.getValue(columnId);
      }
      row._groupingValuesCache[columnId] = column.columnDef.getGroupingValue(row.original);
      return row._groupingValuesCache[columnId];
    };
    row._groupingValuesCache = {};
  },
  createCell: (cell, column, row, table) => {
    cell.getIsGrouped = () => column.getIsGrouped() && column.id === row.groupingColumnId;
    cell.getIsPlaceholder = () => !cell.getIsGrouped() && column.getIsGrouped();
    cell.getIsAggregated = () => {
      var _row$subRows;
      return !cell.getIsGrouped() && !cell.getIsPlaceholder() && !!((_row$subRows = row.subRows) != null && _row$subRows.length);
    };
  }
};
function orderColumns(leafColumns, grouping, groupedColumnMode) {
  if (!(grouping != null && grouping.length) || !groupedColumnMode) {
    return leafColumns;
  }
  const nonGroupingColumns = leafColumns.filter((col) => !grouping.includes(col.id));
  if (groupedColumnMode === "remove") {
    return nonGroupingColumns;
  }
  const groupingColumns = grouping.map((g2) => leafColumns.find((col) => col.id === g2)).filter(Boolean);
  return [...groupingColumns, ...nonGroupingColumns];
}
const ColumnOrdering = {
  getInitialState: (state2) => {
    return {
      columnOrder: [],
      ...state2
    };
  },
  getDefaultOptions: (table) => {
    return {
      onColumnOrderChange: makeStateUpdater("columnOrder", table)
    };
  },
  createColumn: (column, table) => {
    column.getIndex = memo((position) => [_getVisibleLeafColumns(table, position)], (columns2) => columns2.findIndex((d2) => d2.id === column.id), getMemoOptions(table.options, "debugColumns", "getIndex"));
    column.getIsFirstColumn = (position) => {
      var _columns$;
      const columns2 = _getVisibleLeafColumns(table, position);
      return ((_columns$ = columns2[0]) == null ? void 0 : _columns$.id) === column.id;
    };
    column.getIsLastColumn = (position) => {
      var _columns;
      const columns2 = _getVisibleLeafColumns(table, position);
      return ((_columns = columns2[columns2.length - 1]) == null ? void 0 : _columns.id) === column.id;
    };
  },
  createTable: (table) => {
    table.setColumnOrder = (updater) => table.options.onColumnOrderChange == null ? void 0 : table.options.onColumnOrderChange(updater);
    table.resetColumnOrder = (defaultState) => {
      var _table$initialState$c;
      table.setColumnOrder(defaultState ? [] : (_table$initialState$c = table.initialState.columnOrder) != null ? _table$initialState$c : []);
    };
    table._getOrderColumnsFn = memo(() => [table.getState().columnOrder, table.getState().grouping, table.options.groupedColumnMode], (columnOrder, grouping, groupedColumnMode) => (columns2) => {
      let orderedColumns = [];
      if (!(columnOrder != null && columnOrder.length)) {
        orderedColumns = columns2;
      } else {
        const columnOrderCopy = [...columnOrder];
        const columnsCopy = [...columns2];
        while (columnsCopy.length && columnOrderCopy.length) {
          const targetColumnId = columnOrderCopy.shift();
          const foundIndex = columnsCopy.findIndex((d2) => d2.id === targetColumnId);
          if (foundIndex > -1) {
            orderedColumns.push(columnsCopy.splice(foundIndex, 1)[0]);
          }
        }
        orderedColumns = [...orderedColumns, ...columnsCopy];
      }
      return orderColumns(orderedColumns, grouping, groupedColumnMode);
    }, getMemoOptions(table.options, "debugTable", "_getOrderColumnsFn"));
  }
};
const getDefaultColumnPinningState = () => ({
  left: [],
  right: []
});
const ColumnPinning = {
  getInitialState: (state2) => {
    return {
      columnPinning: getDefaultColumnPinningState(),
      ...state2
    };
  },
  getDefaultOptions: (table) => {
    return {
      onColumnPinningChange: makeStateUpdater("columnPinning", table)
    };
  },
  createColumn: (column, table) => {
    column.pin = (position) => {
      const columnIds = column.getLeafColumns().map((d2) => d2.id).filter(Boolean);
      table.setColumnPinning((old) => {
        var _old$left3, _old$right3;
        if (position === "right") {
          var _old$left, _old$right;
          return {
            left: ((_old$left = old == null ? void 0 : old.left) != null ? _old$left : []).filter((d2) => !(columnIds != null && columnIds.includes(d2))),
            right: [...((_old$right = old == null ? void 0 : old.right) != null ? _old$right : []).filter((d2) => !(columnIds != null && columnIds.includes(d2))), ...columnIds]
          };
        }
        if (position === "left") {
          var _old$left2, _old$right2;
          return {
            left: [...((_old$left2 = old == null ? void 0 : old.left) != null ? _old$left2 : []).filter((d2) => !(columnIds != null && columnIds.includes(d2))), ...columnIds],
            right: ((_old$right2 = old == null ? void 0 : old.right) != null ? _old$right2 : []).filter((d2) => !(columnIds != null && columnIds.includes(d2)))
          };
        }
        return {
          left: ((_old$left3 = old == null ? void 0 : old.left) != null ? _old$left3 : []).filter((d2) => !(columnIds != null && columnIds.includes(d2))),
          right: ((_old$right3 = old == null ? void 0 : old.right) != null ? _old$right3 : []).filter((d2) => !(columnIds != null && columnIds.includes(d2)))
        };
      });
    };
    column.getCanPin = () => {
      const leafColumns = column.getLeafColumns();
      return leafColumns.some((d2) => {
        var _d$columnDef$enablePi, _ref, _table$options$enable;
        return ((_d$columnDef$enablePi = d2.columnDef.enablePinning) != null ? _d$columnDef$enablePi : true) && ((_ref = (_table$options$enable = table.options.enableColumnPinning) != null ? _table$options$enable : table.options.enablePinning) != null ? _ref : true);
      });
    };
    column.getIsPinned = () => {
      const leafColumnIds = column.getLeafColumns().map((d2) => d2.id);
      const {
        left,
        right
      } = table.getState().columnPinning;
      const isLeft = leafColumnIds.some((d2) => left == null ? void 0 : left.includes(d2));
      const isRight = leafColumnIds.some((d2) => right == null ? void 0 : right.includes(d2));
      return isLeft ? "left" : isRight ? "right" : false;
    };
    column.getPinnedIndex = () => {
      var _table$getState$colum, _table$getState$colum2;
      const position = column.getIsPinned();
      return position ? (_table$getState$colum = (_table$getState$colum2 = table.getState().columnPinning) == null || (_table$getState$colum2 = _table$getState$colum2[position]) == null ? void 0 : _table$getState$colum2.indexOf(column.id)) != null ? _table$getState$colum : -1 : 0;
    };
  },
  createRow: (row, table) => {
    row.getCenterVisibleCells = memo(() => [row._getAllVisibleCells(), table.getState().columnPinning.left, table.getState().columnPinning.right], (allCells, left, right) => {
      const leftAndRight = [...left != null ? left : [], ...right != null ? right : []];
      return allCells.filter((d2) => !leftAndRight.includes(d2.column.id));
    }, getMemoOptions(table.options, "debugRows", "getCenterVisibleCells"));
    row.getLeftVisibleCells = memo(() => [row._getAllVisibleCells(), table.getState().columnPinning.left], (allCells, left) => {
      const cells = (left != null ? left : []).map((columnId) => allCells.find((cell) => cell.column.id === columnId)).filter(Boolean).map((d2) => ({
        ...d2,
        position: "left"
      }));
      return cells;
    }, getMemoOptions(table.options, "debugRows", "getLeftVisibleCells"));
    row.getRightVisibleCells = memo(() => [row._getAllVisibleCells(), table.getState().columnPinning.right], (allCells, right) => {
      const cells = (right != null ? right : []).map((columnId) => allCells.find((cell) => cell.column.id === columnId)).filter(Boolean).map((d2) => ({
        ...d2,
        position: "right"
      }));
      return cells;
    }, getMemoOptions(table.options, "debugRows", "getRightVisibleCells"));
  },
  createTable: (table) => {
    table.setColumnPinning = (updater) => table.options.onColumnPinningChange == null ? void 0 : table.options.onColumnPinningChange(updater);
    table.resetColumnPinning = (defaultState) => {
      var _table$initialState$c, _table$initialState;
      return table.setColumnPinning(defaultState ? getDefaultColumnPinningState() : (_table$initialState$c = (_table$initialState = table.initialState) == null ? void 0 : _table$initialState.columnPinning) != null ? _table$initialState$c : getDefaultColumnPinningState());
    };
    table.getIsSomeColumnsPinned = (position) => {
      var _pinningState$positio;
      const pinningState = table.getState().columnPinning;
      if (!position) {
        var _pinningState$left, _pinningState$right;
        return Boolean(((_pinningState$left = pinningState.left) == null ? void 0 : _pinningState$left.length) || ((_pinningState$right = pinningState.right) == null ? void 0 : _pinningState$right.length));
      }
      return Boolean((_pinningState$positio = pinningState[position]) == null ? void 0 : _pinningState$positio.length);
    };
    table.getLeftLeafColumns = memo(() => [table.getAllLeafColumns(), table.getState().columnPinning.left], (allColumns, left) => {
      return (left != null ? left : []).map((columnId) => allColumns.find((column) => column.id === columnId)).filter(Boolean);
    }, getMemoOptions(table.options, "debugColumns", "getLeftLeafColumns"));
    table.getRightLeafColumns = memo(() => [table.getAllLeafColumns(), table.getState().columnPinning.right], (allColumns, right) => {
      return (right != null ? right : []).map((columnId) => allColumns.find((column) => column.id === columnId)).filter(Boolean);
    }, getMemoOptions(table.options, "debugColumns", "getRightLeafColumns"));
    table.getCenterLeafColumns = memo(() => [table.getAllLeafColumns(), table.getState().columnPinning.left, table.getState().columnPinning.right], (allColumns, left, right) => {
      const leftAndRight = [...left != null ? left : [], ...right != null ? right : []];
      return allColumns.filter((d2) => !leftAndRight.includes(d2.id));
    }, getMemoOptions(table.options, "debugColumns", "getCenterLeafColumns"));
  }
};
function safelyAccessDocument(_document) {
  return _document || (typeof document !== "undefined" ? document : null);
}
const defaultColumnSizing = {
  size: 150,
  minSize: 20,
  maxSize: Number.MAX_SAFE_INTEGER
};
const getDefaultColumnSizingInfoState = () => ({
  startOffset: null,
  startSize: null,
  deltaOffset: null,
  deltaPercentage: null,
  isResizingColumn: false,
  columnSizingStart: []
});
const ColumnSizing = {
  getDefaultColumnDef: () => {
    return defaultColumnSizing;
  },
  getInitialState: (state2) => {
    return {
      columnSizing: {},
      columnSizingInfo: getDefaultColumnSizingInfoState(),
      ...state2
    };
  },
  getDefaultOptions: (table) => {
    return {
      columnResizeMode: "onEnd",
      columnResizeDirection: "ltr",
      onColumnSizingChange: makeStateUpdater("columnSizing", table),
      onColumnSizingInfoChange: makeStateUpdater("columnSizingInfo", table)
    };
  },
  createColumn: (column, table) => {
    column.getSize = () => {
      var _column$columnDef$min, _ref, _column$columnDef$max;
      const columnSize = table.getState().columnSizing[column.id];
      return Math.min(Math.max((_column$columnDef$min = column.columnDef.minSize) != null ? _column$columnDef$min : defaultColumnSizing.minSize, (_ref = columnSize != null ? columnSize : column.columnDef.size) != null ? _ref : defaultColumnSizing.size), (_column$columnDef$max = column.columnDef.maxSize) != null ? _column$columnDef$max : defaultColumnSizing.maxSize);
    };
    column.getStart = memo((position) => [position, _getVisibleLeafColumns(table, position), table.getState().columnSizing], (position, columns2) => columns2.slice(0, column.getIndex(position)).reduce((sum2, column2) => sum2 + column2.getSize(), 0), getMemoOptions(table.options, "debugColumns", "getStart"));
    column.getAfter = memo((position) => [position, _getVisibleLeafColumns(table, position), table.getState().columnSizing], (position, columns2) => columns2.slice(column.getIndex(position) + 1).reduce((sum2, column2) => sum2 + column2.getSize(), 0), getMemoOptions(table.options, "debugColumns", "getAfter"));
    column.resetSize = () => {
      table.setColumnSizing((_ref2) => {
        let {
          [column.id]: _2,
          ...rest
        } = _ref2;
        return rest;
      });
    };
    column.getCanResize = () => {
      var _column$columnDef$ena, _table$options$enable;
      return ((_column$columnDef$ena = column.columnDef.enableResizing) != null ? _column$columnDef$ena : true) && ((_table$options$enable = table.options.enableColumnResizing) != null ? _table$options$enable : true);
    };
    column.getIsResizing = () => {
      return table.getState().columnSizingInfo.isResizingColumn === column.id;
    };
  },
  createHeader: (header, table) => {
    header.getSize = () => {
      let sum2 = 0;
      const recurse = (header2) => {
        if (header2.subHeaders.length) {
          header2.subHeaders.forEach(recurse);
        } else {
          var _header$column$getSiz;
          sum2 += (_header$column$getSiz = header2.column.getSize()) != null ? _header$column$getSiz : 0;
        }
      };
      recurse(header);
      return sum2;
    };
    header.getStart = () => {
      if (header.index > 0) {
        const prevSiblingHeader = header.headerGroup.headers[header.index - 1];
        return prevSiblingHeader.getStart() + prevSiblingHeader.getSize();
      }
      return 0;
    };
    header.getResizeHandler = (_contextDocument) => {
      const column = table.getColumn(header.column.id);
      const canResize = column == null ? void 0 : column.getCanResize();
      return (e2) => {
        if (!column || !canResize) {
          return;
        }
        e2.persist == null || e2.persist();
        if (isTouchStartEvent(e2)) {
          if (e2.touches && e2.touches.length > 1) {
            return;
          }
        }
        const startSize = header.getSize();
        const columnSizingStart = header ? header.getLeafHeaders().map((d2) => [d2.column.id, d2.column.getSize()]) : [[column.id, column.getSize()]];
        const clientX = isTouchStartEvent(e2) ? Math.round(e2.touches[0].clientX) : e2.clientX;
        const newColumnSizing = {};
        const updateOffset = (eventType, clientXPos) => {
          if (typeof clientXPos !== "number") {
            return;
          }
          table.setColumnSizingInfo((old) => {
            var _old$startOffset, _old$startSize;
            const deltaDirection = table.options.columnResizeDirection === "rtl" ? -1 : 1;
            const deltaOffset = (clientXPos - ((_old$startOffset = old == null ? void 0 : old.startOffset) != null ? _old$startOffset : 0)) * deltaDirection;
            const deltaPercentage = Math.max(deltaOffset / ((_old$startSize = old == null ? void 0 : old.startSize) != null ? _old$startSize : 0), -0.999999);
            old.columnSizingStart.forEach((_ref3) => {
              let [columnId, headerSize] = _ref3;
              newColumnSizing[columnId] = Math.round(Math.max(headerSize + headerSize * deltaPercentage, 0) * 100) / 100;
            });
            return {
              ...old,
              deltaOffset,
              deltaPercentage
            };
          });
          if (table.options.columnResizeMode === "onChange" || eventType === "end") {
            table.setColumnSizing((old) => ({
              ...old,
              ...newColumnSizing
            }));
          }
        };
        const onMove = (clientXPos) => updateOffset("move", clientXPos);
        const onEnd = (clientXPos) => {
          updateOffset("end", clientXPos);
          table.setColumnSizingInfo((old) => ({
            ...old,
            isResizingColumn: false,
            startOffset: null,
            startSize: null,
            deltaOffset: null,
            deltaPercentage: null,
            columnSizingStart: []
          }));
        };
        const contextDocument = safelyAccessDocument(_contextDocument);
        const mouseEvents = {
          moveHandler: (e3) => onMove(e3.clientX),
          upHandler: (e3) => {
            contextDocument == null || contextDocument.removeEventListener("mousemove", mouseEvents.moveHandler);
            contextDocument == null || contextDocument.removeEventListener("mouseup", mouseEvents.upHandler);
            onEnd(e3.clientX);
          }
        };
        const touchEvents = {
          moveHandler: (e3) => {
            if (e3.cancelable) {
              e3.preventDefault();
              e3.stopPropagation();
            }
            onMove(e3.touches[0].clientX);
            return false;
          },
          upHandler: (e3) => {
            var _e$touches$;
            contextDocument == null || contextDocument.removeEventListener("touchmove", touchEvents.moveHandler);
            contextDocument == null || contextDocument.removeEventListener("touchend", touchEvents.upHandler);
            if (e3.cancelable) {
              e3.preventDefault();
              e3.stopPropagation();
            }
            onEnd((_e$touches$ = e3.touches[0]) == null ? void 0 : _e$touches$.clientX);
          }
        };
        const passiveIfSupported = passiveEventSupported() ? {
          passive: false
        } : false;
        if (isTouchStartEvent(e2)) {
          contextDocument == null || contextDocument.addEventListener("touchmove", touchEvents.moveHandler, passiveIfSupported);
          contextDocument == null || contextDocument.addEventListener("touchend", touchEvents.upHandler, passiveIfSupported);
        } else {
          contextDocument == null || contextDocument.addEventListener("mousemove", mouseEvents.moveHandler, passiveIfSupported);
          contextDocument == null || contextDocument.addEventListener("mouseup", mouseEvents.upHandler, passiveIfSupported);
        }
        table.setColumnSizingInfo((old) => ({
          ...old,
          startOffset: clientX,
          startSize,
          deltaOffset: 0,
          deltaPercentage: 0,
          columnSizingStart,
          isResizingColumn: column.id
        }));
      };
    };
  },
  createTable: (table) => {
    table.setColumnSizing = (updater) => table.options.onColumnSizingChange == null ? void 0 : table.options.onColumnSizingChange(updater);
    table.setColumnSizingInfo = (updater) => table.options.onColumnSizingInfoChange == null ? void 0 : table.options.onColumnSizingInfoChange(updater);
    table.resetColumnSizing = (defaultState) => {
      var _table$initialState$c;
      table.setColumnSizing(defaultState ? {} : (_table$initialState$c = table.initialState.columnSizing) != null ? _table$initialState$c : {});
    };
    table.resetHeaderSizeInfo = (defaultState) => {
      var _table$initialState$c2;
      table.setColumnSizingInfo(defaultState ? getDefaultColumnSizingInfoState() : (_table$initialState$c2 = table.initialState.columnSizingInfo) != null ? _table$initialState$c2 : getDefaultColumnSizingInfoState());
    };
    table.getTotalSize = () => {
      var _table$getHeaderGroup, _table$getHeaderGroup2;
      return (_table$getHeaderGroup = (_table$getHeaderGroup2 = table.getHeaderGroups()[0]) == null ? void 0 : _table$getHeaderGroup2.headers.reduce((sum2, header) => {
        return sum2 + header.getSize();
      }, 0)) != null ? _table$getHeaderGroup : 0;
    };
    table.getLeftTotalSize = () => {
      var _table$getLeftHeaderG, _table$getLeftHeaderG2;
      return (_table$getLeftHeaderG = (_table$getLeftHeaderG2 = table.getLeftHeaderGroups()[0]) == null ? void 0 : _table$getLeftHeaderG2.headers.reduce((sum2, header) => {
        return sum2 + header.getSize();
      }, 0)) != null ? _table$getLeftHeaderG : 0;
    };
    table.getCenterTotalSize = () => {
      var _table$getCenterHeade, _table$getCenterHeade2;
      return (_table$getCenterHeade = (_table$getCenterHeade2 = table.getCenterHeaderGroups()[0]) == null ? void 0 : _table$getCenterHeade2.headers.reduce((sum2, header) => {
        return sum2 + header.getSize();
      }, 0)) != null ? _table$getCenterHeade : 0;
    };
    table.getRightTotalSize = () => {
      var _table$getRightHeader, _table$getRightHeader2;
      return (_table$getRightHeader = (_table$getRightHeader2 = table.getRightHeaderGroups()[0]) == null ? void 0 : _table$getRightHeader2.headers.reduce((sum2, header) => {
        return sum2 + header.getSize();
      }, 0)) != null ? _table$getRightHeader : 0;
    };
  }
};
let passiveSupported = null;
function passiveEventSupported() {
  if (typeof passiveSupported === "boolean") return passiveSupported;
  let supported = false;
  try {
    const options = {
      get passive() {
        supported = true;
        return false;
      }
    };
    const noop2 = () => {
    };
    window.addEventListener("test", noop2, options);
    window.removeEventListener("test", noop2);
  } catch (err) {
    supported = false;
  }
  passiveSupported = supported;
  return passiveSupported;
}
function isTouchStartEvent(e2) {
  return e2.type === "touchstart";
}
const ColumnVisibility = {
  getInitialState: (state2) => {
    return {
      columnVisibility: {},
      ...state2
    };
  },
  getDefaultOptions: (table) => {
    return {
      onColumnVisibilityChange: makeStateUpdater("columnVisibility", table)
    };
  },
  createColumn: (column, table) => {
    column.toggleVisibility = (value) => {
      if (column.getCanHide()) {
        table.setColumnVisibility((old) => ({
          ...old,
          [column.id]: value != null ? value : !column.getIsVisible()
        }));
      }
    };
    column.getIsVisible = () => {
      var _ref, _table$getState$colum;
      const childColumns = column.columns;
      return (_ref = childColumns.length ? childColumns.some((c2) => c2.getIsVisible()) : (_table$getState$colum = table.getState().columnVisibility) == null ? void 0 : _table$getState$colum[column.id]) != null ? _ref : true;
    };
    column.getCanHide = () => {
      var _column$columnDef$ena, _table$options$enable;
      return ((_column$columnDef$ena = column.columnDef.enableHiding) != null ? _column$columnDef$ena : true) && ((_table$options$enable = table.options.enableHiding) != null ? _table$options$enable : true);
    };
    column.getToggleVisibilityHandler = () => {
      return (e2) => {
        column.toggleVisibility == null || column.toggleVisibility(e2.target.checked);
      };
    };
  },
  createRow: (row, table) => {
    row._getAllVisibleCells = memo(() => [row.getAllCells(), table.getState().columnVisibility], (cells) => {
      return cells.filter((cell) => cell.column.getIsVisible());
    }, getMemoOptions(table.options, "debugRows", "_getAllVisibleCells"));
    row.getVisibleCells = memo(() => [row.getLeftVisibleCells(), row.getCenterVisibleCells(), row.getRightVisibleCells()], (left, center, right) => [...left, ...center, ...right], getMemoOptions(table.options, "debugRows", "getVisibleCells"));
  },
  createTable: (table) => {
    const makeVisibleColumnsMethod = (key, getColumns) => {
      return memo(() => [getColumns(), getColumns().filter((d2) => d2.getIsVisible()).map((d2) => d2.id).join("_")], (columns2) => {
        return columns2.filter((d2) => d2.getIsVisible == null ? void 0 : d2.getIsVisible());
      }, getMemoOptions(table.options, "debugColumns", key));
    };
    table.getVisibleFlatColumns = makeVisibleColumnsMethod("getVisibleFlatColumns", () => table.getAllFlatColumns());
    table.getVisibleLeafColumns = makeVisibleColumnsMethod("getVisibleLeafColumns", () => table.getAllLeafColumns());
    table.getLeftVisibleLeafColumns = makeVisibleColumnsMethod("getLeftVisibleLeafColumns", () => table.getLeftLeafColumns());
    table.getRightVisibleLeafColumns = makeVisibleColumnsMethod("getRightVisibleLeafColumns", () => table.getRightLeafColumns());
    table.getCenterVisibleLeafColumns = makeVisibleColumnsMethod("getCenterVisibleLeafColumns", () => table.getCenterLeafColumns());
    table.setColumnVisibility = (updater) => table.options.onColumnVisibilityChange == null ? void 0 : table.options.onColumnVisibilityChange(updater);
    table.resetColumnVisibility = (defaultState) => {
      var _table$initialState$c;
      table.setColumnVisibility(defaultState ? {} : (_table$initialState$c = table.initialState.columnVisibility) != null ? _table$initialState$c : {});
    };
    table.toggleAllColumnsVisible = (value) => {
      var _value;
      value = (_value = value) != null ? _value : !table.getIsAllColumnsVisible();
      table.setColumnVisibility(table.getAllLeafColumns().reduce((obj, column) => ({
        ...obj,
        [column.id]: !value ? !(column.getCanHide != null && column.getCanHide()) : value
      }), {}));
    };
    table.getIsAllColumnsVisible = () => !table.getAllLeafColumns().some((column) => !(column.getIsVisible != null && column.getIsVisible()));
    table.getIsSomeColumnsVisible = () => table.getAllLeafColumns().some((column) => column.getIsVisible == null ? void 0 : column.getIsVisible());
    table.getToggleAllColumnsVisibilityHandler = () => {
      return (e2) => {
        var _target;
        table.toggleAllColumnsVisible((_target = e2.target) == null ? void 0 : _target.checked);
      };
    };
  }
};
function _getVisibleLeafColumns(table, position) {
  return !position ? table.getVisibleLeafColumns() : position === "center" ? table.getCenterVisibleLeafColumns() : position === "left" ? table.getLeftVisibleLeafColumns() : table.getRightVisibleLeafColumns();
}
const GlobalFaceting = {
  createTable: (table) => {
    table._getGlobalFacetedRowModel = table.options.getFacetedRowModel && table.options.getFacetedRowModel(table, "__global__");
    table.getGlobalFacetedRowModel = () => {
      if (table.options.manualFiltering || !table._getGlobalFacetedRowModel) {
        return table.getPreFilteredRowModel();
      }
      return table._getGlobalFacetedRowModel();
    };
    table._getGlobalFacetedUniqueValues = table.options.getFacetedUniqueValues && table.options.getFacetedUniqueValues(table, "__global__");
    table.getGlobalFacetedUniqueValues = () => {
      if (!table._getGlobalFacetedUniqueValues) {
        return /* @__PURE__ */ new Map();
      }
      return table._getGlobalFacetedUniqueValues();
    };
    table._getGlobalFacetedMinMaxValues = table.options.getFacetedMinMaxValues && table.options.getFacetedMinMaxValues(table, "__global__");
    table.getGlobalFacetedMinMaxValues = () => {
      if (!table._getGlobalFacetedMinMaxValues) {
        return;
      }
      return table._getGlobalFacetedMinMaxValues();
    };
  }
};
const GlobalFiltering = {
  getInitialState: (state2) => {
    return {
      globalFilter: void 0,
      ...state2
    };
  },
  getDefaultOptions: (table) => {
    return {
      onGlobalFilterChange: makeStateUpdater("globalFilter", table),
      globalFilterFn: "auto",
      getColumnCanGlobalFilter: (column) => {
        var _table$getCoreRowMode;
        const value = (_table$getCoreRowMode = table.getCoreRowModel().flatRows[0]) == null || (_table$getCoreRowMode = _table$getCoreRowMode._getAllCellsByColumnId()[column.id]) == null ? void 0 : _table$getCoreRowMode.getValue();
        return typeof value === "string" || typeof value === "number";
      }
    };
  },
  createColumn: (column, table) => {
    column.getCanGlobalFilter = () => {
      var _column$columnDef$ena, _table$options$enable, _table$options$enable2, _table$options$getCol;
      return ((_column$columnDef$ena = column.columnDef.enableGlobalFilter) != null ? _column$columnDef$ena : true) && ((_table$options$enable = table.options.enableGlobalFilter) != null ? _table$options$enable : true) && ((_table$options$enable2 = table.options.enableFilters) != null ? _table$options$enable2 : true) && ((_table$options$getCol = table.options.getColumnCanGlobalFilter == null ? void 0 : table.options.getColumnCanGlobalFilter(column)) != null ? _table$options$getCol : true) && !!column.accessorFn;
    };
  },
  createTable: (table) => {
    table.getGlobalAutoFilterFn = () => {
      return filterFns.includesString;
    };
    table.getGlobalFilterFn = () => {
      var _table$options$filter, _table$options$filter2;
      const {
        globalFilterFn
      } = table.options;
      return isFunction(globalFilterFn) ? globalFilterFn : globalFilterFn === "auto" ? table.getGlobalAutoFilterFn() : (_table$options$filter = (_table$options$filter2 = table.options.filterFns) == null ? void 0 : _table$options$filter2[globalFilterFn]) != null ? _table$options$filter : filterFns[globalFilterFn];
    };
    table.setGlobalFilter = (updater) => {
      table.options.onGlobalFilterChange == null || table.options.onGlobalFilterChange(updater);
    };
    table.resetGlobalFilter = (defaultState) => {
      table.setGlobalFilter(defaultState ? void 0 : table.initialState.globalFilter);
    };
  }
};
const RowExpanding = {
  getInitialState: (state2) => {
    return {
      expanded: {},
      ...state2
    };
  },
  getDefaultOptions: (table) => {
    return {
      onExpandedChange: makeStateUpdater("expanded", table),
      paginateExpandedRows: true
    };
  },
  createTable: (table) => {
    let registered = false;
    let queued = false;
    table._autoResetExpanded = () => {
      var _ref, _table$options$autoRe;
      if (!registered) {
        table._queue(() => {
          registered = true;
        });
        return;
      }
      if ((_ref = (_table$options$autoRe = table.options.autoResetAll) != null ? _table$options$autoRe : table.options.autoResetExpanded) != null ? _ref : !table.options.manualExpanding) {
        if (queued) return;
        queued = true;
        table._queue(() => {
          table.resetExpanded();
          queued = false;
        });
      }
    };
    table.setExpanded = (updater) => table.options.onExpandedChange == null ? void 0 : table.options.onExpandedChange(updater);
    table.toggleAllRowsExpanded = (expanded) => {
      if (expanded != null ? expanded : !table.getIsAllRowsExpanded()) {
        table.setExpanded(true);
      } else {
        table.setExpanded({});
      }
    };
    table.resetExpanded = (defaultState) => {
      var _table$initialState$e, _table$initialState;
      table.setExpanded(defaultState ? {} : (_table$initialState$e = (_table$initialState = table.initialState) == null ? void 0 : _table$initialState.expanded) != null ? _table$initialState$e : {});
    };
    table.getCanSomeRowsExpand = () => {
      return table.getPrePaginationRowModel().flatRows.some((row) => row.getCanExpand());
    };
    table.getToggleAllRowsExpandedHandler = () => {
      return (e2) => {
        e2.persist == null || e2.persist();
        table.toggleAllRowsExpanded();
      };
    };
    table.getIsSomeRowsExpanded = () => {
      const expanded = table.getState().expanded;
      return expanded === true || Object.values(expanded).some(Boolean);
    };
    table.getIsAllRowsExpanded = () => {
      const expanded = table.getState().expanded;
      if (typeof expanded === "boolean") {
        return expanded === true;
      }
      if (!Object.keys(expanded).length) {
        return false;
      }
      if (table.getRowModel().flatRows.some((row) => !row.getIsExpanded())) {
        return false;
      }
      return true;
    };
    table.getExpandedDepth = () => {
      let maxDepth = 0;
      const rowIds = table.getState().expanded === true ? Object.keys(table.getRowModel().rowsById) : Object.keys(table.getState().expanded);
      rowIds.forEach((id) => {
        const splitId = id.split(".");
        maxDepth = Math.max(maxDepth, splitId.length);
      });
      return maxDepth;
    };
    table.getPreExpandedRowModel = () => table.getSortedRowModel();
    table.getExpandedRowModel = () => {
      if (!table._getExpandedRowModel && table.options.getExpandedRowModel) {
        table._getExpandedRowModel = table.options.getExpandedRowModel(table);
      }
      if (table.options.manualExpanding || !table._getExpandedRowModel) {
        return table.getPreExpandedRowModel();
      }
      return table._getExpandedRowModel();
    };
  },
  createRow: (row, table) => {
    row.toggleExpanded = (expanded) => {
      table.setExpanded((old) => {
        var _expanded;
        const exists = old === true ? true : !!(old != null && old[row.id]);
        let oldExpanded = {};
        if (old === true) {
          Object.keys(table.getRowModel().rowsById).forEach((rowId) => {
            oldExpanded[rowId] = true;
          });
        } else {
          oldExpanded = old;
        }
        expanded = (_expanded = expanded) != null ? _expanded : !exists;
        if (!exists && expanded) {
          return {
            ...oldExpanded,
            [row.id]: true
          };
        }
        if (exists && !expanded) {
          const {
            [row.id]: _2,
            ...rest
          } = oldExpanded;
          return rest;
        }
        return old;
      });
    };
    row.getIsExpanded = () => {
      var _table$options$getIsR;
      const expanded = table.getState().expanded;
      return !!((_table$options$getIsR = table.options.getIsRowExpanded == null ? void 0 : table.options.getIsRowExpanded(row)) != null ? _table$options$getIsR : expanded === true || (expanded == null ? void 0 : expanded[row.id]));
    };
    row.getCanExpand = () => {
      var _table$options$getRow, _table$options$enable, _row$subRows;
      return (_table$options$getRow = table.options.getRowCanExpand == null ? void 0 : table.options.getRowCanExpand(row)) != null ? _table$options$getRow : ((_table$options$enable = table.options.enableExpanding) != null ? _table$options$enable : true) && !!((_row$subRows = row.subRows) != null && _row$subRows.length);
    };
    row.getIsAllParentsExpanded = () => {
      let isFullyExpanded = true;
      let currentRow = row;
      while (isFullyExpanded && currentRow.parentId) {
        currentRow = table.getRow(currentRow.parentId, true);
        isFullyExpanded = currentRow.getIsExpanded();
      }
      return isFullyExpanded;
    };
    row.getToggleExpandedHandler = () => {
      const canExpand = row.getCanExpand();
      return () => {
        if (!canExpand) return;
        row.toggleExpanded();
      };
    };
  }
};
const defaultPageIndex = 0;
const defaultPageSize = 10;
const getDefaultPaginationState = () => ({
  pageIndex: defaultPageIndex,
  pageSize: defaultPageSize
});
const RowPagination = {
  getInitialState: (state2) => {
    return {
      ...state2,
      pagination: {
        ...getDefaultPaginationState(),
        ...state2 == null ? void 0 : state2.pagination
      }
    };
  },
  getDefaultOptions: (table) => {
    return {
      onPaginationChange: makeStateUpdater("pagination", table)
    };
  },
  createTable: (table) => {
    let registered = false;
    let queued = false;
    table._autoResetPageIndex = () => {
      var _ref, _table$options$autoRe;
      if (!registered) {
        table._queue(() => {
          registered = true;
        });
        return;
      }
      if ((_ref = (_table$options$autoRe = table.options.autoResetAll) != null ? _table$options$autoRe : table.options.autoResetPageIndex) != null ? _ref : !table.options.manualPagination) {
        if (queued) return;
        queued = true;
        table._queue(() => {
          table.resetPageIndex();
          queued = false;
        });
      }
    };
    table.setPagination = (updater) => {
      const safeUpdater = (old) => {
        let newState = functionalUpdate(updater, old);
        return newState;
      };
      return table.options.onPaginationChange == null ? void 0 : table.options.onPaginationChange(safeUpdater);
    };
    table.resetPagination = (defaultState) => {
      var _table$initialState$p;
      table.setPagination(defaultState ? getDefaultPaginationState() : (_table$initialState$p = table.initialState.pagination) != null ? _table$initialState$p : getDefaultPaginationState());
    };
    table.setPageIndex = (updater) => {
      table.setPagination((old) => {
        let pageIndex = functionalUpdate(updater, old.pageIndex);
        const maxPageIndex = typeof table.options.pageCount === "undefined" || table.options.pageCount === -1 ? Number.MAX_SAFE_INTEGER : table.options.pageCount - 1;
        pageIndex = Math.max(0, Math.min(pageIndex, maxPageIndex));
        return {
          ...old,
          pageIndex
        };
      });
    };
    table.resetPageIndex = (defaultState) => {
      var _table$initialState$p2, _table$initialState;
      table.setPageIndex(defaultState ? defaultPageIndex : (_table$initialState$p2 = (_table$initialState = table.initialState) == null || (_table$initialState = _table$initialState.pagination) == null ? void 0 : _table$initialState.pageIndex) != null ? _table$initialState$p2 : defaultPageIndex);
    };
    table.resetPageSize = (defaultState) => {
      var _table$initialState$p3, _table$initialState2;
      table.setPageSize(defaultState ? defaultPageSize : (_table$initialState$p3 = (_table$initialState2 = table.initialState) == null || (_table$initialState2 = _table$initialState2.pagination) == null ? void 0 : _table$initialState2.pageSize) != null ? _table$initialState$p3 : defaultPageSize);
    };
    table.setPageSize = (updater) => {
      table.setPagination((old) => {
        const pageSize = Math.max(1, functionalUpdate(updater, old.pageSize));
        const topRowIndex = old.pageSize * old.pageIndex;
        const pageIndex = Math.floor(topRowIndex / pageSize);
        return {
          ...old,
          pageIndex,
          pageSize
        };
      });
    };
    table.setPageCount = (updater) => table.setPagination((old) => {
      var _table$options$pageCo;
      let newPageCount = functionalUpdate(updater, (_table$options$pageCo = table.options.pageCount) != null ? _table$options$pageCo : -1);
      if (typeof newPageCount === "number") {
        newPageCount = Math.max(-1, newPageCount);
      }
      return {
        ...old,
        pageCount: newPageCount
      };
    });
    table.getPageOptions = memo(() => [table.getPageCount()], (pageCount) => {
      let pageOptions = [];
      if (pageCount && pageCount > 0) {
        pageOptions = [...new Array(pageCount)].fill(null).map((_2, i2) => i2);
      }
      return pageOptions;
    }, getMemoOptions(table.options, "debugTable", "getPageOptions"));
    table.getCanPreviousPage = () => table.getState().pagination.pageIndex > 0;
    table.getCanNextPage = () => {
      const {
        pageIndex
      } = table.getState().pagination;
      const pageCount = table.getPageCount();
      if (pageCount === -1) {
        return true;
      }
      if (pageCount === 0) {
        return false;
      }
      return pageIndex < pageCount - 1;
    };
    table.previousPage = () => {
      return table.setPageIndex((old) => old - 1);
    };
    table.nextPage = () => {
      return table.setPageIndex((old) => {
        return old + 1;
      });
    };
    table.firstPage = () => {
      return table.setPageIndex(0);
    };
    table.lastPage = () => {
      return table.setPageIndex(table.getPageCount() - 1);
    };
    table.getPrePaginationRowModel = () => table.getExpandedRowModel();
    table.getPaginationRowModel = () => {
      if (!table._getPaginationRowModel && table.options.getPaginationRowModel) {
        table._getPaginationRowModel = table.options.getPaginationRowModel(table);
      }
      if (table.options.manualPagination || !table._getPaginationRowModel) {
        return table.getPrePaginationRowModel();
      }
      return table._getPaginationRowModel();
    };
    table.getPageCount = () => {
      var _table$options$pageCo2;
      return (_table$options$pageCo2 = table.options.pageCount) != null ? _table$options$pageCo2 : Math.ceil(table.getRowCount() / table.getState().pagination.pageSize);
    };
    table.getRowCount = () => {
      var _table$options$rowCou;
      return (_table$options$rowCou = table.options.rowCount) != null ? _table$options$rowCou : table.getPrePaginationRowModel().rows.length;
    };
  }
};
const getDefaultRowPinningState = () => ({
  top: [],
  bottom: []
});
const RowPinning = {
  getInitialState: (state2) => {
    return {
      rowPinning: getDefaultRowPinningState(),
      ...state2
    };
  },
  getDefaultOptions: (table) => {
    return {
      onRowPinningChange: makeStateUpdater("rowPinning", table)
    };
  },
  createRow: (row, table) => {
    row.pin = (position, includeLeafRows, includeParentRows) => {
      const leafRowIds = includeLeafRows ? row.getLeafRows().map((_ref) => {
        let {
          id
        } = _ref;
        return id;
      }) : [];
      const parentRowIds = includeParentRows ? row.getParentRows().map((_ref2) => {
        let {
          id
        } = _ref2;
        return id;
      }) : [];
      const rowIds = /* @__PURE__ */ new Set([...parentRowIds, row.id, ...leafRowIds]);
      table.setRowPinning((old) => {
        var _old$top3, _old$bottom3;
        if (position === "bottom") {
          var _old$top, _old$bottom;
          return {
            top: ((_old$top = old == null ? void 0 : old.top) != null ? _old$top : []).filter((d2) => !(rowIds != null && rowIds.has(d2))),
            bottom: [...((_old$bottom = old == null ? void 0 : old.bottom) != null ? _old$bottom : []).filter((d2) => !(rowIds != null && rowIds.has(d2))), ...Array.from(rowIds)]
          };
        }
        if (position === "top") {
          var _old$top2, _old$bottom2;
          return {
            top: [...((_old$top2 = old == null ? void 0 : old.top) != null ? _old$top2 : []).filter((d2) => !(rowIds != null && rowIds.has(d2))), ...Array.from(rowIds)],
            bottom: ((_old$bottom2 = old == null ? void 0 : old.bottom) != null ? _old$bottom2 : []).filter((d2) => !(rowIds != null && rowIds.has(d2)))
          };
        }
        return {
          top: ((_old$top3 = old == null ? void 0 : old.top) != null ? _old$top3 : []).filter((d2) => !(rowIds != null && rowIds.has(d2))),
          bottom: ((_old$bottom3 = old == null ? void 0 : old.bottom) != null ? _old$bottom3 : []).filter((d2) => !(rowIds != null && rowIds.has(d2)))
        };
      });
    };
    row.getCanPin = () => {
      var _ref3;
      const {
        enableRowPinning,
        enablePinning
      } = table.options;
      if (typeof enableRowPinning === "function") {
        return enableRowPinning(row);
      }
      return (_ref3 = enableRowPinning != null ? enableRowPinning : enablePinning) != null ? _ref3 : true;
    };
    row.getIsPinned = () => {
      const rowIds = [row.id];
      const {
        top,
        bottom
      } = table.getState().rowPinning;
      const isTop = rowIds.some((d2) => top == null ? void 0 : top.includes(d2));
      const isBottom = rowIds.some((d2) => bottom == null ? void 0 : bottom.includes(d2));
      return isTop ? "top" : isBottom ? "bottom" : false;
    };
    row.getPinnedIndex = () => {
      var _ref4, _visiblePinnedRowIds$;
      const position = row.getIsPinned();
      if (!position) return -1;
      const visiblePinnedRowIds = (_ref4 = position === "top" ? table.getTopRows() : table.getBottomRows()) == null ? void 0 : _ref4.map((_ref5) => {
        let {
          id
        } = _ref5;
        return id;
      });
      return (_visiblePinnedRowIds$ = visiblePinnedRowIds == null ? void 0 : visiblePinnedRowIds.indexOf(row.id)) != null ? _visiblePinnedRowIds$ : -1;
    };
  },
  createTable: (table) => {
    table.setRowPinning = (updater) => table.options.onRowPinningChange == null ? void 0 : table.options.onRowPinningChange(updater);
    table.resetRowPinning = (defaultState) => {
      var _table$initialState$r, _table$initialState;
      return table.setRowPinning(defaultState ? getDefaultRowPinningState() : (_table$initialState$r = (_table$initialState = table.initialState) == null ? void 0 : _table$initialState.rowPinning) != null ? _table$initialState$r : getDefaultRowPinningState());
    };
    table.getIsSomeRowsPinned = (position) => {
      var _pinningState$positio;
      const pinningState = table.getState().rowPinning;
      if (!position) {
        var _pinningState$top, _pinningState$bottom;
        return Boolean(((_pinningState$top = pinningState.top) == null ? void 0 : _pinningState$top.length) || ((_pinningState$bottom = pinningState.bottom) == null ? void 0 : _pinningState$bottom.length));
      }
      return Boolean((_pinningState$positio = pinningState[position]) == null ? void 0 : _pinningState$positio.length);
    };
    table._getPinnedRows = (visibleRows, pinnedRowIds, position) => {
      var _table$options$keepPi;
      const rows = ((_table$options$keepPi = table.options.keepPinnedRows) != null ? _table$options$keepPi : true) ? (
        //get all rows that are pinned even if they would not be otherwise visible
        //account for expanded parent rows, but not pagination or filtering
        (pinnedRowIds != null ? pinnedRowIds : []).map((rowId) => {
          const row = table.getRow(rowId, true);
          return row.getIsAllParentsExpanded() ? row : null;
        })
      ) : (
        //else get only visible rows that are pinned
        (pinnedRowIds != null ? pinnedRowIds : []).map((rowId) => visibleRows.find((row) => row.id === rowId))
      );
      return rows.filter(Boolean).map((d2) => ({
        ...d2,
        position
      }));
    };
    table.getTopRows = memo(() => [table.getRowModel().rows, table.getState().rowPinning.top], (allRows, topPinnedRowIds) => table._getPinnedRows(allRows, topPinnedRowIds, "top"), getMemoOptions(table.options, "debugRows", "getTopRows"));
    table.getBottomRows = memo(() => [table.getRowModel().rows, table.getState().rowPinning.bottom], (allRows, bottomPinnedRowIds) => table._getPinnedRows(allRows, bottomPinnedRowIds, "bottom"), getMemoOptions(table.options, "debugRows", "getBottomRows"));
    table.getCenterRows = memo(() => [table.getRowModel().rows, table.getState().rowPinning.top, table.getState().rowPinning.bottom], (allRows, top, bottom) => {
      const topAndBottom = /* @__PURE__ */ new Set([...top != null ? top : [], ...bottom != null ? bottom : []]);
      return allRows.filter((d2) => !topAndBottom.has(d2.id));
    }, getMemoOptions(table.options, "debugRows", "getCenterRows"));
  }
};
const RowSelection = {
  getInitialState: (state2) => {
    return {
      rowSelection: {},
      ...state2
    };
  },
  getDefaultOptions: (table) => {
    return {
      onRowSelectionChange: makeStateUpdater("rowSelection", table),
      enableRowSelection: true,
      enableMultiRowSelection: true,
      enableSubRowSelection: true
      // enableGroupingRowSelection: false,
      // isAdditiveSelectEvent: (e: unknown) => !!e.metaKey,
      // isInclusiveSelectEvent: (e: unknown) => !!e.shiftKey,
    };
  },
  createTable: (table) => {
    table.setRowSelection = (updater) => table.options.onRowSelectionChange == null ? void 0 : table.options.onRowSelectionChange(updater);
    table.resetRowSelection = (defaultState) => {
      var _table$initialState$r;
      return table.setRowSelection(defaultState ? {} : (_table$initialState$r = table.initialState.rowSelection) != null ? _table$initialState$r : {});
    };
    table.toggleAllRowsSelected = (value) => {
      table.setRowSelection((old) => {
        value = typeof value !== "undefined" ? value : !table.getIsAllRowsSelected();
        const rowSelection = {
          ...old
        };
        const preGroupedFlatRows = table.getPreGroupedRowModel().flatRows;
        if (value) {
          preGroupedFlatRows.forEach((row) => {
            if (!row.getCanSelect()) {
              return;
            }
            rowSelection[row.id] = true;
          });
        } else {
          preGroupedFlatRows.forEach((row) => {
            delete rowSelection[row.id];
          });
        }
        return rowSelection;
      });
    };
    table.toggleAllPageRowsSelected = (value) => table.setRowSelection((old) => {
      const resolvedValue = typeof value !== "undefined" ? value : !table.getIsAllPageRowsSelected();
      const rowSelection = {
        ...old
      };
      table.getRowModel().rows.forEach((row) => {
        mutateRowIsSelected(rowSelection, row.id, resolvedValue, true, table);
      });
      return rowSelection;
    });
    table.getPreSelectedRowModel = () => table.getCoreRowModel();
    table.getSelectedRowModel = memo(() => [table.getState().rowSelection, table.getCoreRowModel()], (rowSelection, rowModel) => {
      if (!Object.keys(rowSelection).length) {
        return {
          rows: [],
          flatRows: [],
          rowsById: {}
        };
      }
      return selectRowsFn(table, rowModel);
    }, getMemoOptions(table.options, "debugTable", "getSelectedRowModel"));
    table.getFilteredSelectedRowModel = memo(() => [table.getState().rowSelection, table.getFilteredRowModel()], (rowSelection, rowModel) => {
      if (!Object.keys(rowSelection).length) {
        return {
          rows: [],
          flatRows: [],
          rowsById: {}
        };
      }
      return selectRowsFn(table, rowModel);
    }, getMemoOptions(table.options, "debugTable", "getFilteredSelectedRowModel"));
    table.getGroupedSelectedRowModel = memo(() => [table.getState().rowSelection, table.getSortedRowModel()], (rowSelection, rowModel) => {
      if (!Object.keys(rowSelection).length) {
        return {
          rows: [],
          flatRows: [],
          rowsById: {}
        };
      }
      return selectRowsFn(table, rowModel);
    }, getMemoOptions(table.options, "debugTable", "getGroupedSelectedRowModel"));
    table.getIsAllRowsSelected = () => {
      const preGroupedFlatRows = table.getFilteredRowModel().flatRows;
      const {
        rowSelection
      } = table.getState();
      let isAllRowsSelected = Boolean(preGroupedFlatRows.length && Object.keys(rowSelection).length);
      if (isAllRowsSelected) {
        if (preGroupedFlatRows.some((row) => row.getCanSelect() && !rowSelection[row.id])) {
          isAllRowsSelected = false;
        }
      }
      return isAllRowsSelected;
    };
    table.getIsAllPageRowsSelected = () => {
      const paginationFlatRows = table.getPaginationRowModel().flatRows.filter((row) => row.getCanSelect());
      const {
        rowSelection
      } = table.getState();
      let isAllPageRowsSelected = !!paginationFlatRows.length;
      if (isAllPageRowsSelected && paginationFlatRows.some((row) => !rowSelection[row.id])) {
        isAllPageRowsSelected = false;
      }
      return isAllPageRowsSelected;
    };
    table.getIsSomeRowsSelected = () => {
      var _table$getState$rowSe;
      const totalSelected = Object.keys((_table$getState$rowSe = table.getState().rowSelection) != null ? _table$getState$rowSe : {}).length;
      return totalSelected > 0 && totalSelected < table.getFilteredRowModel().flatRows.length;
    };
    table.getIsSomePageRowsSelected = () => {
      const paginationFlatRows = table.getPaginationRowModel().flatRows;
      return table.getIsAllPageRowsSelected() ? false : paginationFlatRows.filter((row) => row.getCanSelect()).some((d2) => d2.getIsSelected() || d2.getIsSomeSelected());
    };
    table.getToggleAllRowsSelectedHandler = () => {
      return (e2) => {
        table.toggleAllRowsSelected(e2.target.checked);
      };
    };
    table.getToggleAllPageRowsSelectedHandler = () => {
      return (e2) => {
        table.toggleAllPageRowsSelected(e2.target.checked);
      };
    };
  },
  createRow: (row, table) => {
    row.toggleSelected = (value, opts) => {
      const isSelected = row.getIsSelected();
      table.setRowSelection((old) => {
        var _opts$selectChildren;
        value = typeof value !== "undefined" ? value : !isSelected;
        if (row.getCanSelect() && isSelected === value) {
          return old;
        }
        const selectedRowIds = {
          ...old
        };
        mutateRowIsSelected(selectedRowIds, row.id, value, (_opts$selectChildren = opts == null ? void 0 : opts.selectChildren) != null ? _opts$selectChildren : true, table);
        return selectedRowIds;
      });
    };
    row.getIsSelected = () => {
      const {
        rowSelection
      } = table.getState();
      return isRowSelected(row, rowSelection);
    };
    row.getIsSomeSelected = () => {
      const {
        rowSelection
      } = table.getState();
      return isSubRowSelected(row, rowSelection) === "some";
    };
    row.getIsAllSubRowsSelected = () => {
      const {
        rowSelection
      } = table.getState();
      return isSubRowSelected(row, rowSelection) === "all";
    };
    row.getCanSelect = () => {
      var _table$options$enable;
      if (typeof table.options.enableRowSelection === "function") {
        return table.options.enableRowSelection(row);
      }
      return (_table$options$enable = table.options.enableRowSelection) != null ? _table$options$enable : true;
    };
    row.getCanSelectSubRows = () => {
      var _table$options$enable2;
      if (typeof table.options.enableSubRowSelection === "function") {
        return table.options.enableSubRowSelection(row);
      }
      return (_table$options$enable2 = table.options.enableSubRowSelection) != null ? _table$options$enable2 : true;
    };
    row.getCanMultiSelect = () => {
      var _table$options$enable3;
      if (typeof table.options.enableMultiRowSelection === "function") {
        return table.options.enableMultiRowSelection(row);
      }
      return (_table$options$enable3 = table.options.enableMultiRowSelection) != null ? _table$options$enable3 : true;
    };
    row.getToggleSelectedHandler = () => {
      const canSelect = row.getCanSelect();
      return (e2) => {
        var _target;
        if (!canSelect) return;
        row.toggleSelected((_target = e2.target) == null ? void 0 : _target.checked);
      };
    };
  }
};
const mutateRowIsSelected = (selectedRowIds, id, value, includeChildren, table) => {
  var _row$subRows;
  const row = table.getRow(id, true);
  if (value) {
    if (!row.getCanMultiSelect()) {
      Object.keys(selectedRowIds).forEach((key) => delete selectedRowIds[key]);
    }
    if (row.getCanSelect()) {
      selectedRowIds[id] = true;
    }
  } else {
    delete selectedRowIds[id];
  }
  if (includeChildren && (_row$subRows = row.subRows) != null && _row$subRows.length && row.getCanSelectSubRows()) {
    row.subRows.forEach((row2) => mutateRowIsSelected(selectedRowIds, row2.id, value, includeChildren, table));
  }
};
function selectRowsFn(table, rowModel) {
  const rowSelection = table.getState().rowSelection;
  const newSelectedFlatRows = [];
  const newSelectedRowsById = {};
  const recurseRows = function(rows, depth) {
    return rows.map((row) => {
      var _row$subRows2;
      const isSelected = isRowSelected(row, rowSelection);
      if (isSelected) {
        newSelectedFlatRows.push(row);
        newSelectedRowsById[row.id] = row;
      }
      if ((_row$subRows2 = row.subRows) != null && _row$subRows2.length) {
        row = {
          ...row,
          subRows: recurseRows(row.subRows)
        };
      }
      if (isSelected) {
        return row;
      }
    }).filter(Boolean);
  };
  return {
    rows: recurseRows(rowModel.rows),
    flatRows: newSelectedFlatRows,
    rowsById: newSelectedRowsById
  };
}
function isRowSelected(row, selection) {
  var _selection$row$id;
  return (_selection$row$id = selection[row.id]) != null ? _selection$row$id : false;
}
function isSubRowSelected(row, selection, table) {
  var _row$subRows3;
  if (!((_row$subRows3 = row.subRows) != null && _row$subRows3.length)) return false;
  let allChildrenSelected = true;
  let someSelected = false;
  row.subRows.forEach((subRow) => {
    if (someSelected && !allChildrenSelected) {
      return;
    }
    if (subRow.getCanSelect()) {
      if (isRowSelected(subRow, selection)) {
        someSelected = true;
      } else {
        allChildrenSelected = false;
      }
    }
    if (subRow.subRows && subRow.subRows.length) {
      const subRowChildrenSelected = isSubRowSelected(subRow, selection);
      if (subRowChildrenSelected === "all") {
        someSelected = true;
      } else if (subRowChildrenSelected === "some") {
        someSelected = true;
        allChildrenSelected = false;
      } else {
        allChildrenSelected = false;
      }
    }
  });
  return allChildrenSelected ? "all" : someSelected ? "some" : false;
}
const reSplitAlphaNumeric = /([0-9]+)/gm;
const alphanumeric = (rowA, rowB, columnId) => {
  return compareAlphanumeric(toString(rowA.getValue(columnId)).toLowerCase(), toString(rowB.getValue(columnId)).toLowerCase());
};
const alphanumericCaseSensitive = (rowA, rowB, columnId) => {
  return compareAlphanumeric(toString(rowA.getValue(columnId)), toString(rowB.getValue(columnId)));
};
const text = (rowA, rowB, columnId) => {
  return compareBasic(toString(rowA.getValue(columnId)).toLowerCase(), toString(rowB.getValue(columnId)).toLowerCase());
};
const textCaseSensitive = (rowA, rowB, columnId) => {
  return compareBasic(toString(rowA.getValue(columnId)), toString(rowB.getValue(columnId)));
};
const datetime = (rowA, rowB, columnId) => {
  const a2 = rowA.getValue(columnId);
  const b2 = rowB.getValue(columnId);
  return a2 > b2 ? 1 : a2 < b2 ? -1 : 0;
};
const basic = (rowA, rowB, columnId) => {
  return compareBasic(rowA.getValue(columnId), rowB.getValue(columnId));
};
function compareBasic(a2, b2) {
  return a2 === b2 ? 0 : a2 > b2 ? 1 : -1;
}
function toString(a2) {
  if (typeof a2 === "number") {
    if (isNaN(a2) || a2 === Infinity || a2 === -Infinity) {
      return "";
    }
    return String(a2);
  }
  if (typeof a2 === "string") {
    return a2;
  }
  return "";
}
function compareAlphanumeric(aStr, bStr) {
  const a2 = aStr.split(reSplitAlphaNumeric).filter(Boolean);
  const b2 = bStr.split(reSplitAlphaNumeric).filter(Boolean);
  while (a2.length && b2.length) {
    const aa = a2.shift();
    const bb = b2.shift();
    const an2 = parseInt(aa, 10);
    const bn2 = parseInt(bb, 10);
    const combo = [an2, bn2].sort();
    if (isNaN(combo[0])) {
      if (aa > bb) {
        return 1;
      }
      if (bb > aa) {
        return -1;
      }
      continue;
    }
    if (isNaN(combo[1])) {
      return isNaN(an2) ? -1 : 1;
    }
    if (an2 > bn2) {
      return 1;
    }
    if (bn2 > an2) {
      return -1;
    }
  }
  return a2.length - b2.length;
}
const sortingFns = {
  alphanumeric,
  alphanumericCaseSensitive,
  text,
  textCaseSensitive,
  datetime,
  basic
};
const RowSorting = {
  getInitialState: (state2) => {
    return {
      sorting: [],
      ...state2
    };
  },
  getDefaultColumnDef: () => {
    return {
      sortingFn: "auto",
      sortUndefined: 1
    };
  },
  getDefaultOptions: (table) => {
    return {
      onSortingChange: makeStateUpdater("sorting", table),
      isMultiSortEvent: (e2) => {
        return e2.shiftKey;
      }
    };
  },
  createColumn: (column, table) => {
    column.getAutoSortingFn = () => {
      const firstRows = table.getFilteredRowModel().flatRows.slice(10);
      let isString = false;
      for (const row of firstRows) {
        const value = row == null ? void 0 : row.getValue(column.id);
        if (Object.prototype.toString.call(value) === "[object Date]") {
          return sortingFns.datetime;
        }
        if (typeof value === "string") {
          isString = true;
          if (value.split(reSplitAlphaNumeric).length > 1) {
            return sortingFns.alphanumeric;
          }
        }
      }
      if (isString) {
        return sortingFns.text;
      }
      return sortingFns.basic;
    };
    column.getAutoSortDir = () => {
      const firstRow = table.getFilteredRowModel().flatRows[0];
      const value = firstRow == null ? void 0 : firstRow.getValue(column.id);
      if (typeof value === "string") {
        return "asc";
      }
      return "desc";
    };
    column.getSortingFn = () => {
      var _table$options$sortin, _table$options$sortin2;
      if (!column) {
        throw new Error();
      }
      return isFunction(column.columnDef.sortingFn) ? column.columnDef.sortingFn : column.columnDef.sortingFn === "auto" ? column.getAutoSortingFn() : (_table$options$sortin = (_table$options$sortin2 = table.options.sortingFns) == null ? void 0 : _table$options$sortin2[column.columnDef.sortingFn]) != null ? _table$options$sortin : sortingFns[column.columnDef.sortingFn];
    };
    column.toggleSorting = (desc, multi) => {
      const nextSortingOrder = column.getNextSortingOrder();
      const hasManualValue = typeof desc !== "undefined" && desc !== null;
      table.setSorting((old) => {
        const existingSorting = old == null ? void 0 : old.find((d2) => d2.id === column.id);
        const existingIndex = old == null ? void 0 : old.findIndex((d2) => d2.id === column.id);
        let newSorting = [];
        let sortAction;
        let nextDesc = hasManualValue ? desc : nextSortingOrder === "desc";
        if (old != null && old.length && column.getCanMultiSort() && multi) {
          if (existingSorting) {
            sortAction = "toggle";
          } else {
            sortAction = "add";
          }
        } else {
          if (old != null && old.length && existingIndex !== old.length - 1) {
            sortAction = "replace";
          } else if (existingSorting) {
            sortAction = "toggle";
          } else {
            sortAction = "replace";
          }
        }
        if (sortAction === "toggle") {
          if (!hasManualValue) {
            if (!nextSortingOrder) {
              sortAction = "remove";
            }
          }
        }
        if (sortAction === "add") {
          var _table$options$maxMul;
          newSorting = [...old, {
            id: column.id,
            desc: nextDesc
          }];
          newSorting.splice(0, newSorting.length - ((_table$options$maxMul = table.options.maxMultiSortColCount) != null ? _table$options$maxMul : Number.MAX_SAFE_INTEGER));
        } else if (sortAction === "toggle") {
          newSorting = old.map((d2) => {
            if (d2.id === column.id) {
              return {
                ...d2,
                desc: nextDesc
              };
            }
            return d2;
          });
        } else if (sortAction === "remove") {
          newSorting = old.filter((d2) => d2.id !== column.id);
        } else {
          newSorting = [{
            id: column.id,
            desc: nextDesc
          }];
        }
        return newSorting;
      });
    };
    column.getFirstSortDir = () => {
      var _ref, _column$columnDef$sor;
      const sortDescFirst = (_ref = (_column$columnDef$sor = column.columnDef.sortDescFirst) != null ? _column$columnDef$sor : table.options.sortDescFirst) != null ? _ref : column.getAutoSortDir() === "desc";
      return sortDescFirst ? "desc" : "asc";
    };
    column.getNextSortingOrder = (multi) => {
      var _table$options$enable, _table$options$enable2;
      const firstSortDirection = column.getFirstSortDir();
      const isSorted = column.getIsSorted();
      if (!isSorted) {
        return firstSortDirection;
      }
      if (isSorted !== firstSortDirection && ((_table$options$enable = table.options.enableSortingRemoval) != null ? _table$options$enable : true) && // If enableSortRemove, enable in general
      (multi ? (_table$options$enable2 = table.options.enableMultiRemove) != null ? _table$options$enable2 : true : true)) {
        return false;
      }
      return isSorted === "desc" ? "asc" : "desc";
    };
    column.getCanSort = () => {
      var _column$columnDef$ena, _table$options$enable3;
      return ((_column$columnDef$ena = column.columnDef.enableSorting) != null ? _column$columnDef$ena : true) && ((_table$options$enable3 = table.options.enableSorting) != null ? _table$options$enable3 : true) && !!column.accessorFn;
    };
    column.getCanMultiSort = () => {
      var _ref2, _column$columnDef$ena2;
      return (_ref2 = (_column$columnDef$ena2 = column.columnDef.enableMultiSort) != null ? _column$columnDef$ena2 : table.options.enableMultiSort) != null ? _ref2 : !!column.accessorFn;
    };
    column.getIsSorted = () => {
      var _table$getState$sorti;
      const columnSort = (_table$getState$sorti = table.getState().sorting) == null ? void 0 : _table$getState$sorti.find((d2) => d2.id === column.id);
      return !columnSort ? false : columnSort.desc ? "desc" : "asc";
    };
    column.getSortIndex = () => {
      var _table$getState$sorti2, _table$getState$sorti3;
      return (_table$getState$sorti2 = (_table$getState$sorti3 = table.getState().sorting) == null ? void 0 : _table$getState$sorti3.findIndex((d2) => d2.id === column.id)) != null ? _table$getState$sorti2 : -1;
    };
    column.clearSorting = () => {
      table.setSorting((old) => old != null && old.length ? old.filter((d2) => d2.id !== column.id) : []);
    };
    column.getToggleSortingHandler = () => {
      const canSort = column.getCanSort();
      return (e2) => {
        if (!canSort) return;
        e2.persist == null || e2.persist();
        column.toggleSorting == null || column.toggleSorting(void 0, column.getCanMultiSort() ? table.options.isMultiSortEvent == null ? void 0 : table.options.isMultiSortEvent(e2) : false);
      };
    };
  },
  createTable: (table) => {
    table.setSorting = (updater) => table.options.onSortingChange == null ? void 0 : table.options.onSortingChange(updater);
    table.resetSorting = (defaultState) => {
      var _table$initialState$s, _table$initialState;
      table.setSorting(defaultState ? [] : (_table$initialState$s = (_table$initialState = table.initialState) == null ? void 0 : _table$initialState.sorting) != null ? _table$initialState$s : []);
    };
    table.getPreSortedRowModel = () => table.getGroupedRowModel();
    table.getSortedRowModel = () => {
      if (!table._getSortedRowModel && table.options.getSortedRowModel) {
        table._getSortedRowModel = table.options.getSortedRowModel(table);
      }
      if (table.options.manualSorting || !table._getSortedRowModel) {
        return table.getPreSortedRowModel();
      }
      return table._getSortedRowModel();
    };
  }
};
const builtInFeatures = [
  Headers,
  ColumnVisibility,
  ColumnOrdering,
  ColumnPinning,
  ColumnFaceting,
  ColumnFiltering,
  GlobalFaceting,
  //depends on ColumnFaceting
  GlobalFiltering,
  //depends on ColumnFiltering
  RowSorting,
  ColumnGrouping,
  //depends on RowSorting
  RowExpanding,
  RowPagination,
  RowPinning,
  RowSelection,
  ColumnSizing
];
function createTable(options) {
  var _options$_features, _options$initialState;
  if (process.env.NODE_ENV !== "production" && (options.debugAll || options.debugTable)) {
    console.info("Creating Table Instance...");
  }
  const _features = [...builtInFeatures, ...(_options$_features = options._features) != null ? _options$_features : []];
  let table = {
    _features
  };
  const defaultOptions = table._features.reduce((obj, feature) => {
    return Object.assign(obj, feature.getDefaultOptions == null ? void 0 : feature.getDefaultOptions(table));
  }, {});
  const mergeOptions = (options2) => {
    if (table.options.mergeOptions) {
      return table.options.mergeOptions(defaultOptions, options2);
    }
    return {
      ...defaultOptions,
      ...options2
    };
  };
  const coreInitialState = {};
  let initialState = {
    ...coreInitialState,
    ...(_options$initialState = options.initialState) != null ? _options$initialState : {}
  };
  table._features.forEach((feature) => {
    var _feature$getInitialSt;
    initialState = (_feature$getInitialSt = feature.getInitialState == null ? void 0 : feature.getInitialState(initialState)) != null ? _feature$getInitialSt : initialState;
  });
  const queued = [];
  let queuedTimeout = false;
  const coreInstance = {
    _features,
    options: {
      ...defaultOptions,
      ...options
    },
    initialState,
    _queue: (cb) => {
      queued.push(cb);
      if (!queuedTimeout) {
        queuedTimeout = true;
        Promise.resolve().then(() => {
          while (queued.length) {
            queued.shift()();
          }
          queuedTimeout = false;
        }).catch((error) => setTimeout(() => {
          throw error;
        }));
      }
    },
    reset: () => {
      table.setState(table.initialState);
    },
    setOptions: (updater) => {
      const newOptions = functionalUpdate(updater, table.options);
      table.options = mergeOptions(newOptions);
    },
    getState: () => {
      return table.options.state;
    },
    setState: (updater) => {
      table.options.onStateChange == null || table.options.onStateChange(updater);
    },
    _getRowId: (row, index, parent) => {
      var _table$options$getRow;
      return (_table$options$getRow = table.options.getRowId == null ? void 0 : table.options.getRowId(row, index, parent)) != null ? _table$options$getRow : `${parent ? [parent.id, index].join(".") : index}`;
    },
    getCoreRowModel: () => {
      if (!table._getCoreRowModel) {
        table._getCoreRowModel = table.options.getCoreRowModel(table);
      }
      return table._getCoreRowModel();
    },
    // The final calls start at the bottom of the model,
    // expanded rows, which then work their way up
    getRowModel: () => {
      return table.getPaginationRowModel();
    },
    //in next version, we should just pass in the row model as the optional 2nd arg
    getRow: (id, searchAll) => {
      let row = (searchAll ? table.getPrePaginationRowModel() : table.getRowModel()).rowsById[id];
      if (!row) {
        row = table.getCoreRowModel().rowsById[id];
        if (!row) {
          if (process.env.NODE_ENV !== "production") {
            throw new Error(`getRow could not find row with ID: ${id}`);
          }
          throw new Error();
        }
      }
      return row;
    },
    _getDefaultColumnDef: memo(() => [table.options.defaultColumn], (defaultColumn) => {
      var _defaultColumn;
      defaultColumn = (_defaultColumn = defaultColumn) != null ? _defaultColumn : {};
      return {
        header: (props) => {
          const resolvedColumnDef = props.header.column.columnDef;
          if (resolvedColumnDef.accessorKey) {
            return resolvedColumnDef.accessorKey;
          }
          if (resolvedColumnDef.accessorFn) {
            return resolvedColumnDef.id;
          }
          return null;
        },
        // footer: props => props.header.column.id,
        cell: (props) => {
          var _props$renderValue$to, _props$renderValue;
          return (_props$renderValue$to = (_props$renderValue = props.renderValue()) == null || _props$renderValue.toString == null ? void 0 : _props$renderValue.toString()) != null ? _props$renderValue$to : null;
        },
        ...table._features.reduce((obj, feature) => {
          return Object.assign(obj, feature.getDefaultColumnDef == null ? void 0 : feature.getDefaultColumnDef());
        }, {}),
        ...defaultColumn
      };
    }, getMemoOptions(options, "debugColumns", "_getDefaultColumnDef")),
    _getColumnDefs: () => table.options.columns,
    getAllColumns: memo(() => [table._getColumnDefs()], (columnDefs) => {
      const recurseColumns = function(columnDefs2, parent, depth) {
        if (depth === void 0) {
          depth = 0;
        }
        return columnDefs2.map((columnDef) => {
          const column = createColumn(table, columnDef, depth, parent);
          const groupingColumnDef = columnDef;
          column.columns = groupingColumnDef.columns ? recurseColumns(groupingColumnDef.columns, column, depth + 1) : [];
          return column;
        });
      };
      return recurseColumns(columnDefs);
    }, getMemoOptions(options, "debugColumns", "getAllColumns")),
    getAllFlatColumns: memo(() => [table.getAllColumns()], (allColumns) => {
      return allColumns.flatMap((column) => {
        return column.getFlatColumns();
      });
    }, getMemoOptions(options, "debugColumns", "getAllFlatColumns")),
    _getAllFlatColumnsById: memo(() => [table.getAllFlatColumns()], (flatColumns) => {
      return flatColumns.reduce((acc, column) => {
        acc[column.id] = column;
        return acc;
      }, {});
    }, getMemoOptions(options, "debugColumns", "getAllFlatColumnsById")),
    getAllLeafColumns: memo(() => [table.getAllColumns(), table._getOrderColumnsFn()], (allColumns, orderColumns2) => {
      let leafColumns = allColumns.flatMap((column) => column.getLeafColumns());
      return orderColumns2(leafColumns);
    }, getMemoOptions(options, "debugColumns", "getAllLeafColumns")),
    getColumn: (columnId) => {
      const column = table._getAllFlatColumnsById()[columnId];
      if (process.env.NODE_ENV !== "production" && !column) {
        console.error(`[Table] Column with id '${columnId}' does not exist.`);
      }
      return column;
    }
  };
  Object.assign(table, coreInstance);
  for (let index = 0; index < table._features.length; index++) {
    const feature = table._features[index];
    feature == null || feature.createTable == null || feature.createTable(table);
  }
  return table;
}
function getCoreRowModel() {
  return (table) => memo(() => [table.options.data], (data) => {
    const rowModel = {
      rows: [],
      flatRows: [],
      rowsById: {}
    };
    const accessRows = function(originalRows, depth, parentRow) {
      if (depth === void 0) {
        depth = 0;
      }
      const rows = [];
      for (let i2 = 0; i2 < originalRows.length; i2++) {
        const row = createRow(table, table._getRowId(originalRows[i2], i2, parentRow), originalRows[i2], i2, depth, void 0, parentRow == null ? void 0 : parentRow.id);
        rowModel.flatRows.push(row);
        rowModel.rowsById[row.id] = row;
        rows.push(row);
        if (table.options.getSubRows) {
          var _row$originalSubRows;
          row.originalSubRows = table.options.getSubRows(originalRows[i2], i2);
          if ((_row$originalSubRows = row.originalSubRows) != null && _row$originalSubRows.length) {
            row.subRows = accessRows(row.originalSubRows, depth + 1, row);
          }
        }
      }
      return rows;
    };
    rowModel.rows = accessRows(data);
    return rowModel;
  }, getMemoOptions(table.options, "debugTable", "getRowModel", () => table._autoResetPageIndex()));
}
function getSortedRowModel() {
  return (table) => memo(() => [table.getState().sorting, table.getPreSortedRowModel()], (sorting, rowModel) => {
    if (!rowModel.rows.length || !(sorting != null && sorting.length)) {
      return rowModel;
    }
    const sortingState = table.getState().sorting;
    const sortedFlatRows = [];
    const availableSorting = sortingState.filter((sort) => {
      var _table$getColumn;
      return (_table$getColumn = table.getColumn(sort.id)) == null ? void 0 : _table$getColumn.getCanSort();
    });
    const columnInfoById = {};
    availableSorting.forEach((sortEntry) => {
      const column = table.getColumn(sortEntry.id);
      if (!column) return;
      columnInfoById[sortEntry.id] = {
        sortUndefined: column.columnDef.sortUndefined,
        invertSorting: column.columnDef.invertSorting,
        sortingFn: column.getSortingFn()
      };
    });
    const sortData = (rows) => {
      const sortedData = rows.map((row) => ({
        ...row
      }));
      sortedData.sort((rowA, rowB) => {
        for (let i2 = 0; i2 < availableSorting.length; i2 += 1) {
          var _sortEntry$desc;
          const sortEntry = availableSorting[i2];
          const columnInfo = columnInfoById[sortEntry.id];
          const sortUndefined = columnInfo.sortUndefined;
          const isDesc = (_sortEntry$desc = sortEntry == null ? void 0 : sortEntry.desc) != null ? _sortEntry$desc : false;
          let sortInt = 0;
          if (sortUndefined) {
            const aValue = rowA.getValue(sortEntry.id);
            const bValue = rowB.getValue(sortEntry.id);
            const aUndefined = aValue === void 0;
            const bUndefined = bValue === void 0;
            if (aUndefined || bUndefined) {
              if (sortUndefined === "first") return aUndefined ? -1 : 1;
              if (sortUndefined === "last") return aUndefined ? 1 : -1;
              sortInt = aUndefined && bUndefined ? 0 : aUndefined ? sortUndefined : -sortUndefined;
            }
          }
          if (sortInt === 0) {
            sortInt = columnInfo.sortingFn(rowA, rowB, sortEntry.id);
          }
          if (sortInt !== 0) {
            if (isDesc) {
              sortInt *= -1;
            }
            if (columnInfo.invertSorting) {
              sortInt *= -1;
            }
            return sortInt;
          }
        }
        return rowA.index - rowB.index;
      });
      sortedData.forEach((row) => {
        var _row$subRows;
        sortedFlatRows.push(row);
        if ((_row$subRows = row.subRows) != null && _row$subRows.length) {
          row.subRows = sortData(row.subRows);
        }
      });
      return sortedData;
    };
    return {
      rows: sortData(rowModel.rows),
      flatRows: sortedFlatRows,
      rowsById: rowModel.rowsById
    };
  }, getMemoOptions(table.options, "debugTable", "getSortedRowModel", () => table._autoResetPageIndex()));
}
function flexRender(Comp, props) {
  return !Comp ? null : isReactComponent(Comp) ? /* @__PURE__ */ _$1(Comp, props) : Comp;
}
function isReactComponent(component) {
  return isClassComponent(component) || typeof component === "function" || isExoticComponent(component);
}
function isClassComponent(component) {
  return typeof component === "function" && (() => {
    const proto = Object.getPrototypeOf(component);
    return proto.prototype && proto.prototype.isReactComponent;
  })();
}
function isExoticComponent(component) {
  return typeof component === "object" && typeof component.$$typeof === "symbol" && ["react.memo", "react.forward_ref"].includes(component.$$typeof.description);
}
function useReactTable(options) {
  const resolvedOptions = {
    state: {},
    // Dummy state
    onStateChange: () => {
    },
    // noop
    renderFallbackValue: null,
    ...options
  };
  const [tableRef] = d(() => ({
    current: createTable(resolvedOptions)
  }));
  const [state2, setState] = d(() => tableRef.current.initialState);
  tableRef.current.setOptions((prev) => ({
    ...prev,
    ...options,
    state: {
      ...state2,
      ...options.state
    },
    // Similarly, we'll maintain both our internal state and any user-provided
    // state.
    onStateChange: (updater) => {
      setState(updater);
      options.onStateChange == null || options.onStateChange(updater);
    }
  }));
  return tableRef.current;
}
function StatusBadge({ status }) {
  const statusText = {
    none: { label: "None", color: "gray" },
    "in-progress": { label: "In Progress", color: "var(--color-blue)" },
    abandoned: { label: "Abandoned", color: "var(--color-red)" },
    planned: { label: "Planned", color: "var(--color-yellow)" },
    review: { label: "Review", color: "var(--color-cyan)" },
    closed: { label: "Closed", color: "var(--background-modifier-hover)" }
  };
  return /* @__PURE__ */ u$1(
    "span",
    {
      className: "text-xs font-bold",
      style: { color: statusText[status].color },
      children: statusText[status].label
    }
  );
}
const STATUS_ORDER = {
  none: 0,
  planned: 1,
  "in-progress": 2,
  review: 3,
  abandoned: 4,
  closed: 5
};
function StatusDropdown({
  status,
  onChange
}) {
  const items = {
    none: { label: /* @__PURE__ */ u$1(StatusBadge, { status: "none" }), value: "none" },
    "in-progress": {
      label: /* @__PURE__ */ u$1(StatusBadge, { status: "in-progress" }),
      value: "in-progress"
    },
    planned: { label: /* @__PURE__ */ u$1(StatusBadge, { status: "planned" }), value: "planned" },
    review: {
      label: /* @__PURE__ */ u$1(StatusBadge, { status: "review" }),
      value: "review"
    },
    abandoned: {
      label: /* @__PURE__ */ u$1(StatusBadge, { status: "abandoned" }),
      value: "abandoned"
    },
    closed: { label: /* @__PURE__ */ u$1(StatusBadge, { status: "closed" }), value: "closed" }
  };
  return /* @__PURE__ */ u$1(
    Dropdown,
    {
      items: Object.values(items),
      selectedItem: status,
      onChange,
      optionHeight: 28,
      showButton: false
    }
  );
}
const PRIORITY_ORDER = {
  wish: 0,
  low: 1,
  none: 2,
  medium: 3,
  high: 4,
  critical: 5
};
function PriorityDropdown({
  priority,
  onChange
}) {
  const items = {
    wish: {
      value: "wish",
      label: /* @__PURE__ */ u$1(PriorityBadge, { priority: "wish" })
    },
    low: { value: "low", label: /* @__PURE__ */ u$1(PriorityBadge, { priority: "low" }) },
    none: {
      value: "none",
      label: /* @__PURE__ */ u$1(PriorityBadge, { priority: "none" })
    },
    medium: { value: "medium", label: /* @__PURE__ */ u$1(PriorityBadge, { priority: "medium" }) },
    high: { value: "high", label: /* @__PURE__ */ u$1(PriorityBadge, { priority: "high" }) },
    critical: {
      value: "critical",
      label: /* @__PURE__ */ u$1(PriorityBadge, { priority: "critical" })
    }
  };
  return /* @__PURE__ */ u$1(
    Dropdown,
    {
      items: Object.values(items),
      selectedItem: priority,
      onChange,
      optionHeight: 28,
      showButton: false
    }
  );
}
const columns = [
  {
    accessorKey: "status",
    header: "Status",
    enableSorting: true,
    sortingFn: (rowA, rowB, columnId) => {
      const statusA = rowA.getValue(columnId);
      const statusB = rowB.getValue(columnId);
      return STATUS_ORDER[statusA] - STATUS_ORDER[statusB];
    },
    cell: ({ row }) => /* @__PURE__ */ u$1("div", { className: "flex flex-row justify-center", children: /* @__PURE__ */ u$1(
      StatusDropdown,
      {
        status: row.original.status,
        onChange: (newStatus) => {
          const { saveTask: saveTask2 } = row.original;
          saveTask2(row.original, { ...row.original, status: newStatus });
        }
      }
    ) }),
    meta: {
      columnWidth: 80
    }
  },
  {
    accessorKey: "priority",
    header: "Priority",
    sortingFn: (rowA, rowB, columnId) => {
      const priorityA = rowA.getValue(columnId);
      const priorityB = rowB.getValue(columnId);
      return PRIORITY_ORDER[priorityA] - PRIORITY_ORDER[priorityB];
    },
    cell: ({ row }) => /* @__PURE__ */ u$1("div", { className: "flex flex-row justify-center", children: /* @__PURE__ */ u$1(
      PriorityDropdown,
      {
        priority: row.original.priority,
        onChange: (newPriority) => {
          const { saveTask: saveTask2 } = row.original;
          saveTask2(row.original, { ...row.original, priority: newPriority });
        }
      }
    ) }),
    enableSorting: true,
    meta: {
      columnWidth: 80
    }
  },
  {
    accessorKey: "title",
    header: "Title",
    cell: ({ row }) => /* @__PURE__ */ u$1("div", { className: "text-(--text-normal)) overflow-hidden text-ellipsis px-2", children: row.original.title }),
    enableGlobalFilter: true,
    enableSorting: true,
    meta: {
      columnWidth: null
    }
  },
  {
    accessorKey: "path",
    // TODO make this take in lineNum too
    header: "Filename",
    cell: ({ row }) => /* @__PURE__ */ u$1("div", { className: "flex font-(--font-monospace-default) text-s overflow-x-hidden text-ellipsis px-2", children: /* @__PURE__ */ u$1("span", { className: "rounded py-0.5", children: [
      /* @__PURE__ */ u$1("span", { className: "text-(--color-accent)", children: row.original.path.replace(/.*\//, "") }),
      /* @__PURE__ */ u$1("span", { className: "py-0.5 opacity-50 task-list-linenumber pl", children: [
        ":",
        row.original.startLine
      ] })
    ] }) }),
    enableSorting: true,
    meta: {
      columnWidth: 200
    }
  }
];
const TableHeader = ({
  headerGroup,
  columnWidths,
  onResize
}) => {
  return /* @__PURE__ */ u$1("div", { className: "flex h-8 bg-(--background-primary-alt)", children: headerGroup.headers.map(
    (header, index) => {
      const heading = /* @__PURE__ */ u$1(
        "div",
        {
          className: `text-[14px] font-medium text-(--text-normal) relative flex flex-row cursor-pointer ${header.column.getIsSorted() ? "bg-(--background-modifier-hover)" : ""}`,
          style: { width: columnWidths[index] },
          onClick: () => {
            if (header.column.getIsSorted() === "asc") {
              header.column.clearSorting();
            } else {
              header.column.toggleSorting(
                header.column.getIsSorted() !== "desc"
              );
            }
          },
          children: [
            /* @__PURE__ */ u$1("div", { className: "overflow-hidden grow p-2", children: flexRender(
              header.column.columnDef.header,
              header.getContext()
            ) }),
            header.column.getIsSorted() && /* @__PURE__ */ u$1("div", { className: "ml-1", children: header.column.getIsSorted() == "asc" ? /* @__PURE__ */ u$1(Icon, { icon: "arrow-up" }) : /* @__PURE__ */ u$1(Icon, { icon: "arrow-down" }) })
          ]
        }
      );
      if (index == headerGroup.headers.length - 1) {
        return heading;
      }
      return /* @__PURE__ */ u$1(
        reactResizableExports.Resizable,
        {
          width: columnWidths[index] || 150,
          height: 0,
          minConstraints: [50, 0],
          maxConstraints: [1e3, 0],
          resizeHandles: ["e"],
          onResize: (e2, { size }) => {
            e2.stopPropagation();
            onResize(index, size);
          },
          handle: /* @__PURE__ */ u$1("div", { className: "h-full w-(--divider-width) hover:w-(--divider-width-hover) active:w-(--divider-width-hover) cursor-col-resize select-none bg-(--divider-color) hover:bg-(--divider-color-hover) active:bg-(--color-blue)" }),
          children: heading
        },
        header.id
      );
    }
  ) });
};
const TableRow = ({
  row,
  active,
  onRowClick,
  columnWidths
}) => {
  return /* @__PURE__ */ u$1(
    "div",
    {
      className: [
        row.original.status == "closed" ? "line-through opacity-50" : "",
        "flex hover:bg-(--background-modifier-hover)! border-b h-8 border-(--background-modifier-border) cursor-pointer",
        "task-list-row",
        active ? "task-list-row-active" : ""
      ].join(" "),
      onClick: () => {
        onRowClick(row.original);
      },
      tabIndex: row.index,
      onKeyDown: (e2) => {
        if (e2.key === "Enter") {
          onRowClick(row.original);
        }
      },
      children: row.getVisibleCells().map((cell, index) => {
        return /* @__PURE__ */ u$1(
          "div",
          {
            style: columnWidths[index] ? { width: columnWidths[index] } : { flexGrow: 1 },
            className: "flex justify-center flex-col text-ellipsis whitespace-nowrap text-[14px] relative",
            children: flexRender(cell.column.columnDef.cell, cell.getContext())
          },
          cell.id
        );
      })
    },
    row.id
  );
};
function TableBody({
  table,
  activeTask,
  onRowClick,
  columnWidths
}) {
  const allItems = table.getRowModel().rows;
  return /* @__PURE__ */ u$1("div", { className: "overflow-y-auto grow", children: allItems.length > 0 ? allItems.map((row) => {
    return /* @__PURE__ */ u$1(
      TableRow,
      {
        row,
        active: activeTask?.id == row.original.id,
        onRowClick,
        columnWidths
      },
      row.id
    );
  }) : /* @__PURE__ */ u$1("div", { className: "p-4 text-center text-(--text-muted)", children: "No items found" }) });
}
function useColumnResizing(columns2) {
  const initialWidths = columns2.map((column) => {
    const meta = column.meta;
    return meta?.columnWidth || 100;
  });
  const [columnWidths, setColumnWidths] = d(initialWidths);
  const handleResize = q$1((index, size) => {
    setColumnWidths((prev) => {
      const newWidths = [...prev];
      newWidths[index] = size.width;
      return newWidths;
    });
  }, []);
  return {
    columnWidths,
    handleResize
  };
}
function TaskTable({
  taskContext,
  onRowClick,
  onTaskSave,
  activeTask
}) {
  const [sorting, setSorting] = d([]);
  const { columnWidths, handleResize } = useColumnResizing(columns);
  const table = useReactTable({
    data: (taskContext?.tasks || []).map((task) => ({
      ...task,
      saveTask: onTaskSave
    })),
    columns,
    getCoreRowModel: getCoreRowModel(),
    getSortedRowModel: getSortedRowModel(),
    onSortingChange: setSorting,
    state: {
      sorting
    },
    autoResetPageIndex: false
  });
  const targetRef = A$1(null);
  const [dimensions, setDimensions] = d();
  _(() => {
    if (targetRef.current) {
      setDimensions({
        width: targetRef.current.offsetWidth,
        height: targetRef.current.offsetHeight
      });
      const titleWidth = Math.max(
        100,
        targetRef.current.offsetWidth - columns.map((column) => {
          const meta = column.meta;
          return meta?.columnWidth || 0;
        }).reduce((acc, val) => acc + val, 0)
      );
      handleResize(2, { width: titleWidth });
    }
  }, [handleResize]);
  return /* @__PURE__ */ u$1(
    "div",
    {
      ref: targetRef,
      className: "overflow-x-auto flex flex-col grow items-stretch rounded-lg m-4 mt-0\n      border-solid border border-(--background-modifier-border)",
      children: taskContext.tasks == null || !dimensions ? /* @__PURE__ */ u$1("div", { className: "text-center text-(--text-muted) p-8 task-list-loading grow" }) : taskContext.tasks.length === 0 ? /* @__PURE__ */ u$1("div", { className: "text-center text-(--text-muted) p-8", children: "No tasks found. Create your first task!" }) : /* @__PURE__ */ u$1(k$2, { children: [
        /* @__PURE__ */ u$1("div", { className: "border-b border-(--background-modifier-border) bg-(--background-primary) shadow-sm w-full mb-0 pb-0", children: table.getHeaderGroups().map((headerGroup) => /* @__PURE__ */ u$1(
          TableHeader,
          {
            headerGroup,
            columnWidths: columnWidths.reduce(
              (acc, width, index) => {
                acc[index] = width;
                return acc;
              },
              {}
            ),
            onResize: handleResize
          },
          headerGroup.id
        )) }),
        /* @__PURE__ */ u$1(
          TableBody,
          {
            activeTask,
            table,
            onRowClick,
            columnWidths
          }
        )
      ] })
    }
  );
}
function isBytes(a2) {
  return a2 instanceof Uint8Array || ArrayBuffer.isView(a2) && a2.constructor.name === "Uint8Array";
}
function abytes(value, length, title = "") {
  const bytes = isBytes(value);
  const len = value?.length;
  const needsLen = length !== void 0;
  if (!bytes || needsLen) {
    const prefix = title && `"${title}" `;
    const ofLen = "";
    const got = bytes ? `length=${len}` : `type=${typeof value}`;
    throw new Error(prefix + "expected Uint8Array" + ofLen + ", got " + got);
  }
  return value;
}
function aexists(instance, checkFinished = true) {
  if (instance.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (checkFinished && instance.finished)
    throw new Error("Hash#digest() has already been called");
}
function aoutput(out, instance) {
  abytes(out, void 0, "digestInto() output");
  const min2 = instance.outputLen;
  if (out.length < min2) {
    throw new Error('"digestInto() output" expected to be of length >=' + min2);
  }
}
function clean(...arrays) {
  for (let i2 = 0; i2 < arrays.length; i2++) {
    arrays[i2].fill(0);
  }
}
function createView(arr) {
  return new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
}
function rotr(word, shift) {
  return word << 32 - shift | word >>> shift;
}
function createHasher(hashCons, info = {}) {
  const hashC = (msg, opts) => hashCons(opts).update(msg).digest();
  const tmp = hashCons(void 0);
  hashC.outputLen = tmp.outputLen;
  hashC.blockLen = tmp.blockLen;
  hashC.create = (opts) => hashCons(opts);
  Object.assign(hashC, info);
  return Object.freeze(hashC);
}
const oidNist = (suffix) => ({
  oid: Uint8Array.from([6, 9, 96, 134, 72, 1, 101, 3, 4, 2, suffix])
});
function Chi(a2, b2, c2) {
  return a2 & b2 ^ ~a2 & c2;
}
function Maj(a2, b2, c2) {
  return a2 & b2 ^ a2 & c2 ^ b2 & c2;
}
class HashMD {
  blockLen;
  outputLen;
  padOffset;
  isLE;
  // For partial updates less than block size
  buffer;
  view;
  finished = false;
  length = 0;
  pos = 0;
  destroyed = false;
  constructor(blockLen, outputLen, padOffset, isLE) {
    this.blockLen = blockLen;
    this.outputLen = outputLen;
    this.padOffset = padOffset;
    this.isLE = isLE;
    this.buffer = new Uint8Array(blockLen);
    this.view = createView(this.buffer);
  }
  update(data) {
    aexists(this);
    abytes(data);
    const { view: view2, buffer, blockLen } = this;
    const len = data.length;
    for (let pos = 0; pos < len; ) {
      const take = Math.min(blockLen - this.pos, len - pos);
      if (take === blockLen) {
        const dataView = createView(data);
        for (; blockLen <= len - pos; pos += blockLen)
          this.process(dataView, pos);
        continue;
      }
      buffer.set(data.subarray(pos, pos + take), this.pos);
      this.pos += take;
      pos += take;
      if (this.pos === blockLen) {
        this.process(view2, 0);
        this.pos = 0;
      }
    }
    this.length += data.length;
    this.roundClean();
    return this;
  }
  digestInto(out) {
    aexists(this);
    aoutput(out, this);
    this.finished = true;
    const { buffer, view: view2, blockLen, isLE } = this;
    let { pos } = this;
    buffer[pos++] = 128;
    clean(this.buffer.subarray(pos));
    if (this.padOffset > blockLen - pos) {
      this.process(view2, 0);
      pos = 0;
    }
    for (let i2 = pos; i2 < blockLen; i2++)
      buffer[i2] = 0;
    view2.setBigUint64(blockLen - 8, BigInt(this.length * 8), isLE);
    this.process(view2, 0);
    const oview = createView(out);
    const len = this.outputLen;
    if (len % 4)
      throw new Error("_sha2: outputLen must be aligned to 32bit");
    const outLen = len / 4;
    const state2 = this.get();
    if (outLen > state2.length)
      throw new Error("_sha2: outputLen bigger than state");
    for (let i2 = 0; i2 < outLen; i2++)
      oview.setUint32(4 * i2, state2[i2], isLE);
  }
  digest() {
    const { buffer, outputLen } = this;
    this.digestInto(buffer);
    const res = buffer.slice(0, outputLen);
    this.destroy();
    return res;
  }
  _cloneInto(to) {
    to ||= new this.constructor();
    to.set(...this.get());
    const { blockLen, buffer, length, finished, destroyed, pos } = this;
    to.destroyed = destroyed;
    to.finished = finished;
    to.length = length;
    to.pos = pos;
    if (length % blockLen)
      to.buffer.set(buffer);
    return to;
  }
  clone() {
    return this._cloneInto();
  }
}
const SHA256_IV = /* @__PURE__ */ Uint32Array.from([
  1779033703,
  3144134277,
  1013904242,
  2773480762,
  1359893119,
  2600822924,
  528734635,
  1541459225
]);
const SHA256_K = /* @__PURE__ */ Uint32Array.from([
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
]);
const SHA256_W = /* @__PURE__ */ new Uint32Array(64);
class SHA2_32B extends HashMD {
  constructor(outputLen) {
    super(64, outputLen, 8, false);
  }
  get() {
    const { A: A2, B: B2, C: C2, D: D2, E: E2, F: F2, G: G2, H: H2 } = this;
    return [A2, B2, C2, D2, E2, F2, G2, H2];
  }
  // prettier-ignore
  set(A2, B2, C2, D2, E2, F2, G2, H2) {
    this.A = A2 | 0;
    this.B = B2 | 0;
    this.C = C2 | 0;
    this.D = D2 | 0;
    this.E = E2 | 0;
    this.F = F2 | 0;
    this.G = G2 | 0;
    this.H = H2 | 0;
  }
  process(view2, offset) {
    for (let i2 = 0; i2 < 16; i2++, offset += 4)
      SHA256_W[i2] = view2.getUint32(offset, false);
    for (let i2 = 16; i2 < 64; i2++) {
      const W15 = SHA256_W[i2 - 15];
      const W2 = SHA256_W[i2 - 2];
      const s0 = rotr(W15, 7) ^ rotr(W15, 18) ^ W15 >>> 3;
      const s1 = rotr(W2, 17) ^ rotr(W2, 19) ^ W2 >>> 10;
      SHA256_W[i2] = s1 + SHA256_W[i2 - 7] + s0 + SHA256_W[i2 - 16] | 0;
    }
    let { A: A2, B: B2, C: C2, D: D2, E: E2, F: F2, G: G2, H: H2 } = this;
    for (let i2 = 0; i2 < 64; i2++) {
      const sigma1 = rotr(E2, 6) ^ rotr(E2, 11) ^ rotr(E2, 25);
      const T1 = H2 + sigma1 + Chi(E2, F2, G2) + SHA256_K[i2] + SHA256_W[i2] | 0;
      const sigma0 = rotr(A2, 2) ^ rotr(A2, 13) ^ rotr(A2, 22);
      const T2 = sigma0 + Maj(A2, B2, C2) | 0;
      H2 = G2;
      G2 = F2;
      F2 = E2;
      E2 = D2 + T1 | 0;
      D2 = C2;
      C2 = B2;
      B2 = A2;
      A2 = T1 + T2 | 0;
    }
    A2 = A2 + this.A | 0;
    B2 = B2 + this.B | 0;
    C2 = C2 + this.C | 0;
    D2 = D2 + this.D | 0;
    E2 = E2 + this.E | 0;
    F2 = F2 + this.F | 0;
    G2 = G2 + this.G | 0;
    H2 = H2 + this.H | 0;
    this.set(A2, B2, C2, D2, E2, F2, G2, H2);
  }
  roundClean() {
    clean(SHA256_W);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0);
    clean(this.buffer);
  }
}
class _SHA256 extends SHA2_32B {
  // We cannot use array here since array allows indexing by variable
  // which means optimizer/compiler cannot use registers.
  A = SHA256_IV[0] | 0;
  B = SHA256_IV[1] | 0;
  C = SHA256_IV[2] | 0;
  D = SHA256_IV[3] | 0;
  E = SHA256_IV[4] | 0;
  F = SHA256_IV[5] | 0;
  G = SHA256_IV[6] | 0;
  H = SHA256_IV[7] | 0;
  constructor() {
    super(32);
  }
}
const sha256 = /* @__PURE__ */ createHasher(
  () => new _SHA256(),
  /* @__PURE__ */ oidNist(1)
);
function countLines(text2) {
  return text2.split(/\n/).length;
}
function leadWhitespaceForColumn(column) {
  return Array(column + 1).join(" ").replace(/ {4}/g, "	");
}
function convertTaskToMarkdown(baseTask, taskUpdate) {
  let taskText = "- [" + toTaskStatusMarker(taskUpdate.status) + "] ";
  taskText += taskUpdate.title.replace(/\n/g, " ");
  if (taskUpdate.priority != "none") {
    taskText += " [priority::" + taskUpdate.priority + "]";
  }
  if (taskUpdate.description) {
    taskText += "\n\n";
    taskText += taskUpdate.description.replace(/^(?!$)/gm, leadWhitespaceForColumn(baseTask.startColumn + 2)).trimEnd();
  }
  return taskText;
}
function rewriteTask(markdown, baseTask, taskUpdate) {
  const newTaskMarkdown = convertTaskToMarkdown(baseTask, taskUpdate);
  const newMarkdown = markdown.slice(0, baseTask.startOffset) + newTaskMarkdown + markdown.slice(baseTask.endOffset);
  const newTask = { ...baseTask, ...taskUpdate };
  newTask.endOffset = baseTask.startOffset + newTaskMarkdown.length;
  newTask.endLine = countLines(newMarkdown.substring(0, newTask.endOffset));
  newTask.fileHash = sha256(new TextEncoder().encode(newMarkdown));
  return { newMarkdown, newTask };
}
function arrayEquals(a2, b2) {
  return a2.length === b2.length && Array.prototype.every.call(
    a2,
    (val, index) => val === b2[index]
  );
}
const version = "0.1.3";
const packageJson = {
  version
};
const CreateTaskButton = () => {
  const plugin = usePlugin();
  return /* @__PURE__ */ u$1(
    "button",
    {
      "aria-label": "Create New Task",
      onClick: () => plugin.showCreateTaskModal(),
      className: "ml-8",
      children: [
        /* @__PURE__ */ u$1(Icon, { icon: "plus" }),
        " Create New Task"
      ]
    }
  );
};
const TaskTrackHeader = ({
  taskCount,
  search,
  onChangeFilters
}) => {
  return /* @__PURE__ */ u$1("div", { className: "p-4 pb-0", children: [
    /* @__PURE__ */ u$1("div", { className: "relative", children: /* @__PURE__ */ u$1(SearchInput, { value: search, onChangeFilters }) }),
    /* @__PURE__ */ u$1("div", { className: "flex flex-row justify-between text-sm py-3 content-center", children: [
      /* @__PURE__ */ u$1("span", { className: "flex flex-col justify-center", children: [
        "Showing ",
        taskCount,
        " results."
      ] }),
      /* @__PURE__ */ u$1(CreateTaskButton, {})
    ] })
  ] });
};
function TaskList({
  onTaskClick,
  onTaskSave,
  onChangeFilters,
  search,
  activeTask
}) {
  const taskContext = useTaskContext();
  return /* @__PURE__ */ u$1("div", { className: "border-b border-(--background-modifier-border) flex flex-col h-full", children: [
    /* @__PURE__ */ u$1(
      TaskTrackHeader,
      {
        taskCount: taskContext.tasks?.length || 0,
        search,
        onChangeFilters
      }
    ),
    /* @__PURE__ */ u$1(
      TaskTable,
      {
        taskContext,
        activeTask,
        onRowClick: onTaskClick,
        onTaskSave,
        enableSorting: true
      }
    )
  ] });
}
async function saveTask(plugin, baseTask, editedTask) {
  const file = plugin.app.vault.getFileByPath(baseTask.path);
  if (!(file instanceof require$$0$1.TFile)) {
    throw new Error(
      `Unexpected modification of non-file ${JSON.stringify(baseTask.path)}`
    );
  }
  let returnTask = baseTask;
  let returnMarkdown = "";
  await plugin.app.vault.process(file, (data) => {
    returnMarkdown = data;
    if (!arrayEquals(sha256(new TextEncoder().encode(data)), baseTask.fileHash)) {
      new require$$0$1.Notice(
        "Warning! Checksum mismatch between vault file and task. Aborting."
      );
      return data;
    }
    const { newMarkdown, newTask } = rewriteTask(data, baseTask, editedTask);
    Logger.warn("[TaskTrack][TaskTrack.tsx:98]", newMarkdown, newTask);
    returnTask = newTask;
    return newMarkdown;
  });
  return { newMarkdown: returnMarkdown, newTask: returnTask };
}
function TaskTrack() {
  const plugin = usePlugin();
  const [activeTask, setActiveTask] = d(null);
  const [filers, setFilters] = d({
    keywords: [],
    statuses: [...OPEN_STATUSES],
    files: []
  });
  const search = "is:open ";
  const handleTaskClick = q$1((task) => {
    Logger.info("[TaskTrack][TaskTrack.tsx:114]", "Opening task:", task);
    setActiveTask(task);
  }, []);
  const handleCancel = q$1(() => {
    setActiveTask(null);
  }, []);
  return /* @__PURE__ */ u$1("div", { className: "flex flex-col grow h-full items-stretch", children: [
    /* @__PURE__ */ u$1("div", { className: "flex flex-row items-center p-2 border-0 border-b border-solid border-(--divider-color)", children: /* @__PURE__ */ u$1("div", { className: "text-lg font-semibold flex flex-row items-center", children: [
      /* @__PURE__ */ u$1("div", { className: "ml-2 mr-1 h-4.5 w-5", children: /* @__PURE__ */ u$1(Icon, { icon: "tasktrack" }) }),
      "TaskTrack (",
      packageJson.version,
      ")"
    ] }) }),
    /* @__PURE__ */ u$1("div", { className: "flex flex-row grow overflow-y-hidden relative", children: /* @__PURE__ */ u$1(VerticalTabContentContainer, { children: [
      /* @__PURE__ */ u$1(TaskProvider, { ...filers, database: plugin.taskDatabase, children: /* @__PURE__ */ u$1(
        TaskList,
        {
          onTaskClick: handleTaskClick,
          onTaskSave: async (baseTask, taskUpdate) => {
            const { newTask, newMarkdown } = await saveTask(
              plugin,
              baseTask,
              taskUpdate
            );
            const offsetDelta = newTask.endOffset - baseTask.endOffset;
            if (!activeTask) {
              return;
            }
            if (baseTask.path === activeTask?.path) {
              Logger.info("[TaskTrack][TaskTrack.tsx:143]", "Parallel file modification:");
              const newActiveTask = { ...activeTask };
              if (baseTask.endOffset <= activeTask.startOffset) {
                Logger.info("[TaskTrack][TaskTrack.tsx:146]", "- earlier task");
                newActiveTask.startOffset += offsetDelta;
                newActiveTask.endOffset += offsetDelta;
                newActiveTask.endLine += countLines(newMarkdown.substring(0, newTask.endOffset)) - newTask.endLine;
              } else if (baseTask.startOffset >= activeTask.endOffset) {
                Logger.info("[TaskTrack][TaskTrack.tsx:151]", "- later task");
              } else {
                Logger.info("[TaskTrack][TaskTrack.tsx:153]", "- conjoined task");
                throw new Error(
                  "Unexpected task overlap when editing multiple tasks"
                );
              }
              newActiveTask.fileHash = newTask.fileHash;
              Logger.info("[TaskTrack][TaskTrack.tsx:159]", "Updating.");
              setActiveTask(newActiveTask);
            }
          },
          search,
          activeTask,
          onChangeFilters: setFilters
        }
      ) }),
      activeTask && /* @__PURE__ */ u$1(
        TaskEditorSidebar,
        {
          task: activeTask,
          onSave: async (baseTask, taskDetails) => {
            const { newTask: updatedTask } = await saveTask(
              plugin,
              baseTask,
              taskDetails
            );
            setActiveTask(updatedTask);
          },
          onCancel: handleCancel
        }
      )
    ] }) })
  ] });
}
class TaskTrackModal extends require$$0$1.Modal {
  plugin;
  constructor(app, plugin) {
    super(app);
    this.plugin = plugin;
  }
  onOpen() {
    this.contentEl.classList.add("vertical-tabs-container");
    this.modalEl.classList.add("mod-sidebar-layout");
    this.modalEl.classList.add("mod-settings");
    G$1(
      /* @__PURE__ */ u$1(PluginProvider, { plugin: this.plugin, children: [
        /* @__PURE__ */ u$1(TaskTrack, {}),
        /* @__PURE__ */ u$1(
          "div",
          {
            className: "touchable mr-8 modal-close-button mod-raised clickable-icon",
            onClick: () => this.openInNewWindow(),
            children: /* @__PURE__ */ u$1(Icon, { icon: "picture-in-picture" })
          }
        )
      ] }),
      this.contentEl
    );
  }
  openInNewWindow() {
    try {
      const leaf = this.app.workspace.openPopoutLeaf();
      leaf.view.containerEl.empty();
      G$1(
        /* @__PURE__ */ u$1(PluginProvider, { plugin: this.plugin, children: /* @__PURE__ */ u$1(TaskTrack, {}) }),
        leaf.view.containerEl
      );
      this.close();
    } catch (error) {
      Logger.error("[TaskTrack][TaskTrackModal.tsx:43]", "Error opening task list in new window:", error);
      new require$$0$1.Notice("Failed to open task list in new window");
    }
  }
  onClose() {
    G$1(null, this.contentEl);
  }
}
const RIBBON_TOOLTIP = "TaskTrack";
const COMMAND_OPEN_TASKTRACK_MODAL = "Open TaskTrack modal";
const COMMAND_CREATE_NEW_TASK = "Create new task";
const STATUS_LOADING = "TaskTrack (Loading...)";
const STATUS_OK = "TaskTrack (OK)";
const SETTINGS_TITLE = "TaskTrack Settings";
const SETTINGS_RICH_CONTENT_NAME = "(Experimental) Use rich content in dropdowns";
const SETTINGS_RICH_CONTENT_DESC = "On supported OSes, rich content will be embedded in dropdown lists using CSS emulation.";
const DEFAULT_SETTINGS = {
  defaultProject: "",
  showDueDates: true,
  showPriority: true,
  showAssignee: true,
  dropdownEmulation: false
};
class TaskTrackSettingsTab extends require$$0$1.PluginSettingTab {
  plugin;
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
    this.icon = "tasktrack";
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    new require$$0$1.Setting(containerEl).setName(SETTINGS_TITLE).setHeading();
    new require$$0$1.Setting(containerEl).setName(SETTINGS_RICH_CONTENT_NAME).setDesc(SETTINGS_RICH_CONTENT_DESC).addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.dropdownEmulation).onChange((value) => {
        this.plugin.settings.dropdownEmulation = value;
      })
    );
  }
}
var main = {};
var hasRequiredMain;
function requireMain() {
  if (hasRequiredMain) return main;
  hasRequiredMain = 1;
  Object.defineProperty(main, "__esModule", { value: true });
  var obsidian = require$$0$1;
  const DEFAULT_DAILY_NOTE_FORMAT = "YYYY-MM-DD";
  const DEFAULT_WEEKLY_NOTE_FORMAT = "gggg-[W]ww";
  const DEFAULT_MONTHLY_NOTE_FORMAT = "YYYY-MM";
  const DEFAULT_QUARTERLY_NOTE_FORMAT = "YYYY-[Q]Q";
  const DEFAULT_YEARLY_NOTE_FORMAT = "YYYY";
  function shouldUsePeriodicNotesSettings(periodicity) {
    const periodicNotes = window.app.plugins.getPlugin("periodic-notes");
    return periodicNotes && periodicNotes.settings?.[periodicity]?.enabled;
  }
  function getDailyNoteSettings() {
    try {
      const { internalPlugins, plugins } = window.app;
      if (shouldUsePeriodicNotesSettings("daily")) {
        const { format: format2, folder: folder2, template: template2 } = plugins.getPlugin("periodic-notes")?.settings?.daily || {};
        return {
          format: format2 || DEFAULT_DAILY_NOTE_FORMAT,
          folder: folder2?.trim() || "",
          template: template2?.trim() || ""
        };
      }
      const { folder, format, template } = internalPlugins.getPluginById("daily-notes")?.instance?.options || {};
      return {
        format: format || DEFAULT_DAILY_NOTE_FORMAT,
        folder: folder?.trim() || "",
        template: template?.trim() || ""
      };
    } catch (err) {
      console.info("No custom daily note settings found!", err);
    }
  }
  function getWeeklyNoteSettings() {
    try {
      const pluginManager = window.app.plugins;
      const calendarSettings = pluginManager.getPlugin("calendar")?.options;
      const periodicNotesSettings = pluginManager.getPlugin("periodic-notes")?.settings?.weekly;
      if (shouldUsePeriodicNotesSettings("weekly")) {
        return {
          format: periodicNotesSettings.format || DEFAULT_WEEKLY_NOTE_FORMAT,
          folder: periodicNotesSettings.folder?.trim() || "",
          template: periodicNotesSettings.template?.trim() || ""
        };
      }
      const settings = calendarSettings || {};
      return {
        format: settings.weeklyNoteFormat || DEFAULT_WEEKLY_NOTE_FORMAT,
        folder: settings.weeklyNoteFolder?.trim() || "",
        template: settings.weeklyNoteTemplate?.trim() || ""
      };
    } catch (err) {
      console.info("No custom weekly note settings found!", err);
    }
  }
  function getMonthlyNoteSettings() {
    const pluginManager = window.app.plugins;
    try {
      const settings = shouldUsePeriodicNotesSettings("monthly") && pluginManager.getPlugin("periodic-notes")?.settings?.monthly || {};
      return {
        format: settings.format || DEFAULT_MONTHLY_NOTE_FORMAT,
        folder: settings.folder?.trim() || "",
        template: settings.template?.trim() || ""
      };
    } catch (err) {
      console.info("No custom monthly note settings found!", err);
    }
  }
  function getQuarterlyNoteSettings() {
    const pluginManager = window.app.plugins;
    try {
      const settings = shouldUsePeriodicNotesSettings("quarterly") && pluginManager.getPlugin("periodic-notes")?.settings?.quarterly || {};
      return {
        format: settings.format || DEFAULT_QUARTERLY_NOTE_FORMAT,
        folder: settings.folder?.trim() || "",
        template: settings.template?.trim() || ""
      };
    } catch (err) {
      console.info("No custom quarterly note settings found!", err);
    }
  }
  function getYearlyNoteSettings() {
    const pluginManager = window.app.plugins;
    try {
      const settings = shouldUsePeriodicNotesSettings("yearly") && pluginManager.getPlugin("periodic-notes")?.settings?.yearly || {};
      return {
        format: settings.format || DEFAULT_YEARLY_NOTE_FORMAT,
        folder: settings.folder?.trim() || "",
        template: settings.template?.trim() || ""
      };
    } catch (err) {
      console.info("No custom yearly note settings found!", err);
    }
  }
  function join(...partSegments) {
    let parts = [];
    for (let i2 = 0, l2 = partSegments.length; i2 < l2; i2++) {
      parts = parts.concat(partSegments[i2].split("/"));
    }
    const newParts = [];
    for (let i2 = 0, l2 = parts.length; i2 < l2; i2++) {
      const part = parts[i2];
      if (!part || part === ".")
        continue;
      else
        newParts.push(part);
    }
    if (parts[0] === "")
      newParts.unshift("");
    return newParts.join("/");
  }
  function basename(fullPath) {
    let base = fullPath.substring(fullPath.lastIndexOf("/") + 1);
    if (base.lastIndexOf(".") != -1)
      base = base.substring(0, base.lastIndexOf("."));
    return base;
  }
  async function ensureFolderExists(path) {
    const dirs = path.replace(/\\/g, "/").split("/");
    dirs.pop();
    if (dirs.length) {
      const dir = join(...dirs);
      if (!window.app.vault.getAbstractFileByPath(dir)) {
        await window.app.vault.createFolder(dir);
      }
    }
  }
  async function getNotePath(directory, filename) {
    if (!filename.endsWith(".md")) {
      filename += ".md";
    }
    const path = obsidian.normalizePath(join(directory, filename));
    await ensureFolderExists(path);
    return path;
  }
  async function getTemplateInfo(template) {
    const { metadataCache, vault } = window.app;
    const templatePath = obsidian.normalizePath(template);
    if (templatePath === "/") {
      return Promise.resolve(["", null]);
    }
    try {
      const templateFile = metadataCache.getFirstLinkpathDest(templatePath, "");
      const contents = await vault.cachedRead(templateFile);
      const IFoldInfo = window.app.foldManager.load(templateFile);
      return [contents, IFoldInfo];
    } catch (err) {
      console.error(`Failed to read the daily note template '${templatePath}'`, err);
      new obsidian.Notice("Failed to read the daily note template");
      return ["", null];
    }
  }
  function getDateUID(date, granularity = "day") {
    const ts = date.clone().startOf(granularity).format();
    return `${granularity}-${ts}`;
  }
  function removeEscapedCharacters(format) {
    return format.replace(/\[[^\]]*\]/g, "");
  }
  function isFormatAmbiguous(format, granularity) {
    if (granularity === "week") {
      const cleanFormat = removeEscapedCharacters(format);
      return /w{1,2}/i.test(cleanFormat) && (/M{1,4}/.test(cleanFormat) || /D{1,4}/.test(cleanFormat));
    }
    return false;
  }
  function getDateFromFile(file, granularity) {
    return getDateFromFilename(file.basename, granularity);
  }
  function getDateFromPath(path, granularity) {
    return getDateFromFilename(basename(path), granularity);
  }
  function getDateFromFilename(filename, granularity) {
    const getSettings = {
      day: getDailyNoteSettings,
      week: getWeeklyNoteSettings,
      month: getMonthlyNoteSettings,
      quarter: getQuarterlyNoteSettings,
      year: getYearlyNoteSettings
    };
    const format = getSettings[granularity]().format.split("/").pop();
    const noteDate = window.moment(filename, format, true);
    if (!noteDate.isValid()) {
      return null;
    }
    if (isFormatAmbiguous(format, granularity)) {
      if (granularity === "week") {
        const cleanFormat = removeEscapedCharacters(format);
        if (/w{1,2}/i.test(cleanFormat)) {
          return window.moment(
            filename,
            // If format contains week, remove day & month formatting
            format.replace(/M{1,4}/g, "").replace(/D{1,4}/g, ""),
            false
          );
        }
      }
    }
    return noteDate;
  }
  class DailyNotesFolderMissingError extends Error {
  }
  async function createDailyNote(date) {
    const app = window.app;
    const { vault } = app;
    const moment = window.moment;
    const { template, format, folder } = getDailyNoteSettings();
    const [templateContents, IFoldInfo] = await getTemplateInfo(template);
    const filename = date.format(format);
    const normalizedPath = await getNotePath(folder, filename);
    try {
      const createdFile = await vault.create(normalizedPath, templateContents.replace(/{{\s*date\s*}}/gi, filename).replace(/{{\s*time\s*}}/gi, moment().format("HH:mm")).replace(/{{\s*title\s*}}/gi, filename).replace(/{{\s*(date|time)\s*(([+-]\d+)([yqmwdhs]))?\s*(:.+?)?}}/gi, (_2, _timeOrDate, calc, timeDelta, unit, momentFormat) => {
        const now = moment();
        const currentDate = date.clone().set({
          hour: now.get("hour"),
          minute: now.get("minute"),
          second: now.get("second")
        });
        if (calc) {
          currentDate.add(parseInt(timeDelta, 10), unit);
        }
        if (momentFormat) {
          return currentDate.format(momentFormat.substring(1).trim());
        }
        return currentDate.format(format);
      }).replace(/{{\s*yesterday\s*}}/gi, date.clone().subtract(1, "day").format(format)).replace(/{{\s*tomorrow\s*}}/gi, date.clone().add(1, "d").format(format)));
      app.foldManager.save(createdFile, IFoldInfo);
      return createdFile;
    } catch (err) {
      console.error(`Failed to create file: '${normalizedPath}'`, err);
      new obsidian.Notice("Unable to create new file.");
    }
  }
  function getDailyNote(date, dailyNotes) {
    return dailyNotes[getDateUID(date, "day")] ?? null;
  }
  function getAllDailyNotes() {
    const { vault } = window.app;
    const { folder } = getDailyNoteSettings();
    const dailyNotesFolder = vault.getAbstractFileByPath(obsidian.normalizePath(folder));
    if (!dailyNotesFolder) {
      throw new DailyNotesFolderMissingError("Failed to find daily notes folder");
    }
    const dailyNotes = {};
    obsidian.Vault.recurseChildren(dailyNotesFolder, (note) => {
      if (note instanceof obsidian.TFile) {
        const date = getDateFromFile(note, "day");
        if (date) {
          const dateString = getDateUID(date, "day");
          dailyNotes[dateString] = note;
        }
      }
    });
    return dailyNotes;
  }
  class WeeklyNotesFolderMissingError extends Error {
  }
  function getDaysOfWeek() {
    const { moment } = window;
    let weekStart = moment.localeData()._week.dow;
    const daysOfWeek = [
      "sunday",
      "monday",
      "tuesday",
      "wednesday",
      "thursday",
      "friday",
      "saturday"
    ];
    while (weekStart) {
      daysOfWeek.push(daysOfWeek.shift());
      weekStart--;
    }
    return daysOfWeek;
  }
  function getDayOfWeekNumericalValue(dayOfWeekName) {
    return getDaysOfWeek().indexOf(dayOfWeekName.toLowerCase());
  }
  async function createWeeklyNote(date) {
    const { vault } = window.app;
    const { template, format, folder } = getWeeklyNoteSettings();
    const [templateContents, IFoldInfo] = await getTemplateInfo(template);
    const filename = date.format(format);
    const normalizedPath = await getNotePath(folder, filename);
    try {
      const createdFile = await vault.create(normalizedPath, templateContents.replace(/{{\s*(date|time)\s*(([+-]\d+)([yqmwdhs]))?\s*(:.+?)?}}/gi, (_2, _timeOrDate, calc, timeDelta, unit, momentFormat) => {
        const now = window.moment();
        const currentDate = date.clone().set({
          hour: now.get("hour"),
          minute: now.get("minute"),
          second: now.get("second")
        });
        if (calc) {
          currentDate.add(parseInt(timeDelta, 10), unit);
        }
        if (momentFormat) {
          return currentDate.format(momentFormat.substring(1).trim());
        }
        return currentDate.format(format);
      }).replace(/{{\s*title\s*}}/gi, filename).replace(/{{\s*time\s*}}/gi, window.moment().format("HH:mm")).replace(/{{\s*(sunday|monday|tuesday|wednesday|thursday|friday|saturday)\s*:(.*?)}}/gi, (_2, dayOfWeek, momentFormat) => {
        const day = getDayOfWeekNumericalValue(dayOfWeek);
        return date.weekday(day).format(momentFormat.trim());
      }));
      window.app.foldManager.save(createdFile, IFoldInfo);
      return createdFile;
    } catch (err) {
      console.error(`Failed to create file: '${normalizedPath}'`, err);
      new obsidian.Notice("Unable to create new file.");
    }
  }
  function getWeeklyNote(date, weeklyNotes) {
    return weeklyNotes[getDateUID(date, "week")] ?? null;
  }
  function getAllWeeklyNotes() {
    const weeklyNotes = {};
    if (!appHasWeeklyNotesPluginLoaded()) {
      return weeklyNotes;
    }
    const { vault } = window.app;
    const { folder } = getWeeklyNoteSettings();
    const weeklyNotesFolder = vault.getAbstractFileByPath(obsidian.normalizePath(folder));
    if (!weeklyNotesFolder) {
      throw new WeeklyNotesFolderMissingError("Failed to find weekly notes folder");
    }
    obsidian.Vault.recurseChildren(weeklyNotesFolder, (note) => {
      if (note instanceof obsidian.TFile) {
        const date = getDateFromFile(note, "week");
        if (date) {
          const dateString = getDateUID(date, "week");
          weeklyNotes[dateString] = note;
        }
      }
    });
    return weeklyNotes;
  }
  class MonthlyNotesFolderMissingError extends Error {
  }
  async function createMonthlyNote(date) {
    const { vault } = window.app;
    const { template, format, folder } = getMonthlyNoteSettings();
    const [templateContents, IFoldInfo] = await getTemplateInfo(template);
    const filename = date.format(format);
    const normalizedPath = await getNotePath(folder, filename);
    try {
      const createdFile = await vault.create(normalizedPath, templateContents.replace(/{{\s*(date|time)\s*(([+-]\d+)([yqmwdhs]))?\s*(:.+?)?}}/gi, (_2, _timeOrDate, calc, timeDelta, unit, momentFormat) => {
        const now = window.moment();
        const currentDate = date.clone().set({
          hour: now.get("hour"),
          minute: now.get("minute"),
          second: now.get("second")
        });
        if (calc) {
          currentDate.add(parseInt(timeDelta, 10), unit);
        }
        if (momentFormat) {
          return currentDate.format(momentFormat.substring(1).trim());
        }
        return currentDate.format(format);
      }).replace(/{{\s*date\s*}}/gi, filename).replace(/{{\s*time\s*}}/gi, window.moment().format("HH:mm")).replace(/{{\s*title\s*}}/gi, filename));
      window.app.foldManager.save(createdFile, IFoldInfo);
      return createdFile;
    } catch (err) {
      console.error(`Failed to create file: '${normalizedPath}'`, err);
      new obsidian.Notice("Unable to create new file.");
    }
  }
  function getMonthlyNote(date, monthlyNotes) {
    return monthlyNotes[getDateUID(date, "month")] ?? null;
  }
  function getAllMonthlyNotes() {
    const monthlyNotes = {};
    if (!appHasMonthlyNotesPluginLoaded()) {
      return monthlyNotes;
    }
    const { vault } = window.app;
    const { folder } = getMonthlyNoteSettings();
    const monthlyNotesFolder = vault.getAbstractFileByPath(obsidian.normalizePath(folder));
    if (!monthlyNotesFolder) {
      throw new MonthlyNotesFolderMissingError("Failed to find monthly notes folder");
    }
    obsidian.Vault.recurseChildren(monthlyNotesFolder, (note) => {
      if (note instanceof obsidian.TFile) {
        const date = getDateFromFile(note, "month");
        if (date) {
          const dateString = getDateUID(date, "month");
          monthlyNotes[dateString] = note;
        }
      }
    });
    return monthlyNotes;
  }
  class QuarterlyNotesFolderMissingError extends Error {
  }
  async function createQuarterlyNote(date) {
    const { vault } = window.app;
    const { template, format, folder } = getQuarterlyNoteSettings();
    const [templateContents, IFoldInfo] = await getTemplateInfo(template);
    const filename = date.format(format);
    const normalizedPath = await getNotePath(folder, filename);
    try {
      const createdFile = await vault.create(normalizedPath, templateContents.replace(/{{\s*(date|time)\s*(([+-]\d+)([yqmwdhs]))?\s*(:.+?)?}}/gi, (_2, _timeOrDate, calc, timeDelta, unit, momentFormat) => {
        const now = window.moment();
        const currentDate = date.clone().set({
          hour: now.get("hour"),
          minute: now.get("minute"),
          second: now.get("second")
        });
        if (calc) {
          currentDate.add(parseInt(timeDelta, 10), unit);
        }
        if (momentFormat) {
          return currentDate.format(momentFormat.substring(1).trim());
        }
        return currentDate.format(format);
      }).replace(/{{\s*date\s*}}/gi, filename).replace(/{{\s*time\s*}}/gi, window.moment().format("HH:mm")).replace(/{{\s*title\s*}}/gi, filename));
      window.app.foldManager.save(createdFile, IFoldInfo);
      return createdFile;
    } catch (err) {
      console.error(`Failed to create file: '${normalizedPath}'`, err);
      new obsidian.Notice("Unable to create new file.");
    }
  }
  function getQuarterlyNote(date, quarterly) {
    return quarterly[getDateUID(date, "quarter")] ?? null;
  }
  function getAllQuarterlyNotes() {
    const quarterly = {};
    if (!appHasQuarterlyNotesPluginLoaded()) {
      return quarterly;
    }
    const { vault } = window.app;
    const { folder } = getQuarterlyNoteSettings();
    const quarterlyFolder = vault.getAbstractFileByPath(obsidian.normalizePath(folder));
    if (!quarterlyFolder) {
      throw new QuarterlyNotesFolderMissingError("Failed to find quarterly notes folder");
    }
    obsidian.Vault.recurseChildren(quarterlyFolder, (note) => {
      if (note instanceof obsidian.TFile) {
        const date = getDateFromFile(note, "quarter");
        if (date) {
          const dateString = getDateUID(date, "quarter");
          quarterly[dateString] = note;
        }
      }
    });
    return quarterly;
  }
  class YearlyNotesFolderMissingError extends Error {
  }
  async function createYearlyNote(date) {
    const { vault } = window.app;
    const { template, format, folder } = getYearlyNoteSettings();
    const [templateContents, IFoldInfo] = await getTemplateInfo(template);
    const filename = date.format(format);
    const normalizedPath = await getNotePath(folder, filename);
    try {
      const createdFile = await vault.create(normalizedPath, templateContents.replace(/{{\s*(date|time)\s*(([+-]\d+)([yqmwdhs]))?\s*(:.+?)?}}/gi, (_2, _timeOrDate, calc, timeDelta, unit, momentFormat) => {
        const now = window.moment();
        const currentDate = date.clone().set({
          hour: now.get("hour"),
          minute: now.get("minute"),
          second: now.get("second")
        });
        if (calc) {
          currentDate.add(parseInt(timeDelta, 10), unit);
        }
        if (momentFormat) {
          return currentDate.format(momentFormat.substring(1).trim());
        }
        return currentDate.format(format);
      }).replace(/{{\s*date\s*}}/gi, filename).replace(/{{\s*time\s*}}/gi, window.moment().format("HH:mm")).replace(/{{\s*title\s*}}/gi, filename));
      window.app.foldManager.save(createdFile, IFoldInfo);
      return createdFile;
    } catch (err) {
      console.error(`Failed to create file: '${normalizedPath}'`, err);
      new obsidian.Notice("Unable to create new file.");
    }
  }
  function getYearlyNote(date, yearlyNotes) {
    return yearlyNotes[getDateUID(date, "year")] ?? null;
  }
  function getAllYearlyNotes() {
    const yearlyNotes = {};
    if (!appHasYearlyNotesPluginLoaded()) {
      return yearlyNotes;
    }
    const { vault } = window.app;
    const { folder } = getYearlyNoteSettings();
    const yearlyNotesFolder = vault.getAbstractFileByPath(obsidian.normalizePath(folder));
    if (!yearlyNotesFolder) {
      throw new YearlyNotesFolderMissingError("Failed to find yearly notes folder");
    }
    obsidian.Vault.recurseChildren(yearlyNotesFolder, (note) => {
      if (note instanceof obsidian.TFile) {
        const date = getDateFromFile(note, "year");
        if (date) {
          const dateString = getDateUID(date, "year");
          yearlyNotes[dateString] = note;
        }
      }
    });
    return yearlyNotes;
  }
  function appHasDailyNotesPluginLoaded() {
    const { app } = window;
    const dailyNotesPlugin = app.internalPlugins.plugins["daily-notes"];
    if (dailyNotesPlugin && dailyNotesPlugin.enabled) {
      return true;
    }
    const periodicNotes = app.plugins.getPlugin("periodic-notes");
    return periodicNotes && periodicNotes.settings?.daily?.enabled;
  }
  function appHasWeeklyNotesPluginLoaded() {
    const { app } = window;
    if (app.plugins.getPlugin("calendar")) {
      return true;
    }
    const periodicNotes = app.plugins.getPlugin("periodic-notes");
    return periodicNotes && periodicNotes.settings?.weekly?.enabled;
  }
  function appHasMonthlyNotesPluginLoaded() {
    const { app } = window;
    const periodicNotes = app.plugins.getPlugin("periodic-notes");
    return periodicNotes && periodicNotes.settings?.monthly?.enabled;
  }
  function appHasQuarterlyNotesPluginLoaded() {
    const { app } = window;
    const periodicNotes = app.plugins.getPlugin("periodic-notes");
    return periodicNotes && periodicNotes.settings?.quarterly?.enabled;
  }
  function appHasYearlyNotesPluginLoaded() {
    const { app } = window;
    const periodicNotes = app.plugins.getPlugin("periodic-notes");
    return periodicNotes && periodicNotes.settings?.yearly?.enabled;
  }
  function getPeriodicNoteSettings(granularity) {
    const getSettings = {
      day: getDailyNoteSettings,
      week: getWeeklyNoteSettings,
      month: getMonthlyNoteSettings,
      quarter: getQuarterlyNoteSettings,
      year: getYearlyNoteSettings
    }[granularity];
    return getSettings();
  }
  function createPeriodicNote(granularity, date) {
    const createFn = {
      day: createDailyNote,
      month: createMonthlyNote,
      week: createWeeklyNote
    };
    return createFn[granularity](date);
  }
  main.DEFAULT_DAILY_NOTE_FORMAT = DEFAULT_DAILY_NOTE_FORMAT;
  main.DEFAULT_MONTHLY_NOTE_FORMAT = DEFAULT_MONTHLY_NOTE_FORMAT;
  main.DEFAULT_QUARTERLY_NOTE_FORMAT = DEFAULT_QUARTERLY_NOTE_FORMAT;
  main.DEFAULT_WEEKLY_NOTE_FORMAT = DEFAULT_WEEKLY_NOTE_FORMAT;
  main.DEFAULT_YEARLY_NOTE_FORMAT = DEFAULT_YEARLY_NOTE_FORMAT;
  main.appHasDailyNotesPluginLoaded = appHasDailyNotesPluginLoaded;
  main.appHasMonthlyNotesPluginLoaded = appHasMonthlyNotesPluginLoaded;
  main.appHasQuarterlyNotesPluginLoaded = appHasQuarterlyNotesPluginLoaded;
  main.appHasWeeklyNotesPluginLoaded = appHasWeeklyNotesPluginLoaded;
  main.appHasYearlyNotesPluginLoaded = appHasYearlyNotesPluginLoaded;
  main.createDailyNote = createDailyNote;
  main.createMonthlyNote = createMonthlyNote;
  main.createPeriodicNote = createPeriodicNote;
  main.createQuarterlyNote = createQuarterlyNote;
  main.createWeeklyNote = createWeeklyNote;
  main.createYearlyNote = createYearlyNote;
  main.getAllDailyNotes = getAllDailyNotes;
  main.getAllMonthlyNotes = getAllMonthlyNotes;
  main.getAllQuarterlyNotes = getAllQuarterlyNotes;
  main.getAllWeeklyNotes = getAllWeeklyNotes;
  main.getAllYearlyNotes = getAllYearlyNotes;
  main.getDailyNote = getDailyNote;
  main.getDailyNoteSettings = getDailyNoteSettings;
  main.getDateFromFile = getDateFromFile;
  main.getDateFromPath = getDateFromPath;
  main.getDateUID = getDateUID;
  main.getMonthlyNote = getMonthlyNote;
  main.getMonthlyNoteSettings = getMonthlyNoteSettings;
  main.getPeriodicNoteSettings = getPeriodicNoteSettings;
  main.getQuarterlyNote = getQuarterlyNote;
  main.getQuarterlyNoteSettings = getQuarterlyNoteSettings;
  main.getTemplateInfo = getTemplateInfo;
  main.getWeeklyNote = getWeeklyNote;
  main.getWeeklyNoteSettings = getWeeklyNoteSettings;
  main.getYearlyNote = getYearlyNote;
  main.getYearlyNoteSettings = getYearlyNoteSettings;
  return main;
}
var mainExports = requireMain();
const TaskForm = ({ onClose }) => {
  const plugin = usePlugin();
  const handleSubmit = async (baseTask, taskUpdates) => {
    try {
      const date = require$$0$1.moment();
      const notes = mainExports.getAllDailyNotes();
      let note;
      try {
        note = mainExports.getDailyNote(date, notes);
        if (!note) {
          throw new Error("Daily note not found");
        }
      } catch (e2) {
        Logger.error("[TaskTrack][TaskCreateModal.tsx:27]", e2);
        note = await mainExports.createDailyNote(date);
      }
      if (note instanceof require$$0$1.TFile) {
        await plugin.app.vault.process(note, (content) => {
          return content + "\n" + convertTaskToMarkdown(baseTask, taskUpdates);
        });
      }
      onClose();
    } catch (error) {
      Logger.error("[TaskTrack][TaskCreateModal.tsx:37]", "Error saving task:", error);
    }
  };
  return /* @__PURE__ */ u$1("div", { className: "flex flex-col gap-4", children: /* @__PURE__ */ u$1(
    TaskEditor,
    {
      mode: "create",
      task: {
        id: "unknown",
        path: "",
        startColumn: 0,
        startOffset: 0,
        startLine: 0,
        endLine: 0,
        endOffset: 0,
        fileHash: new Uint8Array(),
        title: "",
        description: null,
        marker: " ",
        status: "none",
        priority: "none",
        project: "",
        section: "",
        assignee: "",
        dueDate: null,
        createdAt: "",
        updatedAt: "",
        completedAt: null,
        subtasks: [],
        dependencies: [],
        tags: []
      },
      onSave: handleSubmit,
      onCancel: () => {
        onClose();
      }
    }
  ) });
};
class TaskCreateModal extends require$$0$1.Modal {
  plugin;
  task;
  constructor(app, plugin) {
    super(app);
    this.plugin = plugin;
  }
  onOpen() {
    G$1(
      /* @__PURE__ */ u$1(PluginProvider, { plugin: this.plugin, children: /* @__PURE__ */ u$1(TaskForm, { onClose: () => this.close() }) }),
      this.contentEl
    );
  }
  onClose() {
    G$1(null, this.contentEl);
  }
}
const jsContent = '(function() {\n  "use strict";\n  var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};\n  function getDefaultExportFromCjs(x) {\n    return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;\n  }\n  function getAugmentedNamespace(n) {\n    if (Object.prototype.hasOwnProperty.call(n, "__esModule")) return n;\n    var f = n.default;\n    if (typeof f == "function") {\n      var a = function a2() {\n        var isInstance = false;\n        try {\n          isInstance = this instanceof a2;\n        } catch {\n        }\n        if (isInstance) {\n          return Reflect.construct(f, arguments, this.constructor);\n        }\n        return f.apply(this, arguments);\n      };\n      a.prototype = f.prototype;\n    } else a = {};\n    Object.defineProperty(a, "__esModule", { value: true });\n    Object.keys(n).forEach(function(k) {\n      var d = Object.getOwnPropertyDescriptor(n, k);\n      Object.defineProperty(a, k, d.get ? d : {\n        enumerable: true,\n        get: function() {\n          return n[k];\n        }\n      });\n    });\n    return a;\n  }\n  var dexie_min$1 = { exports: {} };\n  var dexie_min = dexie_min$1.exports;\n  var hasRequiredDexie_min;\n  function requireDexie_min() {\n    if (hasRequiredDexie_min) return dexie_min$1.exports;\n    hasRequiredDexie_min = 1;\n    (function(module2, exports$12) {\n      (function(e, t) {\n        module2.exports = t();\n      })(dexie_min, function() {\n        var s = function(e2, t2) {\n          return (s = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e3, t3) {\n            e3.__proto__ = t3;\n          } || function(e3, t3) {\n            for (var n2 in t3) Object.prototype.hasOwnProperty.call(t3, n2) && (e3[n2] = t3[n2]);\n          })(e2, t2);\n        };\n        var _ = function() {\n          return (_ = Object.assign || function(e2) {\n            for (var t2, n2 = 1, r2 = arguments.length; n2 < r2; n2++) for (var i2 in t2 = arguments[n2]) Object.prototype.hasOwnProperty.call(t2, i2) && (e2[i2] = t2[i2]);\n            return e2;\n          }).apply(this, arguments);\n        };\n        function i(e2, t2, n2) {\n          for (var r2, i2 = 0, o2 = t2.length; i2 < o2; i2++) !r2 && i2 in t2 || ((r2 = r2 || Array.prototype.slice.call(t2, 0, i2))[i2] = t2[i2]);\n          return e2.concat(r2 || Array.prototype.slice.call(t2));\n        }\n        var f = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof self ? self : "undefined" != typeof window ? window : commonjsGlobal, O = Object.keys, x = Array.isArray;\n        function a(t2, n2) {\n          return "object" != typeof n2 || O(n2).forEach(function(e2) {\n            t2[e2] = n2[e2];\n          }), t2;\n        }\n        "undefined" == typeof Promise || f.Promise || (f.Promise = Promise);\n        var c = Object.getPrototypeOf, n = {}.hasOwnProperty;\n        function m(e2, t2) {\n          return n.call(e2, t2);\n        }\n        function r(t2, n2) {\n          "function" == typeof n2 && (n2 = n2(c(t2))), ("undefined" == typeof Reflect ? O : Reflect.ownKeys)(n2).forEach(function(e2) {\n            l(t2, e2, n2[e2]);\n          });\n        }\n        var u = Object.defineProperty;\n        function l(e2, t2, n2, r2) {\n          u(e2, t2, a(n2 && m(n2, "get") && "function" == typeof n2.get ? { get: n2.get, set: n2.set, configurable: true } : { value: n2, configurable: true, writable: true }, r2));\n        }\n        function o(t2) {\n          return { from: function(e2) {\n            return t2.prototype = Object.create(e2.prototype), l(t2.prototype, "constructor", t2), { extend: r.bind(null, t2.prototype) };\n          } };\n        }\n        var h = Object.getOwnPropertyDescriptor;\n        var d = [].slice;\n        function b(e2, t2, n2) {\n          return d.call(e2, t2, n2);\n        }\n        function p(e2, t2) {\n          return t2(e2);\n        }\n        function y(e2) {\n          if (!e2) throw new Error("Assertion Failed");\n        }\n        function v(e2) {\n          f.setImmediate ? setImmediate(e2) : setTimeout(e2, 0);\n        }\n        function g(e2, t2) {\n          if ("string" == typeof t2 && m(e2, t2)) return e2[t2];\n          if (!t2) return e2;\n          if ("string" != typeof t2) {\n            for (var n2 = [], r2 = 0, i2 = t2.length; r2 < i2; ++r2) {\n              var o2 = g(e2, t2[r2]);\n              n2.push(o2);\n            }\n            return n2;\n          }\n          var a2 = t2.indexOf(".");\n          if (-1 !== a2) {\n            var u2 = e2[t2.substr(0, a2)];\n            return null == u2 ? void 0 : g(u2, t2.substr(a2 + 1));\n          }\n        }\n        function w(e2, t2, n2) {\n          if (e2 && void 0 !== t2 && !("isFrozen" in Object && Object.isFrozen(e2))) if ("string" != typeof t2 && "length" in t2) {\n            y("string" != typeof n2 && "length" in n2);\n            for (var r2 = 0, i2 = t2.length; r2 < i2; ++r2) w(e2, t2[r2], n2[r2]);\n          } else {\n            var o2, a2, u2 = t2.indexOf(".");\n            -1 !== u2 ? (o2 = t2.substr(0, u2), "" === (a2 = t2.substr(u2 + 1)) ? void 0 === n2 ? x(e2) && !isNaN(parseInt(o2)) ? e2.splice(o2, 1) : delete e2[o2] : e2[o2] = n2 : w(u2 = !(u2 = e2[o2]) || !m(e2, o2) ? e2[o2] = {} : u2, a2, n2)) : void 0 === n2 ? x(e2) && !isNaN(parseInt(t2)) ? e2.splice(t2, 1) : delete e2[t2] : e2[t2] = n2;\n          }\n        }\n        function k(e2) {\n          var t2, n2 = {};\n          for (t2 in e2) m(e2, t2) && (n2[t2] = e2[t2]);\n          return n2;\n        }\n        var t = [].concat;\n        function P(e2) {\n          return t.apply([], e2);\n        }\n        var e = "BigUint64Array,BigInt64Array,Array,Boolean,String,Date,RegExp,Blob,File,FileList,FileSystemFileHandle,FileSystemDirectoryHandle,ArrayBuffer,DataView,Uint8ClampedArray,ImageBitmap,ImageData,Map,Set,CryptoKey".split(",").concat(P([8, 16, 32, 64].map(function(t2) {\n          return ["Int", "Uint", "Float"].map(function(e2) {\n            return e2 + t2 + "Array";\n          });\n        }))).filter(function(e2) {\n          return f[e2];\n        }), K = new Set(e.map(function(e2) {\n          return f[e2];\n        }));\n        var E = null;\n        function S(e2) {\n          E = /* @__PURE__ */ new WeakMap();\n          e2 = (function e3(t2) {\n            if (!t2 || "object" != typeof t2) return t2;\n            var n2 = E.get(t2);\n            if (n2) return n2;\n            if (x(t2)) {\n              n2 = [], E.set(t2, n2);\n              for (var r2 = 0, i2 = t2.length; r2 < i2; ++r2) n2.push(e3(t2[r2]));\n            } else if (K.has(t2.constructor)) n2 = t2;\n            else {\n              var o2, a2 = c(t2);\n              for (o2 in n2 = a2 === Object.prototype ? {} : Object.create(a2), E.set(t2, n2), t2) m(t2, o2) && (n2[o2] = e3(t2[o2]));\n            }\n            return n2;\n          })(e2);\n          return E = null, e2;\n        }\n        var j = {}.toString;\n        function A(e2) {\n          return j.call(e2).slice(8, -1);\n        }\n        var C = "undefined" != typeof Symbol ? Symbol.iterator : "@@iterator", T = "symbol" == typeof C ? function(e2) {\n          var t2;\n          return null != e2 && (t2 = e2[C]) && t2.apply(e2);\n        } : function() {\n          return null;\n        };\n        function I(e2, t2) {\n          t2 = e2.indexOf(t2);\n          return 0 <= t2 && e2.splice(t2, 1), 0 <= t2;\n        }\n        var q = {};\n        function D(e2) {\n          var t2, n2, r2, i2;\n          if (1 === arguments.length) {\n            if (x(e2)) return e2.slice();\n            if (this === q && "string" == typeof e2) return [e2];\n            if (i2 = T(e2)) {\n              for (n2 = []; !(r2 = i2.next()).done; ) n2.push(r2.value);\n              return n2;\n            }\n            if (null == e2) return [e2];\n            if ("number" != typeof (t2 = e2.length)) return [e2];\n            for (n2 = new Array(t2); t2--; ) n2[t2] = e2[t2];\n            return n2;\n          }\n          for (t2 = arguments.length, n2 = new Array(t2); t2--; ) n2[t2] = arguments[t2];\n          return n2;\n        }\n        var B = "undefined" != typeof Symbol ? function(e2) {\n          return "AsyncFunction" === e2[Symbol.toStringTag];\n        } : function() {\n          return false;\n        }, R = ["Unknown", "Constraint", "Data", "TransactionInactive", "ReadOnly", "Version", "NotFound", "InvalidState", "InvalidAccess", "Abort", "Timeout", "QuotaExceeded", "Syntax", "DataClone"], F = ["Modify", "Bulk", "OpenFailed", "VersionChange", "Schema", "Upgrade", "InvalidTable", "MissingAPI", "NoSuchDatabase", "InvalidArgument", "SubTransaction", "Unsupported", "Internal", "DatabaseClosed", "PrematureCommit", "ForeignAwait"].concat(R), M = { VersionChanged: "Database version changed by other database connection", DatabaseClosed: "Database has been closed", Abort: "Transaction aborted", TransactionInactive: "Transaction has already completed or failed", MissingAPI: "IndexedDB API missing. Please visit https://tinyurl.com/y2uuvskb" };\n        function N(e2, t2) {\n          this.name = e2, this.message = t2;\n        }\n        function L(e2, t2) {\n          return e2 + ". Errors: " + Object.keys(t2).map(function(e3) {\n            return t2[e3].toString();\n          }).filter(function(e3, t3, n2) {\n            return n2.indexOf(e3) === t3;\n          }).join("\\n");\n        }\n        function U(e2, t2, n2, r2) {\n          this.failures = t2, this.failedKeys = r2, this.successCount = n2, this.message = L(e2, t2);\n        }\n        function V(e2, t2) {\n          this.name = "BulkError", this.failures = Object.keys(t2).map(function(e3) {\n            return t2[e3];\n          }), this.failuresByPos = t2, this.message = L(e2, this.failures);\n        }\n        o(N).from(Error).extend({ toString: function() {\n          return this.name + ": " + this.message;\n        } }), o(U).from(N), o(V).from(N);\n        var z = F.reduce(function(e2, t2) {\n          return e2[t2] = t2 + "Error", e2;\n        }, {}), W = N, Y = F.reduce(function(e2, n2) {\n          var r2 = n2 + "Error";\n          function t2(e3, t3) {\n            this.name = r2, e3 ? "string" == typeof e3 ? (this.message = "".concat(e3).concat(t3 ? "\\n " + t3 : ""), this.inner = t3 || null) : "object" == typeof e3 && (this.message = "".concat(e3.name, " ").concat(e3.message), this.inner = e3) : (this.message = M[n2] || r2, this.inner = null);\n          }\n          return o(t2).from(W), e2[n2] = t2, e2;\n        }, {});\n        Y.Syntax = SyntaxError, Y.Type = TypeError, Y.Range = RangeError;\n        var $ = R.reduce(function(e2, t2) {\n          return e2[t2 + "Error"] = Y[t2], e2;\n        }, {});\n        var Q = F.reduce(function(e2, t2) {\n          return -1 === ["Syntax", "Type", "Range"].indexOf(t2) && (e2[t2 + "Error"] = Y[t2]), e2;\n        }, {});\n        function G() {\n        }\n        function X(e2) {\n          return e2;\n        }\n        function H(t2, n2) {\n          return null == t2 || t2 === X ? n2 : function(e2) {\n            return n2(t2(e2));\n          };\n        }\n        function J(e2, t2) {\n          return function() {\n            e2.apply(this, arguments), t2.apply(this, arguments);\n          };\n        }\n        function Z(i2, o2) {\n          return i2 === G ? o2 : function() {\n            var e2 = i2.apply(this, arguments);\n            void 0 !== e2 && (arguments[0] = e2);\n            var t2 = this.onsuccess, n2 = this.onerror;\n            this.onsuccess = null, this.onerror = null;\n            var r2 = o2.apply(this, arguments);\n            return t2 && (this.onsuccess = this.onsuccess ? J(t2, this.onsuccess) : t2), n2 && (this.onerror = this.onerror ? J(n2, this.onerror) : n2), void 0 !== r2 ? r2 : e2;\n          };\n        }\n        function ee(n2, r2) {\n          return n2 === G ? r2 : function() {\n            n2.apply(this, arguments);\n            var e2 = this.onsuccess, t2 = this.onerror;\n            this.onsuccess = this.onerror = null, r2.apply(this, arguments), e2 && (this.onsuccess = this.onsuccess ? J(e2, this.onsuccess) : e2), t2 && (this.onerror = this.onerror ? J(t2, this.onerror) : t2);\n          };\n        }\n        function te(i2, o2) {\n          return i2 === G ? o2 : function(e2) {\n            var t2 = i2.apply(this, arguments);\n            a(e2, t2);\n            var n2 = this.onsuccess, r2 = this.onerror;\n            this.onsuccess = null, this.onerror = null;\n            e2 = o2.apply(this, arguments);\n            return n2 && (this.onsuccess = this.onsuccess ? J(n2, this.onsuccess) : n2), r2 && (this.onerror = this.onerror ? J(r2, this.onerror) : r2), void 0 === t2 ? void 0 === e2 ? void 0 : e2 : a(t2, e2);\n          };\n        }\n        function ne(e2, t2) {\n          return e2 === G ? t2 : function() {\n            return false !== t2.apply(this, arguments) && e2.apply(this, arguments);\n          };\n        }\n        function re(i2, o2) {\n          return i2 === G ? o2 : function() {\n            var e2 = i2.apply(this, arguments);\n            if (e2 && "function" == typeof e2.then) {\n              for (var t2 = this, n2 = arguments.length, r2 = new Array(n2); n2--; ) r2[n2] = arguments[n2];\n              return e2.then(function() {\n                return o2.apply(t2, r2);\n              });\n            }\n            return o2.apply(this, arguments);\n          };\n        }\n        Q.ModifyError = U, Q.DexieError = N, Q.BulkError = V;\n        var ie = "undefined" != typeof location && /^(http|https):\\/\\/(localhost|127\\.0\\.0\\.1)/.test(location.href);\n        function oe(e2) {\n          ie = e2;\n        }\n        var ae = {}, ue = 100, e = "undefined" == typeof Promise ? [] : (function() {\n          var e2 = Promise.resolve();\n          if ("undefined" == typeof crypto || !crypto.subtle) return [e2, c(e2), e2];\n          var t2 = crypto.subtle.digest("SHA-512", new Uint8Array([0]));\n          return [t2, c(t2), e2];\n        })(), R = e[0], F = e[1], e = e[2], F = F && F.then, se = R && R.constructor, ce = !!e;\n        var le = function(e2, t2) {\n          be.push([e2, t2]), he && (queueMicrotask(Se), he = false);\n        }, fe = true, he = true, de = [], pe = [], ye = X, ve = { id: "global", global: true, ref: 0, unhandleds: [], onunhandled: G, pgp: false, env: {}, finalize: G }, me = ve, be = [], ge = 0, we = [];\n        function _e(e2) {\n          if ("object" != typeof this) throw new TypeError("Promises must be constructed via new");\n          this._listeners = [], this._lib = false;\n          var t2 = this._PSD = me;\n          if ("function" != typeof e2) {\n            if (e2 !== ae) throw new TypeError("Not a function");\n            return this._state = arguments[1], this._value = arguments[2], void (false === this._state && Oe(this, this._value));\n          }\n          this._state = null, this._value = null, ++t2.ref, (function t3(r2, e3) {\n            try {\n              e3(function(n2) {\n                if (null === r2._state) {\n                  if (n2 === r2) throw new TypeError("A promise cannot be resolved with itself.");\n                  var e4 = r2._lib && je();\n                  n2 && "function" == typeof n2.then ? t3(r2, function(e5, t4) {\n                    n2 instanceof _e ? n2._then(e5, t4) : n2.then(e5, t4);\n                  }) : (r2._state = true, r2._value = n2, Pe(r2)), e4 && Ae();\n                }\n              }, Oe.bind(null, r2));\n            } catch (e4) {\n              Oe(r2, e4);\n            }\n          })(this, e2);\n        }\n        var xe = { get: function() {\n          var u2 = me, t2 = Fe;\n          function e2(n2, r2) {\n            var i2 = this, o2 = !u2.global && (u2 !== me || t2 !== Fe), a2 = o2 && !Ue(), e3 = new _e(function(e4, t3) {\n              Ke(i2, new ke(Qe(n2, u2, o2, a2), Qe(r2, u2, o2, a2), e4, t3, u2));\n            });\n            return this._consoleTask && (e3._consoleTask = this._consoleTask), e3;\n          }\n          return e2.prototype = ae, e2;\n        }, set: function(e2) {\n          l(this, "then", e2 && e2.prototype === ae ? xe : { get: function() {\n            return e2;\n          }, set: xe.set });\n        } };\n        function ke(e2, t2, n2, r2, i2) {\n          this.onFulfilled = "function" == typeof e2 ? e2 : null, this.onRejected = "function" == typeof t2 ? t2 : null, this.resolve = n2, this.reject = r2, this.psd = i2;\n        }\n        function Oe(e2, t2) {\n          var n2, r2;\n          pe.push(t2), null === e2._state && (n2 = e2._lib && je(), t2 = ye(t2), e2._state = false, e2._value = t2, r2 = e2, de.some(function(e3) {\n            return e3._value === r2._value;\n          }) || de.push(r2), Pe(e2), n2 && Ae());\n        }\n        function Pe(e2) {\n          var t2 = e2._listeners;\n          e2._listeners = [];\n          for (var n2 = 0, r2 = t2.length; n2 < r2; ++n2) Ke(e2, t2[n2]);\n          var i2 = e2._PSD;\n          --i2.ref || i2.finalize(), 0 === ge && (++ge, le(function() {\n            0 == --ge && Ce();\n          }, []));\n        }\n        function Ke(e2, t2) {\n          if (null !== e2._state) {\n            var n2 = e2._state ? t2.onFulfilled : t2.onRejected;\n            if (null === n2) return (e2._state ? t2.resolve : t2.reject)(e2._value);\n            ++t2.psd.ref, ++ge, le(Ee, [n2, e2, t2]);\n          } else e2._listeners.push(t2);\n        }\n        function Ee(e2, t2, n2) {\n          try {\n            var r2, i2 = t2._value;\n            !t2._state && pe.length && (pe = []), r2 = ie && t2._consoleTask ? t2._consoleTask.run(function() {\n              return e2(i2);\n            }) : e2(i2), t2._state || -1 !== pe.indexOf(i2) || (function(e3) {\n              var t3 = de.length;\n              for (; t3; ) if (de[--t3]._value === e3._value) return de.splice(t3, 1);\n            })(t2), n2.resolve(r2);\n          } catch (e3) {\n            n2.reject(e3);\n          } finally {\n            0 == --ge && Ce(), --n2.psd.ref || n2.psd.finalize();\n          }\n        }\n        function Se() {\n          $e(ve, function() {\n            je() && Ae();\n          });\n        }\n        function je() {\n          var e2 = fe;\n          return he = fe = false, e2;\n        }\n        function Ae() {\n          var e2, t2, n2;\n          do {\n            for (; 0 < be.length; ) for (e2 = be, be = [], n2 = e2.length, t2 = 0; t2 < n2; ++t2) {\n              var r2 = e2[t2];\n              r2[0].apply(null, r2[1]);\n            }\n          } while (0 < be.length);\n          he = fe = true;\n        }\n        function Ce() {\n          var e2 = de;\n          de = [], e2.forEach(function(e3) {\n            e3._PSD.onunhandled.call(null, e3._value, e3);\n          });\n          for (var t2 = we.slice(0), n2 = t2.length; n2; ) t2[--n2]();\n        }\n        function Te(e2) {\n          return new _e(ae, false, e2);\n        }\n        function Ie(n2, r2) {\n          var i2 = me;\n          return function() {\n            var e2 = je(), t2 = me;\n            try {\n              return We(i2, true), n2.apply(this, arguments);\n            } catch (e3) {\n              r2 && r2(e3);\n            } finally {\n              We(t2, false), e2 && Ae();\n            }\n          };\n        }\n        r(_e.prototype, { then: xe, _then: function(e2, t2) {\n          Ke(this, new ke(null, null, e2, t2, me));\n        }, catch: function(e2) {\n          if (1 === arguments.length) return this.then(null, e2);\n          var t2 = e2, n2 = arguments[1];\n          return "function" == typeof t2 ? this.then(null, function(e3) {\n            return (e3 instanceof t2 ? n2 : Te)(e3);\n          }) : this.then(null, function(e3) {\n            return (e3 && e3.name === t2 ? n2 : Te)(e3);\n          });\n        }, finally: function(t2) {\n          return this.then(function(e2) {\n            return _e.resolve(t2()).then(function() {\n              return e2;\n            });\n          }, function(e2) {\n            return _e.resolve(t2()).then(function() {\n              return Te(e2);\n            });\n          });\n        }, timeout: function(r2, i2) {\n          var o2 = this;\n          return r2 < 1 / 0 ? new _e(function(e2, t2) {\n            var n2 = setTimeout(function() {\n              return t2(new Y.Timeout(i2));\n            }, r2);\n            o2.then(e2, t2).finally(clearTimeout.bind(null, n2));\n          }) : this;\n        } }), "undefined" != typeof Symbol && Symbol.toStringTag && l(_e.prototype, Symbol.toStringTag, "Dexie.Promise"), ve.env = Ye(), r(_e, { all: function() {\n          var o2 = D.apply(null, arguments).map(Ve);\n          return new _e(function(n2, r2) {\n            0 === o2.length && n2([]);\n            var i2 = o2.length;\n            o2.forEach(function(e2, t2) {\n              return _e.resolve(e2).then(function(e3) {\n                o2[t2] = e3, --i2 || n2(o2);\n              }, r2);\n            });\n          });\n        }, resolve: function(n2) {\n          return n2 instanceof _e ? n2 : n2 && "function" == typeof n2.then ? new _e(function(e2, t2) {\n            n2.then(e2, t2);\n          }) : new _e(ae, true, n2);\n        }, reject: Te, race: function() {\n          var e2 = D.apply(null, arguments).map(Ve);\n          return new _e(function(t2, n2) {\n            e2.map(function(e3) {\n              return _e.resolve(e3).then(t2, n2);\n            });\n          });\n        }, PSD: { get: function() {\n          return me;\n        }, set: function(e2) {\n          return me = e2;\n        } }, totalEchoes: { get: function() {\n          return Fe;\n        } }, newPSD: Ne, usePSD: $e, scheduler: { get: function() {\n          return le;\n        }, set: function(e2) {\n          le = e2;\n        } }, rejectionMapper: { get: function() {\n          return ye;\n        }, set: function(e2) {\n          ye = e2;\n        } }, follow: function(i2, n2) {\n          return new _e(function(e2, t2) {\n            return Ne(function(n3, r2) {\n              var e3 = me;\n              e3.unhandleds = [], e3.onunhandled = r2, e3.finalize = J(function() {\n                var t3, e4 = this;\n                t3 = function() {\n                  0 === e4.unhandleds.length ? n3() : r2(e4.unhandleds[0]);\n                }, we.push(function e5() {\n                  t3(), we.splice(we.indexOf(e5), 1);\n                }), ++ge, le(function() {\n                  0 == --ge && Ce();\n                }, []);\n              }, e3.finalize), i2();\n            }, n2, e2, t2);\n          });\n        } }), se && (se.allSettled && l(_e, "allSettled", function() {\n          var e2 = D.apply(null, arguments).map(Ve);\n          return new _e(function(n2) {\n            0 === e2.length && n2([]);\n            var r2 = e2.length, i2 = new Array(r2);\n            e2.forEach(function(e3, t2) {\n              return _e.resolve(e3).then(function(e4) {\n                return i2[t2] = { status: "fulfilled", value: e4 };\n              }, function(e4) {\n                return i2[t2] = { status: "rejected", reason: e4 };\n              }).then(function() {\n                return --r2 || n2(i2);\n              });\n            });\n          });\n        }), se.any && "undefined" != typeof AggregateError && l(_e, "any", function() {\n          var e2 = D.apply(null, arguments).map(Ve);\n          return new _e(function(n2, r2) {\n            0 === e2.length && r2(new AggregateError([]));\n            var i2 = e2.length, o2 = new Array(i2);\n            e2.forEach(function(e3, t2) {\n              return _e.resolve(e3).then(function(e4) {\n                return n2(e4);\n              }, function(e4) {\n                o2[t2] = e4, --i2 || r2(new AggregateError(o2));\n              });\n            });\n          });\n        }), se.withResolvers && (_e.withResolvers = se.withResolvers));\n        var qe = { awaits: 0, echoes: 0, id: 0 }, De = 0, Be = [], Re = 0, Fe = 0, Me = 0;\n        function Ne(e2, t2, n2, r2) {\n          var i2 = me, o2 = Object.create(i2);\n          o2.parent = i2, o2.ref = 0, o2.global = false, o2.id = ++Me, ve.env, o2.env = ce ? { Promise: _e, PromiseProp: { value: _e, configurable: true, writable: true }, all: _e.all, race: _e.race, allSettled: _e.allSettled, any: _e.any, resolve: _e.resolve, reject: _e.reject } : {}, t2 && a(o2, t2), ++i2.ref, o2.finalize = function() {\n            --this.parent.ref || this.parent.finalize();\n          };\n          r2 = $e(o2, e2, n2, r2);\n          return 0 === o2.ref && o2.finalize(), r2;\n        }\n        function Le() {\n          return qe.id || (qe.id = ++De), ++qe.awaits, qe.echoes += ue, qe.id;\n        }\n        function Ue() {\n          return !!qe.awaits && (0 == --qe.awaits && (qe.id = 0), qe.echoes = qe.awaits * ue, true);\n        }\n        function Ve(e2) {\n          return qe.echoes && e2 && e2.constructor === se ? (Le(), e2.then(function(e3) {\n            return Ue(), e3;\n          }, function(e3) {\n            return Ue(), Xe(e3);\n          })) : e2;\n        }\n        function ze() {\n          var e2 = Be[Be.length - 1];\n          Be.pop(), We(e2, false);\n        }\n        function We(e2, t2) {\n          var n2, r2 = me;\n          (t2 ? !qe.echoes || Re++ && e2 === me : !Re || --Re && e2 === me) || queueMicrotask(t2 ? function(e3) {\n            ++Fe, qe.echoes && 0 != --qe.echoes || (qe.echoes = qe.awaits = qe.id = 0), Be.push(me), We(e3, true);\n          }.bind(null, e2) : ze), e2 !== me && (me = e2, r2 === ve && (ve.env = Ye()), ce && (n2 = ve.env.Promise, t2 = e2.env, (r2.global || e2.global) && (Object.defineProperty(f, "Promise", t2.PromiseProp), n2.all = t2.all, n2.race = t2.race, n2.resolve = t2.resolve, n2.reject = t2.reject, t2.allSettled && (n2.allSettled = t2.allSettled), t2.any && (n2.any = t2.any))));\n        }\n        function Ye() {\n          var e2 = f.Promise;\n          return ce ? { Promise: e2, PromiseProp: Object.getOwnPropertyDescriptor(f, "Promise"), all: e2.all, race: e2.race, allSettled: e2.allSettled, any: e2.any, resolve: e2.resolve, reject: e2.reject } : {};\n        }\n        function $e(e2, t2, n2, r2, i2) {\n          var o2 = me;\n          try {\n            return We(e2, true), t2(n2, r2, i2);\n          } finally {\n            We(o2, false);\n          }\n        }\n        function Qe(t2, n2, r2, i2) {\n          return "function" != typeof t2 ? t2 : function() {\n            var e2 = me;\n            r2 && Le(), We(n2, true);\n            try {\n              return t2.apply(this, arguments);\n            } finally {\n              We(e2, false), i2 && queueMicrotask(Ue);\n            }\n          };\n        }\n        function Ge(e2) {\n          Promise === se && 0 === qe.echoes ? 0 === Re ? e2() : enqueueNativeMicroTask(e2) : setTimeout(e2, 0);\n        }\n        -1 === ("" + F).indexOf("[native code]") && (Le = Ue = G);\n        var Xe = _e.reject;\n        var He = String.fromCharCode(65535), Je = "Invalid key provided. Keys must be of type string, number, Date or Array<string | number | Date>.", Ze = "String expected.", et = [], tt = "__dbnames", nt = "readonly", rt = "readwrite";\n        function it(e2, t2) {\n          return e2 ? t2 ? function() {\n            return e2.apply(this, arguments) && t2.apply(this, arguments);\n          } : e2 : t2;\n        }\n        var ot = { type: 3, lower: -1 / 0, lowerOpen: false, upper: [[]], upperOpen: false };\n        function at(t2) {\n          return "string" != typeof t2 || /\\./.test(t2) ? function(e2) {\n            return e2;\n          } : function(e2) {\n            return void 0 === e2[t2] && t2 in e2 && delete (e2 = S(e2))[t2], e2;\n          };\n        }\n        function ut() {\n          throw Y.Type("Entity instances must never be new:ed. Instances are generated by the framework bypassing the constructor.");\n        }\n        function st(e2, t2) {\n          try {\n            var n2 = ct(e2), r2 = ct(t2);\n            if (n2 !== r2) return "Array" === n2 ? 1 : "Array" === r2 ? -1 : "binary" === n2 ? 1 : "binary" === r2 ? -1 : "string" === n2 ? 1 : "string" === r2 ? -1 : "Date" === n2 ? 1 : "Date" !== r2 ? NaN : -1;\n            switch (n2) {\n              case "number":\n              case "Date":\n              case "string":\n                return t2 < e2 ? 1 : e2 < t2 ? -1 : 0;\n              case "binary":\n                return (function(e3, t3) {\n                  for (var n3 = e3.length, r3 = t3.length, i2 = n3 < r3 ? n3 : r3, o2 = 0; o2 < i2; ++o2) if (e3[o2] !== t3[o2]) return e3[o2] < t3[o2] ? -1 : 1;\n                  return n3 === r3 ? 0 : n3 < r3 ? -1 : 1;\n                })(lt(e2), lt(t2));\n              case "Array":\n                return (function(e3, t3) {\n                  for (var n3 = e3.length, r3 = t3.length, i2 = n3 < r3 ? n3 : r3, o2 = 0; o2 < i2; ++o2) {\n                    var a2 = st(e3[o2], t3[o2]);\n                    if (0 !== a2) return a2;\n                  }\n                  return n3 === r3 ? 0 : n3 < r3 ? -1 : 1;\n                })(e2, t2);\n            }\n          } catch (e3) {\n          }\n          return NaN;\n        }\n        function ct(e2) {\n          var t2 = typeof e2;\n          if ("object" != t2) return t2;\n          if (ArrayBuffer.isView(e2)) return "binary";\n          e2 = A(e2);\n          return "ArrayBuffer" === e2 ? "binary" : e2;\n        }\n        function lt(e2) {\n          return e2 instanceof Uint8Array ? e2 : ArrayBuffer.isView(e2) ? new Uint8Array(e2.buffer, e2.byteOffset, e2.byteLength) : new Uint8Array(e2);\n        }\n        function ft(t2, n2, r2) {\n          var e2 = t2.schema.yProps;\n          return e2 ? (n2 && 0 < r2.numFailures && (n2 = n2.filter(function(e3, t3) {\n            return !r2.failures[t3];\n          })), Promise.all(e2.map(function(e3) {\n            e3 = e3.updatesTable;\n            return n2 ? t2.db.table(e3).where("k").anyOf(n2).delete() : t2.db.table(e3).clear();\n          })).then(function() {\n            return r2;\n          })) : r2;\n        }\n        var ht = (dt.prototype.execute = function(e2) {\n          var t2 = this["@@propmod"];\n          if (void 0 !== t2.add) {\n            var n2 = t2.add;\n            if (x(n2)) return i(i([], x(e2) ? e2 : [], true), n2).sort();\n            if ("number" == typeof n2) return (Number(e2) || 0) + n2;\n            if ("bigint" == typeof n2) try {\n              return BigInt(e2) + n2;\n            } catch (e3) {\n              return BigInt(0) + n2;\n            }\n            throw new TypeError("Invalid term ".concat(n2));\n          }\n          if (void 0 !== t2.remove) {\n            var r2 = t2.remove;\n            if (x(r2)) return x(e2) ? e2.filter(function(e3) {\n              return !r2.includes(e3);\n            }).sort() : [];\n            if ("number" == typeof r2) return Number(e2) - r2;\n            if ("bigint" == typeof r2) try {\n              return BigInt(e2) - r2;\n            } catch (e3) {\n              return BigInt(0) - r2;\n            }\n            throw new TypeError("Invalid subtrahend ".concat(r2));\n          }\n          n2 = null === (n2 = t2.replacePrefix) || void 0 === n2 ? void 0 : n2[0];\n          return n2 && "string" == typeof e2 && e2.startsWith(n2) ? t2.replacePrefix[1] + e2.substring(n2.length) : e2;\n        }, dt);\n        function dt(e2) {\n          this["@@propmod"] = e2;\n        }\n        function pt(e2, t2) {\n          for (var n2 = O(t2), r2 = n2.length, i2 = false, o2 = 0; o2 < r2; ++o2) {\n            var a2 = n2[o2], u2 = t2[a2], s2 = g(e2, a2);\n            u2 instanceof ht ? (w(e2, a2, u2.execute(s2)), i2 = true) : s2 !== u2 && (w(e2, a2, u2), i2 = true);\n          }\n          return i2;\n        }\n        var yt = (vt.prototype._trans = function(e2, r2, t2) {\n          var n2 = this._tx || me.trans, i2 = this.name, o2 = ie && "undefined" != typeof console && console.createTask && console.createTask("Dexie: ".concat("readonly" === e2 ? "read" : "write", " ").concat(this.name));\n          function a2(e3, t3, n3) {\n            if (!n3.schema[i2]) throw new Y.NotFound("Table " + i2 + " not part of transaction");\n            return r2(n3.idbtrans, n3);\n          }\n          var u2 = je();\n          try {\n            var s2 = n2 && n2.db._novip === this.db._novip ? n2 === me.trans ? n2._promise(e2, a2, t2) : Ne(function() {\n              return n2._promise(e2, a2, t2);\n            }, { trans: n2, transless: me.transless || me }) : (function t3(n3, r3, i3, o3) {\n              if (n3.idbdb && (n3._state.openComplete || me.letThrough || n3._vip)) {\n                var a3 = n3._createTransaction(r3, i3, n3._dbSchema);\n                try {\n                  a3.create(), n3._state.PR1398_maxLoop = 3;\n                } catch (e3) {\n                  return e3.name === z.InvalidState && n3.isOpen() && 0 < --n3._state.PR1398_maxLoop ? (console.warn("Dexie: Need to reopen db"), n3.close({ disableAutoOpen: false }), n3.open().then(function() {\n                    return t3(n3, r3, i3, o3);\n                  })) : Xe(e3);\n                }\n                return a3._promise(r3, function(e3, t4) {\n                  return Ne(function() {\n                    return me.trans = a3, o3(e3, t4, a3);\n                  });\n                }).then(function(e3) {\n                  if ("readwrite" === r3) try {\n                    a3.idbtrans.commit();\n                  } catch (e4) {\n                  }\n                  return "readonly" === r3 ? e3 : a3._completion.then(function() {\n                    return e3;\n                  });\n                });\n              }\n              if (n3._state.openComplete) return Xe(new Y.DatabaseClosed(n3._state.dbOpenError));\n              if (!n3._state.isBeingOpened) {\n                if (!n3._state.autoOpen) return Xe(new Y.DatabaseClosed());\n                n3.open().catch(G);\n              }\n              return n3._state.dbReadyPromise.then(function() {\n                return t3(n3, r3, i3, o3);\n              });\n            })(this.db, e2, [this.name], a2);\n            return o2 && (s2._consoleTask = o2, s2 = s2.catch(function(e3) {\n              return console.trace(e3), Xe(e3);\n            })), s2;\n          } finally {\n            u2 && Ae();\n          }\n        }, vt.prototype.get = function(t2, e2) {\n          var n2 = this;\n          return t2 && t2.constructor === Object ? this.where(t2).first(e2) : null == t2 ? Xe(new Y.Type("Invalid argument to Table.get()")) : this._trans("readonly", function(e3) {\n            return n2.core.get({ trans: e3, key: t2 }).then(function(e4) {\n              return n2.hook.reading.fire(e4);\n            });\n          }).then(e2);\n        }, vt.prototype.where = function(o2) {\n          if ("string" == typeof o2) return new this.db.WhereClause(this, o2);\n          if (x(o2)) return new this.db.WhereClause(this, "[".concat(o2.join("+"), "]"));\n          var n2 = O(o2);\n          if (1 === n2.length) return this.where(n2[0]).equals(o2[n2[0]]);\n          var e2 = this.schema.indexes.concat(this.schema.primKey).filter(function(t3) {\n            if (t3.compound && n2.every(function(e4) {\n              return 0 <= t3.keyPath.indexOf(e4);\n            })) {\n              for (var e3 = 0; e3 < n2.length; ++e3) if (-1 === n2.indexOf(t3.keyPath[e3])) return false;\n              return true;\n            }\n            return false;\n          }).sort(function(e3, t3) {\n            return e3.keyPath.length - t3.keyPath.length;\n          })[0];\n          if (e2 && this.db._maxKey !== He) {\n            var t2 = e2.keyPath.slice(0, n2.length);\n            return this.where(t2).equals(t2.map(function(e3) {\n              return o2[e3];\n            }));\n          }\n          !e2 && ie && console.warn("The query ".concat(JSON.stringify(o2), " on ").concat(this.name, " would benefit from a ") + "compound index [".concat(n2.join("+"), "]"));\n          var a2 = this.schema.idxByName;\n          function u2(e3, t3) {\n            return 0 === st(e3, t3);\n          }\n          var r2 = n2.reduce(function(e3, t3) {\n            var n3 = e3[0], r3 = e3[1], e3 = a2[t3], i2 = o2[t3];\n            return [n3 || e3, n3 || !e3 ? it(r3, e3 && e3.multi ? function(e4) {\n              e4 = g(e4, t3);\n              return x(e4) && e4.some(function(e5) {\n                return u2(i2, e5);\n              });\n            } : function(e4) {\n              return u2(i2, g(e4, t3));\n            }) : r3];\n          }, [null, null]), t2 = r2[0], r2 = r2[1];\n          return t2 ? this.where(t2.name).equals(o2[t2.keyPath]).filter(r2) : e2 ? this.filter(r2) : this.where(n2).equals("");\n        }, vt.prototype.filter = function(e2) {\n          return this.toCollection().and(e2);\n        }, vt.prototype.count = function(e2) {\n          return this.toCollection().count(e2);\n        }, vt.prototype.offset = function(e2) {\n          return this.toCollection().offset(e2);\n        }, vt.prototype.limit = function(e2) {\n          return this.toCollection().limit(e2);\n        }, vt.prototype.each = function(e2) {\n          return this.toCollection().each(e2);\n        }, vt.prototype.toArray = function(e2) {\n          return this.toCollection().toArray(e2);\n        }, vt.prototype.toCollection = function() {\n          return new this.db.Collection(new this.db.WhereClause(this));\n        }, vt.prototype.orderBy = function(e2) {\n          return new this.db.Collection(new this.db.WhereClause(this, x(e2) ? "[".concat(e2.join("+"), "]") : e2));\n        }, vt.prototype.reverse = function() {\n          return this.toCollection().reverse();\n        }, vt.prototype.mapToClass = function(r2) {\n          var e2, t2 = this.db, n2 = this.name;\n          function i2() {\n            return null !== e2 && e2.apply(this, arguments) || this;\n          }\n          (this.schema.mappedClass = r2).prototype instanceof ut && ((function(e3, t3) {\n            if ("function" != typeof t3 && null !== t3) throw new TypeError("Class extends value " + String(t3) + " is not a constructor or null");\n            function n3() {\n              this.constructor = e3;\n            }\n            s(e3, t3), e3.prototype = null === t3 ? Object.create(t3) : (n3.prototype = t3.prototype, new n3());\n          })(i2, e2 = r2), Object.defineProperty(i2.prototype, "db", { get: function() {\n            return t2;\n          }, enumerable: false, configurable: true }), i2.prototype.table = function() {\n            return n2;\n          }, r2 = i2);\n          for (var o2 = /* @__PURE__ */ new Set(), a2 = r2.prototype; a2; a2 = c(a2)) Object.getOwnPropertyNames(a2).forEach(function(e3) {\n            return o2.add(e3);\n          });\n          function u2(e3) {\n            if (!e3) return e3;\n            var t3, n3 = Object.create(r2.prototype);\n            for (t3 in e3) if (!o2.has(t3)) try {\n              n3[t3] = e3[t3];\n            } catch (e4) {\n            }\n            return n3;\n          }\n          return this.schema.readHook && this.hook.reading.unsubscribe(this.schema.readHook), this.schema.readHook = u2, this.hook("reading", u2), r2;\n        }, vt.prototype.defineClass = function() {\n          return this.mapToClass(function(e2) {\n            a(this, e2);\n          });\n        }, vt.prototype.add = function(t2, n2) {\n          var r2 = this, e2 = this.schema.primKey, i2 = e2.auto, o2 = e2.keyPath, a2 = t2;\n          return o2 && i2 && (a2 = at(o2)(t2)), this._trans("readwrite", function(e3) {\n            return r2.core.mutate({ trans: e3, type: "add", keys: null != n2 ? [n2] : null, values: [a2] });\n          }).then(function(e3) {\n            return e3.numFailures ? _e.reject(e3.failures[0]) : e3.lastResult;\n          }).then(function(e3) {\n            if (o2) try {\n              w(t2, o2, e3);\n            } catch (e4) {\n            }\n            return e3;\n          });\n        }, vt.prototype.upsert = function(r2, i2) {\n          var o2 = this, a2 = this.schema.primKey.keyPath;\n          return this._trans("readwrite", function(n2) {\n            return o2.core.get({ trans: n2, key: r2 }).then(function(t2) {\n              var e2 = null != t2 ? t2 : {};\n              return pt(e2, i2), a2 && w(e2, a2, r2), o2.core.mutate({ trans: n2, type: "put", values: [e2], keys: [r2], upsert: true, updates: { keys: [r2], changeSpecs: [i2] } }).then(function(e3) {\n                return e3.numFailures ? _e.reject(e3.failures[0]) : !!t2;\n              });\n            });\n          });\n        }, vt.prototype.update = function(e2, t2) {\n          if ("object" != typeof e2 || x(e2)) return this.where(":id").equals(e2).modify(t2);\n          e2 = g(e2, this.schema.primKey.keyPath);\n          return void 0 === e2 ? Xe(new Y.InvalidArgument("Given object does not contain its primary key")) : this.where(":id").equals(e2).modify(t2);\n        }, vt.prototype.put = function(t2, n2) {\n          var r2 = this, e2 = this.schema.primKey, i2 = e2.auto, o2 = e2.keyPath, a2 = t2;\n          return o2 && i2 && (a2 = at(o2)(t2)), this._trans("readwrite", function(e3) {\n            return r2.core.mutate({ trans: e3, type: "put", values: [a2], keys: null != n2 ? [n2] : null });\n          }).then(function(e3) {\n            return e3.numFailures ? _e.reject(e3.failures[0]) : e3.lastResult;\n          }).then(function(e3) {\n            if (o2) try {\n              w(t2, o2, e3);\n            } catch (e4) {\n            }\n            return e3;\n          });\n        }, vt.prototype.delete = function(t2) {\n          var n2 = this;\n          return this._trans("readwrite", function(e2) {\n            return n2.core.mutate({ trans: e2, type: "delete", keys: [t2] }).then(function(e3) {\n              return ft(n2, [t2], e3);\n            }).then(function(e3) {\n              return e3.numFailures ? _e.reject(e3.failures[0]) : void 0;\n            });\n          });\n        }, vt.prototype.clear = function() {\n          var t2 = this;\n          return this._trans("readwrite", function(e2) {\n            return t2.core.mutate({ trans: e2, type: "deleteRange", range: ot }).then(function(e3) {\n              return ft(t2, null, e3);\n            });\n          }).then(function(e2) {\n            return e2.numFailures ? _e.reject(e2.failures[0]) : void 0;\n          });\n        }, vt.prototype.bulkGet = function(t2) {\n          var n2 = this;\n          return this._trans("readonly", function(e2) {\n            return n2.core.getMany({ keys: t2, trans: e2 }).then(function(e3) {\n              return e3.map(function(e4) {\n                return n2.hook.reading.fire(e4);\n              });\n            });\n          });\n        }, vt.prototype.bulkAdd = function(r2, e2, t2) {\n          var o2 = this, a2 = Array.isArray(e2) ? e2 : void 0, u2 = (t2 = t2 || (a2 ? void 0 : e2)) ? t2.allKeys : void 0;\n          return this._trans("readwrite", function(e3) {\n            var t3 = o2.schema.primKey, n2 = t3.auto, t3 = t3.keyPath;\n            if (t3 && a2) throw new Y.InvalidArgument("bulkAdd(): keys argument invalid on tables with inbound keys");\n            if (a2 && a2.length !== r2.length) throw new Y.InvalidArgument("Arguments objects and keys must have the same length");\n            var i2 = r2.length, t3 = t3 && n2 ? r2.map(at(t3)) : r2;\n            return o2.core.mutate({ trans: e3, type: "add", keys: a2, values: t3, wantResults: u2 }).then(function(e4) {\n              var t4 = e4.numFailures, n3 = e4.results, r3 = e4.lastResult, e4 = e4.failures;\n              if (0 === t4) return u2 ? n3 : r3;\n              throw new V("".concat(o2.name, ".bulkAdd(): ").concat(t4, " of ").concat(i2, " operations failed"), e4);\n            });\n          });\n        }, vt.prototype.bulkPut = function(r2, e2, t2) {\n          var o2 = this, a2 = Array.isArray(e2) ? e2 : void 0, u2 = (t2 = t2 || (a2 ? void 0 : e2)) ? t2.allKeys : void 0;\n          return this._trans("readwrite", function(e3) {\n            var t3 = o2.schema.primKey, n2 = t3.auto, t3 = t3.keyPath;\n            if (t3 && a2) throw new Y.InvalidArgument("bulkPut(): keys argument invalid on tables with inbound keys");\n            if (a2 && a2.length !== r2.length) throw new Y.InvalidArgument("Arguments objects and keys must have the same length");\n            var i2 = r2.length, t3 = t3 && n2 ? r2.map(at(t3)) : r2;\n            return o2.core.mutate({ trans: e3, type: "put", keys: a2, values: t3, wantResults: u2 }).then(function(e4) {\n              var t4 = e4.numFailures, n3 = e4.results, r3 = e4.lastResult, e4 = e4.failures;\n              if (0 === t4) return u2 ? n3 : r3;\n              throw new V("".concat(o2.name, ".bulkPut(): ").concat(t4, " of ").concat(i2, " operations failed"), e4);\n            });\n          });\n        }, vt.prototype.bulkUpdate = function(t2) {\n          var h2 = this, n2 = this.core, r2 = t2.map(function(e2) {\n            return e2.key;\n          }), i2 = t2.map(function(e2) {\n            return e2.changes;\n          }), d2 = [];\n          return this._trans("readwrite", function(e2) {\n            return n2.getMany({ trans: e2, keys: r2, cache: "clone" }).then(function(c2) {\n              var l2 = [], f2 = [];\n              t2.forEach(function(e3, t3) {\n                var n3 = e3.key, r3 = e3.changes, i3 = c2[t3];\n                if (i3) {\n                  for (var o2 = 0, a2 = Object.keys(r3); o2 < a2.length; o2++) {\n                    var u2 = a2[o2], s3 = r3[u2];\n                    if (u2 === h2.schema.primKey.keyPath) {\n                      if (0 !== st(s3, n3)) throw new Y.Constraint("Cannot update primary key in bulkUpdate()");\n                    } else w(i3, u2, s3);\n                  }\n                  d2.push(t3), l2.push(n3), f2.push(i3);\n                }\n              });\n              var s2 = l2.length;\n              return n2.mutate({ trans: e2, type: "put", keys: l2, values: f2, updates: { keys: r2, changeSpecs: i2 } }).then(function(e3) {\n                var t3 = e3.numFailures, n3 = e3.failures;\n                if (0 === t3) return s2;\n                for (var r3 = 0, i3 = Object.keys(n3); r3 < i3.length; r3++) {\n                  var o2, a2 = i3[r3], u2 = d2[Number(a2)];\n                  null != u2 && (o2 = n3[a2], delete n3[a2], n3[u2] = o2);\n                }\n                throw new V("".concat(h2.name, ".bulkUpdate(): ").concat(t3, " of ").concat(s2, " operations failed"), n3);\n              });\n            });\n          });\n        }, vt.prototype.bulkDelete = function(t2) {\n          var r2 = this, i2 = t2.length;\n          return this._trans("readwrite", function(e2) {\n            return r2.core.mutate({ trans: e2, type: "delete", keys: t2 }).then(function(e3) {\n              return ft(r2, t2, e3);\n            });\n          }).then(function(e2) {\n            var t3 = e2.numFailures, n2 = e2.lastResult, e2 = e2.failures;\n            if (0 === t3) return n2;\n            throw new V("".concat(r2.name, ".bulkDelete(): ").concat(t3, " of ").concat(i2, " operations failed"), e2);\n          });\n        }, vt);\n        function vt() {\n        }\n        function mt(i2) {\n          function t2(e3, t3) {\n            if (t3) {\n              for (var n3 = arguments.length, r2 = new Array(n3 - 1); --n3; ) r2[n3 - 1] = arguments[n3];\n              return a2[e3].subscribe.apply(null, r2), i2;\n            }\n            if ("string" == typeof e3) return a2[e3];\n          }\n          var a2 = {};\n          t2.addEventType = u2;\n          for (var e2 = 1, n2 = arguments.length; e2 < n2; ++e2) u2(arguments[e2]);\n          return t2;\n          function u2(e3, n3, r2) {\n            if ("object" != typeof e3) {\n              var i3;\n              n3 = n3 || ne;\n              var o2 = { subscribers: [], fire: r2 = r2 || G, subscribe: function(e4) {\n                -1 === o2.subscribers.indexOf(e4) && (o2.subscribers.push(e4), o2.fire = n3(o2.fire, e4));\n              }, unsubscribe: function(t3) {\n                o2.subscribers = o2.subscribers.filter(function(e4) {\n                  return e4 !== t3;\n                }), o2.fire = o2.subscribers.reduce(n3, r2);\n              } };\n              return a2[e3] = t2[e3] = o2;\n            }\n            O(i3 = e3).forEach(function(e4) {\n              var t3 = i3[e4];\n              if (x(t3)) u2(e4, i3[e4][0], i3[e4][1]);\n              else {\n                if ("asap" !== t3) throw new Y.InvalidArgument("Invalid event config");\n                var n4 = u2(e4, X, function() {\n                  for (var e5 = arguments.length, t4 = new Array(e5); e5--; ) t4[e5] = arguments[e5];\n                  n4.subscribers.forEach(function(e6) {\n                    v(function() {\n                      e6.apply(null, t4);\n                    });\n                  });\n                });\n              }\n            });\n          }\n        }\n        function bt(e2, t2) {\n          return o(t2).from({ prototype: e2 }), t2;\n        }\n        function gt(e2, t2) {\n          return !(e2.filter || e2.algorithm || e2.or) && (t2 ? e2.justLimit : !e2.replayFilter);\n        }\n        function wt(e2, t2) {\n          e2.filter = it(e2.filter, t2);\n        }\n        function _t(e2, t2, n2) {\n          var r2 = e2.replayFilter;\n          e2.replayFilter = r2 ? function() {\n            return it(r2(), t2());\n          } : t2, e2.justLimit = n2 && !r2;\n        }\n        function xt(e2, t2) {\n          if (e2.isPrimKey) return t2.primaryKey;\n          var n2 = t2.getIndexByKeyPath(e2.index);\n          if (!n2) throw new Y.Schema("KeyPath " + e2.index + " on object store " + t2.name + " is not indexed");\n          return n2;\n        }\n        function kt(e2, t2, n2) {\n          var r2 = xt(e2, t2.schema);\n          return t2.openCursor({ trans: n2, values: !e2.keysOnly, reverse: "prev" === e2.dir, unique: !!e2.unique, query: { index: r2, range: e2.range } });\n        }\n        function Ot(e2, o2, t2, n2) {\n          var a2 = e2.replayFilter ? it(e2.filter, e2.replayFilter()) : e2.filter;\n          if (e2.or) {\n            var u2 = {}, r2 = function(e3, t3, n3) {\n              var r3, i2;\n              a2 && !a2(t3, n3, function(e4) {\n                return t3.stop(e4);\n              }, function(e4) {\n                return t3.fail(e4);\n              }) || ("[object ArrayBuffer]" === (i2 = "" + (r3 = t3.primaryKey)) && (i2 = "" + new Uint8Array(r3)), m(u2, i2) || (u2[i2] = true, o2(e3, t3, n3)));\n            };\n            return Promise.all([e2.or._iterate(r2, t2), Pt(kt(e2, n2, t2), e2.algorithm, r2, !e2.keysOnly && e2.valueMapper)]);\n          }\n          return Pt(kt(e2, n2, t2), it(e2.algorithm, a2), o2, !e2.keysOnly && e2.valueMapper);\n        }\n        function Pt(e2, r2, i2, o2) {\n          var a2 = Ie(o2 ? function(e3, t2, n2) {\n            return i2(o2(e3), t2, n2);\n          } : i2);\n          return e2.then(function(n2) {\n            if (n2) return n2.start(function() {\n              var t2 = function() {\n                return n2.continue();\n              };\n              r2 && !r2(n2, function(e3) {\n                return t2 = e3;\n              }, function(e3) {\n                n2.stop(e3), t2 = G;\n              }, function(e3) {\n                n2.fail(e3), t2 = G;\n              }) || a2(n2.value, n2, function(e3) {\n                return t2 = e3;\n              }), t2();\n            });\n          });\n        }\n        var Kt = (Et.prototype._read = function(e2, t2) {\n          var n2 = this._ctx;\n          return n2.error ? n2.table._trans(null, Xe.bind(null, n2.error)) : n2.table._trans("readonly", e2).then(t2);\n        }, Et.prototype._write = function(e2) {\n          var t2 = this._ctx;\n          return t2.error ? t2.table._trans(null, Xe.bind(null, t2.error)) : t2.table._trans("readwrite", e2, "locked");\n        }, Et.prototype._addAlgorithm = function(e2) {\n          var t2 = this._ctx;\n          t2.algorithm = it(t2.algorithm, e2);\n        }, Et.prototype._iterate = function(e2, t2) {\n          return Ot(this._ctx, e2, t2, this._ctx.table.core);\n        }, Et.prototype.clone = function(e2) {\n          var t2 = Object.create(this.constructor.prototype), n2 = Object.create(this._ctx);\n          return e2 && a(n2, e2), t2._ctx = n2, t2;\n        }, Et.prototype.raw = function() {\n          return this._ctx.valueMapper = null, this;\n        }, Et.prototype.each = function(t2) {\n          var n2 = this._ctx;\n          return this._read(function(e2) {\n            return Ot(n2, t2, e2, n2.table.core);\n          });\n        }, Et.prototype.count = function(e2) {\n          var i2 = this;\n          return this._read(function(e3) {\n            var t2 = i2._ctx, n2 = t2.table.core;\n            if (gt(t2, true)) return n2.count({ trans: e3, query: { index: xt(t2, n2.schema), range: t2.range } }).then(function(e4) {\n              return Math.min(e4, t2.limit);\n            });\n            var r2 = 0;\n            return Ot(t2, function() {\n              return ++r2, false;\n            }, e3, n2).then(function() {\n              return r2;\n            });\n          }).then(e2);\n        }, Et.prototype.sortBy = function(e2, t2) {\n          var n2 = e2.split(".").reverse(), r2 = n2[0], i2 = n2.length - 1;\n          function o2(e3, t3) {\n            return t3 ? o2(e3[n2[t3]], t3 - 1) : e3[r2];\n          }\n          var a2 = "next" === this._ctx.dir ? 1 : -1;\n          function u2(e3, t3) {\n            return st(o2(e3, i2), o2(t3, i2)) * a2;\n          }\n          return this.toArray(function(e3) {\n            return e3.sort(u2);\n          }).then(t2);\n        }, Et.prototype.toArray = function(e2) {\n          var o2 = this;\n          return this._read(function(e3) {\n            var t2 = o2._ctx;\n            if ("next" === t2.dir && gt(t2, true) && 0 < t2.limit) {\n              var n2 = t2.valueMapper, r2 = xt(t2, t2.table.core.schema);\n              return t2.table.core.query({ trans: e3, limit: t2.limit, values: true, query: { index: r2, range: t2.range } }).then(function(e4) {\n                e4 = e4.result;\n                return n2 ? e4.map(n2) : e4;\n              });\n            }\n            var i2 = [];\n            return Ot(t2, function(e4) {\n              return i2.push(e4);\n            }, e3, t2.table.core).then(function() {\n              return i2;\n            });\n          }, e2);\n        }, Et.prototype.offset = function(t2) {\n          var e2 = this._ctx;\n          return t2 <= 0 || (e2.offset += t2, gt(e2) ? _t(e2, function() {\n            var n2 = t2;\n            return function(e3, t3) {\n              return 0 === n2 || (1 === n2 ? --n2 : t3(function() {\n                e3.advance(n2), n2 = 0;\n              }), false);\n            };\n          }) : _t(e2, function() {\n            var e3 = t2;\n            return function() {\n              return --e3 < 0;\n            };\n          })), this;\n        }, Et.prototype.limit = function(e2) {\n          return this._ctx.limit = Math.min(this._ctx.limit, e2), _t(this._ctx, function() {\n            var r2 = e2;\n            return function(e3, t2, n2) {\n              return --r2 <= 0 && t2(n2), 0 <= r2;\n            };\n          }, true), this;\n        }, Et.prototype.until = function(r2, i2) {\n          return wt(this._ctx, function(e2, t2, n2) {\n            return !r2(e2.value) || (t2(n2), i2);\n          }), this;\n        }, Et.prototype.first = function(e2) {\n          return this.limit(1).toArray(function(e3) {\n            return e3[0];\n          }).then(e2);\n        }, Et.prototype.last = function(e2) {\n          return this.reverse().first(e2);\n        }, Et.prototype.filter = function(t2) {\n          var e2;\n          return wt(this._ctx, function(e3) {\n            return t2(e3.value);\n          }), (e2 = this._ctx).isMatch = it(e2.isMatch, t2), this;\n        }, Et.prototype.and = function(e2) {\n          return this.filter(e2);\n        }, Et.prototype.or = function(e2) {\n          return new this.db.WhereClause(this._ctx.table, e2, this);\n        }, Et.prototype.reverse = function() {\n          return this._ctx.dir = "prev" === this._ctx.dir ? "next" : "prev", this._ondirectionchange && this._ondirectionchange(this._ctx.dir), this;\n        }, Et.prototype.desc = function() {\n          return this.reverse();\n        }, Et.prototype.eachKey = function(n2) {\n          var e2 = this._ctx;\n          return e2.keysOnly = !e2.isMatch, this.each(function(e3, t2) {\n            n2(t2.key, t2);\n          });\n        }, Et.prototype.eachUniqueKey = function(e2) {\n          return this._ctx.unique = "unique", this.eachKey(e2);\n        }, Et.prototype.eachPrimaryKey = function(n2) {\n          var e2 = this._ctx;\n          return e2.keysOnly = !e2.isMatch, this.each(function(e3, t2) {\n            n2(t2.primaryKey, t2);\n          });\n        }, Et.prototype.keys = function(e2) {\n          var t2 = this._ctx;\n          t2.keysOnly = !t2.isMatch;\n          var n2 = [];\n          return this.each(function(e3, t3) {\n            n2.push(t3.key);\n          }).then(function() {\n            return n2;\n          }).then(e2);\n        }, Et.prototype.primaryKeys = function(e2) {\n          var n2 = this._ctx;\n          if ("next" === n2.dir && gt(n2, true) && 0 < n2.limit) return this._read(function(e3) {\n            var t2 = xt(n2, n2.table.core.schema);\n            return n2.table.core.query({ trans: e3, values: false, limit: n2.limit, query: { index: t2, range: n2.range } });\n          }).then(function(e3) {\n            return e3.result;\n          }).then(e2);\n          n2.keysOnly = !n2.isMatch;\n          var r2 = [];\n          return this.each(function(e3, t2) {\n            r2.push(t2.primaryKey);\n          }).then(function() {\n            return r2;\n          }).then(e2);\n        }, Et.prototype.uniqueKeys = function(e2) {\n          return this._ctx.unique = "unique", this.keys(e2);\n        }, Et.prototype.firstKey = function(e2) {\n          return this.limit(1).keys(function(e3) {\n            return e3[0];\n          }).then(e2);\n        }, Et.prototype.lastKey = function(e2) {\n          return this.reverse().firstKey(e2);\n        }, Et.prototype.distinct = function() {\n          var e2 = this._ctx, e2 = e2.index && e2.table.schema.idxByName[e2.index];\n          if (!e2 || !e2.multi) return this;\n          var n2 = {};\n          return wt(this._ctx, function(e3) {\n            var t2 = e3.primaryKey.toString(), e3 = m(n2, t2);\n            return n2[t2] = true, !e3;\n          }), this;\n        }, Et.prototype.modify = function(x2) {\n          var n2 = this, k2 = this._ctx;\n          return this._write(function(p2) {\n            var y2 = "function" == typeof x2 ? x2 : function(e3) {\n              return pt(e3, x2);\n            }, v2 = k2.table.core, e2 = v2.schema.primaryKey, m2 = e2.outbound, b2 = e2.extractKey, g2 = 200, e2 = n2.db._options.modifyChunkSize;\n            e2 && (g2 = "object" == typeof e2 ? e2[v2.name] || e2["*"] || 200 : e2);\n            function w2(e3, t3) {\n              var n3 = t3.failures, t3 = t3.numFailures;\n              u2 += e3 - t3;\n              for (var r2 = 0, i2 = O(n3); r2 < i2.length; r2++) {\n                var o2 = i2[r2];\n                a2.push(n3[o2]);\n              }\n            }\n            var a2 = [], u2 = 0, t2 = [], _2 = x2 === St;\n            return n2.clone().primaryKeys().then(function(f2) {\n              function h2(s2) {\n                var c2 = Math.min(g2, f2.length - s2), l2 = f2.slice(s2, s2 + c2);\n                return (_2 ? Promise.resolve([]) : v2.getMany({ trans: p2, keys: l2, cache: "immutable" })).then(function(e3) {\n                  var n3 = [], t3 = [], r2 = m2 ? [] : null, i2 = _2 ? l2 : [];\n                  if (!_2) for (var o2 = 0; o2 < c2; ++o2) {\n                    var a3 = e3[o2], u3 = { value: S(a3), primKey: f2[s2 + o2] };\n                    false !== y2.call(u3, u3.value, u3) && (null == u3.value ? i2.push(f2[s2 + o2]) : m2 || 0 === st(b2(a3), b2(u3.value)) ? (t3.push(u3.value), m2 && r2.push(f2[s2 + o2])) : (i2.push(f2[s2 + o2]), n3.push(u3.value)));\n                  }\n                  return Promise.resolve(0 < n3.length && v2.mutate({ trans: p2, type: "add", values: n3 }).then(function(e4) {\n                    for (var t4 in e4.failures) i2.splice(parseInt(t4), 1);\n                    w2(n3.length, e4);\n                  })).then(function() {\n                    return (0 < t3.length || d2 && "object" == typeof x2) && v2.mutate({ trans: p2, type: "put", keys: r2, values: t3, criteria: d2, changeSpec: "function" != typeof x2 && x2, isAdditionalChunk: 0 < s2 }).then(function(e4) {\n                      return w2(t3.length, e4);\n                    });\n                  }).then(function() {\n                    return (0 < i2.length || d2 && _2) && v2.mutate({ trans: p2, type: "delete", keys: i2, criteria: d2, isAdditionalChunk: 0 < s2 }).then(function(e4) {\n                      return ft(k2.table, i2, e4);\n                    }).then(function(e4) {\n                      return w2(i2.length, e4);\n                    });\n                  }).then(function() {\n                    return f2.length > s2 + c2 && h2(s2 + g2);\n                  });\n                });\n              }\n              var d2 = gt(k2) && k2.limit === 1 / 0 && ("function" != typeof x2 || _2) && { index: k2.index, range: k2.range };\n              return h2(0).then(function() {\n                if (0 < a2.length) throw new U("Error modifying one or more objects", a2, u2, t2);\n                return f2.length;\n              });\n            });\n          });\n        }, Et.prototype.delete = function() {\n          var i2 = this._ctx, n2 = i2.range;\n          return !gt(i2) || i2.table.schema.yProps || !i2.isPrimKey && 3 !== n2.type ? this.modify(St) : this._write(function(e2) {\n            var t2 = i2.table.core.schema.primaryKey, r2 = n2;\n            return i2.table.core.count({ trans: e2, query: { index: t2, range: r2 } }).then(function(n3) {\n              return i2.table.core.mutate({ trans: e2, type: "deleteRange", range: r2 }).then(function(e3) {\n                var t3 = e3.failures, e3 = e3.numFailures;\n                if (e3) throw new U("Could not delete some values", Object.keys(t3).map(function(e4) {\n                  return t3[e4];\n                }), n3 - e3);\n                return n3 - e3;\n              });\n            });\n          });\n        }, Et);\n        function Et() {\n        }\n        var St = function(e2, t2) {\n          return t2.value = null;\n        };\n        function jt(e2, t2) {\n          return e2 < t2 ? -1 : e2 === t2 ? 0 : 1;\n        }\n        function At(e2, t2) {\n          return t2 < e2 ? -1 : e2 === t2 ? 0 : 1;\n        }\n        function Ct(e2, t2, n2) {\n          e2 = e2 instanceof Bt ? new e2.Collection(e2) : e2;\n          return e2._ctx.error = new (n2 || TypeError)(t2), e2;\n        }\n        function Tt(e2) {\n          return new e2.Collection(e2, function() {\n            return Dt("");\n          }).limit(0);\n        }\n        function It(e2, s2, n2, r2) {\n          var i2, c2, l2, f2, h2, d2, p2, y2 = n2.length;\n          if (!n2.every(function(e3) {\n            return "string" == typeof e3;\n          })) return Ct(e2, Ze);\n          function t2(e3) {\n            i2 = "next" === e3 ? function(e4) {\n              return e4.toUpperCase();\n            } : function(e4) {\n              return e4.toLowerCase();\n            }, c2 = "next" === e3 ? function(e4) {\n              return e4.toLowerCase();\n            } : function(e4) {\n              return e4.toUpperCase();\n            }, l2 = "next" === e3 ? jt : At;\n            var t3 = n2.map(function(e4) {\n              return { lower: c2(e4), upper: i2(e4) };\n            }).sort(function(e4, t4) {\n              return l2(e4.lower, t4.lower);\n            });\n            f2 = t3.map(function(e4) {\n              return e4.upper;\n            }), h2 = t3.map(function(e4) {\n              return e4.lower;\n            }), p2 = "next" === (d2 = e3) ? "" : r2;\n          }\n          t2("next");\n          e2 = new e2.Collection(e2, function() {\n            return qt(f2[0], h2[y2 - 1] + r2);\n          });\n          e2._ondirectionchange = function(e3) {\n            t2(e3);\n          };\n          var v2 = 0;\n          return e2._addAlgorithm(function(e3, t3, n3) {\n            var r3 = e3.key;\n            if ("string" != typeof r3) return false;\n            var i3 = c2(r3);\n            if (s2(i3, h2, v2)) return true;\n            for (var o2 = null, a2 = v2; a2 < y2; ++a2) {\n              var u2 = (function(e4, t4, n4, r4, i4, o3) {\n                for (var a3 = Math.min(e4.length, r4.length), u3 = -1, s3 = 0; s3 < a3; ++s3) {\n                  var c3 = t4[s3];\n                  if (c3 !== r4[s3]) return i4(e4[s3], n4[s3]) < 0 ? e4.substr(0, s3) + n4[s3] + n4.substr(s3 + 1) : i4(e4[s3], r4[s3]) < 0 ? e4.substr(0, s3) + r4[s3] + n4.substr(s3 + 1) : 0 <= u3 ? e4.substr(0, u3) + t4[u3] + n4.substr(u3 + 1) : null;\n                  i4(e4[s3], c3) < 0 && (u3 = s3);\n                }\n                return a3 < r4.length && "next" === o3 ? e4 + n4.substr(e4.length) : a3 < e4.length && "prev" === o3 ? e4.substr(0, n4.length) : u3 < 0 ? null : e4.substr(0, u3) + r4[u3] + n4.substr(u3 + 1);\n              })(r3, i3, f2[a2], h2[a2], l2, d2);\n              null === u2 && null === o2 ? v2 = a2 + 1 : (null === o2 || 0 < l2(o2, u2)) && (o2 = u2);\n            }\n            return t3(null !== o2 ? function() {\n              e3.continue(o2 + p2);\n            } : n3), false;\n          }), e2;\n        }\n        function qt(e2, t2, n2, r2) {\n          return { type: 2, lower: e2, upper: t2, lowerOpen: n2, upperOpen: r2 };\n        }\n        function Dt(e2) {\n          return { type: 1, lower: e2, upper: e2 };\n        }\n        var Bt = (Object.defineProperty(Rt.prototype, "Collection", { get: function() {\n          return this._ctx.table.db.Collection;\n        }, enumerable: false, configurable: true }), Rt.prototype.between = function(e2, t2, n2, r2) {\n          n2 = false !== n2, r2 = true === r2;\n          try {\n            return 0 < this._cmp(e2, t2) || 0 === this._cmp(e2, t2) && (n2 || r2) && (!n2 || !r2) ? Tt(this) : new this.Collection(this, function() {\n              return qt(e2, t2, !n2, !r2);\n            });\n          } catch (e3) {\n            return Ct(this, Je);\n          }\n        }, Rt.prototype.equals = function(e2) {\n          return null == e2 ? Ct(this, Je) : new this.Collection(this, function() {\n            return Dt(e2);\n          });\n        }, Rt.prototype.above = function(e2) {\n          return null == e2 ? Ct(this, Je) : new this.Collection(this, function() {\n            return qt(e2, void 0, true);\n          });\n        }, Rt.prototype.aboveOrEqual = function(e2) {\n          return null == e2 ? Ct(this, Je) : new this.Collection(this, function() {\n            return qt(e2, void 0, false);\n          });\n        }, Rt.prototype.below = function(e2) {\n          return null == e2 ? Ct(this, Je) : new this.Collection(this, function() {\n            return qt(void 0, e2, false, true);\n          });\n        }, Rt.prototype.belowOrEqual = function(e2) {\n          return null == e2 ? Ct(this, Je) : new this.Collection(this, function() {\n            return qt(void 0, e2);\n          });\n        }, Rt.prototype.startsWith = function(e2) {\n          return "string" != typeof e2 ? Ct(this, Ze) : this.between(e2, e2 + He, true, true);\n        }, Rt.prototype.startsWithIgnoreCase = function(e2) {\n          return "" === e2 ? this.startsWith(e2) : It(this, function(e3, t2) {\n            return 0 === e3.indexOf(t2[0]);\n          }, [e2], He);\n        }, Rt.prototype.equalsIgnoreCase = function(e2) {\n          return It(this, function(e3, t2) {\n            return e3 === t2[0];\n          }, [e2], "");\n        }, Rt.prototype.anyOfIgnoreCase = function() {\n          var e2 = D.apply(q, arguments);\n          return 0 === e2.length ? Tt(this) : It(this, function(e3, t2) {\n            return -1 !== t2.indexOf(e3);\n          }, e2, "");\n        }, Rt.prototype.startsWithAnyOfIgnoreCase = function() {\n          var e2 = D.apply(q, arguments);\n          return 0 === e2.length ? Tt(this) : It(this, function(t2, e3) {\n            return e3.some(function(e4) {\n              return 0 === t2.indexOf(e4);\n            });\n          }, e2, He);\n        }, Rt.prototype.anyOf = function() {\n          var t2 = this, i2 = D.apply(q, arguments), o2 = this._cmp;\n          try {\n            i2.sort(o2);\n          } catch (e3) {\n            return Ct(this, Je);\n          }\n          if (0 === i2.length) return Tt(this);\n          var e2 = new this.Collection(this, function() {\n            return qt(i2[0], i2[i2.length - 1]);\n          });\n          e2._ondirectionchange = function(e3) {\n            o2 = "next" === e3 ? t2._ascending : t2._descending, i2.sort(o2);\n          };\n          var a2 = 0;\n          return e2._addAlgorithm(function(e3, t3, n2) {\n            for (var r2 = e3.key; 0 < o2(r2, i2[a2]); ) if (++a2 === i2.length) return t3(n2), false;\n            return 0 === o2(r2, i2[a2]) || (t3(function() {\n              e3.continue(i2[a2]);\n            }), false);\n          }), e2;\n        }, Rt.prototype.notEqual = function(e2) {\n          return this.inAnyRange([[-1 / 0, e2], [e2, this.db._maxKey]], { includeLowers: false, includeUppers: false });\n        }, Rt.prototype.noneOf = function() {\n          var e2 = D.apply(q, arguments);\n          if (0 === e2.length) return new this.Collection(this);\n          try {\n            e2.sort(this._ascending);\n          } catch (e3) {\n            return Ct(this, Je);\n          }\n          var t2 = e2.reduce(function(e3, t3) {\n            return e3 ? e3.concat([[e3[e3.length - 1][1], t3]]) : [[-1 / 0, t3]];\n          }, null);\n          return t2.push([e2[e2.length - 1], this.db._maxKey]), this.inAnyRange(t2, { includeLowers: false, includeUppers: false });\n        }, Rt.prototype.inAnyRange = function(e2, t2) {\n          var o2 = this, a2 = this._cmp, u2 = this._ascending, n2 = this._descending, s2 = this._min, c2 = this._max;\n          if (0 === e2.length) return Tt(this);\n          if (!e2.every(function(e3) {\n            return void 0 !== e3[0] && void 0 !== e3[1] && u2(e3[0], e3[1]) <= 0;\n          })) return Ct(this, "First argument to inAnyRange() must be an Array of two-value Arrays [lower,upper] where upper must not be lower than lower", Y.InvalidArgument);\n          var r2 = !t2 || false !== t2.includeLowers, i2 = t2 && true === t2.includeUppers;\n          var l2, f2 = u2;\n          function h2(e3, t3) {\n            return f2(e3[0], t3[0]);\n          }\n          try {\n            (l2 = e2.reduce(function(e3, t3) {\n              for (var n3 = 0, r3 = e3.length; n3 < r3; ++n3) {\n                var i3 = e3[n3];\n                if (a2(t3[0], i3[1]) < 0 && 0 < a2(t3[1], i3[0])) {\n                  i3[0] = s2(i3[0], t3[0]), i3[1] = c2(i3[1], t3[1]);\n                  break;\n                }\n              }\n              return n3 === r3 && e3.push(t3), e3;\n            }, [])).sort(h2);\n          } catch (e3) {\n            return Ct(this, Je);\n          }\n          var d2 = 0, p2 = i2 ? function(e3) {\n            return 0 < u2(e3, l2[d2][1]);\n          } : function(e3) {\n            return 0 <= u2(e3, l2[d2][1]);\n          }, y2 = r2 ? function(e3) {\n            return 0 < n2(e3, l2[d2][0]);\n          } : function(e3) {\n            return 0 <= n2(e3, l2[d2][0]);\n          };\n          var v2 = p2, e2 = new this.Collection(this, function() {\n            return qt(l2[0][0], l2[l2.length - 1][1], !r2, !i2);\n          });\n          return e2._ondirectionchange = function(e3) {\n            f2 = "next" === e3 ? (v2 = p2, u2) : (v2 = y2, n2), l2.sort(h2);\n          }, e2._addAlgorithm(function(e3, t3, n3) {\n            for (var r3, i3 = e3.key; v2(i3); ) if (++d2 === l2.length) return t3(n3), false;\n            return !p2(r3 = i3) && !y2(r3) || (0 === o2._cmp(i3, l2[d2][1]) || 0 === o2._cmp(i3, l2[d2][0]) || t3(function() {\n              f2 === u2 ? e3.continue(l2[d2][0]) : e3.continue(l2[d2][1]);\n            }), false);\n          }), e2;\n        }, Rt.prototype.startsWithAnyOf = function() {\n          var e2 = D.apply(q, arguments);\n          return e2.every(function(e3) {\n            return "string" == typeof e3;\n          }) ? 0 === e2.length ? Tt(this) : this.inAnyRange(e2.map(function(e3) {\n            return [e3, e3 + He];\n          })) : Ct(this, "startsWithAnyOf() only works with strings");\n        }, Rt);\n        function Rt() {\n        }\n        function Ft(t2) {\n          return Ie(function(e2) {\n            return Mt(e2), t2(e2.target.error), false;\n          });\n        }\n        function Mt(e2) {\n          e2.stopPropagation && e2.stopPropagation(), e2.preventDefault && e2.preventDefault();\n        }\n        var Nt = "storagemutated", Lt = "x-storagemutated-1", Ut = mt(null, Nt), Vt = (zt.prototype._lock = function() {\n          return y(!me.global), ++this._reculock, 1 !== this._reculock || me.global || (me.lockOwnerFor = this), this;\n        }, zt.prototype._unlock = function() {\n          if (y(!me.global), 0 == --this._reculock) for (me.global || (me.lockOwnerFor = null); 0 < this._blockedFuncs.length && !this._locked(); ) {\n            var e2 = this._blockedFuncs.shift();\n            try {\n              $e(e2[1], e2[0]);\n            } catch (e3) {\n            }\n          }\n          return this;\n        }, zt.prototype._locked = function() {\n          return this._reculock && me.lockOwnerFor !== this;\n        }, zt.prototype.create = function(t2) {\n          var n2 = this;\n          if (!this.mode) return this;\n          var e2 = this.db.idbdb, r2 = this.db._state.dbOpenError;\n          if (y(!this.idbtrans), !t2 && !e2) switch (r2 && r2.name) {\n            case "DatabaseClosedError":\n              throw new Y.DatabaseClosed(r2);\n            case "MissingAPIError":\n              throw new Y.MissingAPI(r2.message, r2);\n            default:\n              throw new Y.OpenFailed(r2);\n          }\n          if (!this.active) throw new Y.TransactionInactive();\n          return y(null === this._completion._state), (t2 = this.idbtrans = t2 || (this.db.core || e2).transaction(this.storeNames, this.mode, { durability: this.chromeTransactionDurability })).onerror = Ie(function(e3) {\n            Mt(e3), n2._reject(t2.error);\n          }), t2.onabort = Ie(function(e3) {\n            Mt(e3), n2.active && n2._reject(new Y.Abort(t2.error)), n2.active = false, n2.on("abort").fire(e3);\n          }), t2.oncomplete = Ie(function() {\n            n2.active = false, n2._resolve(), "mutatedParts" in t2 && Ut.storagemutated.fire(t2.mutatedParts);\n          }), this;\n        }, zt.prototype._promise = function(n2, r2, i2) {\n          var o2 = this;\n          if ("readwrite" === n2 && "readwrite" !== this.mode) return Xe(new Y.ReadOnly("Transaction is readonly"));\n          if (!this.active) return Xe(new Y.TransactionInactive());\n          if (this._locked()) return new _e(function(e3, t2) {\n            o2._blockedFuncs.push([function() {\n              o2._promise(n2, r2, i2).then(e3, t2);\n            }, me]);\n          });\n          if (i2) return Ne(function() {\n            var e3 = new _e(function(e4, t2) {\n              o2._lock();\n              var n3 = r2(e4, t2, o2);\n              n3 && n3.then && n3.then(e4, t2);\n            });\n            return e3.finally(function() {\n              return o2._unlock();\n            }), e3._lib = true, e3;\n          });\n          var e2 = new _e(function(e3, t2) {\n            var n3 = r2(e3, t2, o2);\n            n3 && n3.then && n3.then(e3, t2);\n          });\n          return e2._lib = true, e2;\n        }, zt.prototype._root = function() {\n          return this.parent ? this.parent._root() : this;\n        }, zt.prototype.waitFor = function(e2) {\n          var t2, r2 = this._root(), i2 = _e.resolve(e2);\n          r2._waitingFor ? r2._waitingFor = r2._waitingFor.then(function() {\n            return i2;\n          }) : (r2._waitingFor = i2, r2._waitingQueue = [], t2 = r2.idbtrans.objectStore(r2.storeNames[0]), (function e3() {\n            for (++r2._spinCount; r2._waitingQueue.length; ) r2._waitingQueue.shift()();\n            r2._waitingFor && (t2.get(-1 / 0).onsuccess = e3);\n          })());\n          var o2 = r2._waitingFor;\n          return new _e(function(t3, n2) {\n            i2.then(function(e3) {\n              return r2._waitingQueue.push(Ie(t3.bind(null, e3)));\n            }, function(e3) {\n              return r2._waitingQueue.push(Ie(n2.bind(null, e3)));\n            }).finally(function() {\n              r2._waitingFor === o2 && (r2._waitingFor = null);\n            });\n          });\n        }, zt.prototype.abort = function() {\n          this.active && (this.active = false, this.idbtrans && this.idbtrans.abort(), this._reject(new Y.Abort()));\n        }, zt.prototype.table = function(e2) {\n          var t2 = this._memoizedTables || (this._memoizedTables = {});\n          if (m(t2, e2)) return t2[e2];\n          var n2 = this.schema[e2];\n          if (!n2) throw new Y.NotFound("Table " + e2 + " not part of transaction");\n          n2 = new this.db.Table(e2, n2, this);\n          return n2.core = this.db.core.table(e2), t2[e2] = n2;\n        }, zt);\n        function zt() {\n        }\n        function Wt(e2, t2, n2, r2, i2, o2, a2, u2) {\n          return { name: e2, keyPath: t2, unique: n2, multi: r2, auto: i2, compound: o2, src: (n2 && !a2 ? "&" : "") + (r2 ? "*" : "") + (i2 ? "++" : "") + Yt(t2), type: u2 };\n        }\n        function Yt(e2) {\n          return "string" == typeof e2 ? e2 : e2 ? "[" + [].join.call(e2, "+") + "]" : "";\n        }\n        function $t(e2, t2, n2) {\n          return { name: e2, primKey: t2, indexes: n2, mappedClass: null, idxByName: (r2 = function(e3) {\n            return [e3.name, e3];\n          }, n2.reduce(function(e3, t3, n3) {\n            n3 = r2(t3, n3);\n            return n3 && (e3[n3[0]] = n3[1]), e3;\n          }, {})) };\n          var r2;\n        }\n        var Qt = function(e2) {\n          try {\n            return e2.only([[]]), Qt = function() {\n              return [[]];\n            }, [[]];\n          } catch (e3) {\n            return Qt = function() {\n              return He;\n            }, He;\n          }\n        };\n        function Gt(t2) {\n          return null == t2 ? function() {\n          } : "string" == typeof t2 ? 1 === (n2 = t2).split(".").length ? function(e2) {\n            return e2[n2];\n          } : function(e2) {\n            return g(e2, n2);\n          } : function(e2) {\n            return g(e2, t2);\n          };\n          var n2;\n        }\n        function Xt(e2) {\n          return [].slice.call(e2);\n        }\n        var Ht = 0;\n        function Jt(e2) {\n          return null == e2 ? ":id" : "string" == typeof e2 ? e2 : "[".concat(e2.join("+"), "]");\n        }\n        function Zt(e2, i2, t2) {\n          function _2(e3) {\n            if (3 === e3.type) return null;\n            if (4 === e3.type) throw new Error("Cannot convert never type to IDBKeyRange");\n            var t3 = e3.lower, n3 = e3.upper, r3 = e3.lowerOpen, e3 = e3.upperOpen;\n            return void 0 === t3 ? void 0 === n3 ? null : i2.upperBound(n3, !!e3) : void 0 === n3 ? i2.lowerBound(t3, !!r3) : i2.bound(t3, n3, !!r3, !!e3);\n          }\n          function n2(e3) {\n            var h2, w2 = e3.name;\n            return { name: w2, schema: e3, mutate: function(e4) {\n              var y2 = e4.trans, v2 = e4.type, m2 = e4.keys, b2 = e4.values, g2 = e4.range;\n              return new Promise(function(t3, e5) {\n                t3 = Ie(t3);\n                var n3 = y2.objectStore(w2), r3 = null == n3.keyPath, i3 = "put" === v2 || "add" === v2;\n                if (!i3 && "delete" !== v2 && "deleteRange" !== v2) throw new Error("Invalid operation type: " + v2);\n                var o3, a3 = (m2 || b2 || { length: 1 }).length;\n                if (m2 && b2 && m2.length !== b2.length) throw new Error("Given keys array must have same length as given values array.");\n                if (0 === a3) return t3({ numFailures: 0, failures: {}, results: [], lastResult: void 0 });\n                function u3(e6) {\n                  ++l2, Mt(e6);\n                }\n                var s3 = [], c3 = [], l2 = 0;\n                if ("deleteRange" === v2) {\n                  if (4 === g2.type) return t3({ numFailures: l2, failures: c3, results: [], lastResult: void 0 });\n                  3 === g2.type ? s3.push(o3 = n3.clear()) : s3.push(o3 = n3.delete(_2(g2)));\n                } else {\n                  var r3 = i3 ? r3 ? [b2, m2] : [b2, null] : [m2, null], f2 = r3[0], h3 = r3[1];\n                  if (i3) for (var d2 = 0; d2 < a3; ++d2) s3.push(o3 = h3 && void 0 !== h3[d2] ? n3[v2](f2[d2], h3[d2]) : n3[v2](f2[d2])), o3.onerror = u3;\n                  else for (d2 = 0; d2 < a3; ++d2) s3.push(o3 = n3[v2](f2[d2])), o3.onerror = u3;\n                }\n                function p2(e6) {\n                  e6 = e6.target.result, s3.forEach(function(e7, t4) {\n                    return null != e7.error && (c3[t4] = e7.error);\n                  }), t3({ numFailures: l2, failures: c3, results: "delete" === v2 ? m2 : s3.map(function(e7) {\n                    return e7.result;\n                  }), lastResult: e6 });\n                }\n                o3.onerror = function(e6) {\n                  u3(e6), p2(e6);\n                }, o3.onsuccess = p2;\n              });\n            }, getMany: function(e4) {\n              var f2 = e4.trans, h3 = e4.keys;\n              return new Promise(function(t3, e5) {\n                t3 = Ie(t3);\n                for (var n3, r3 = f2.objectStore(w2), i3 = h3.length, o3 = new Array(i3), a3 = 0, u3 = 0, s3 = function(e6) {\n                  e6 = e6.target;\n                  o3[e6._pos] = e6.result, ++u3 === a3 && t3(o3);\n                }, c3 = Ft(e5), l2 = 0; l2 < i3; ++l2) null != h3[l2] && ((n3 = r3.get(h3[l2]))._pos = l2, n3.onsuccess = s3, n3.onerror = c3, ++a3);\n                0 === a3 && t3(o3);\n              });\n            }, get: function(e4) {\n              var r3 = e4.trans, i3 = e4.key;\n              return new Promise(function(t3, e5) {\n                t3 = Ie(t3);\n                var n3 = r3.objectStore(w2).get(i3);\n                n3.onsuccess = function(e6) {\n                  return t3(e6.target.result);\n                }, n3.onerror = Ft(e5);\n              });\n            }, query: (h2 = s2, function(f2) {\n              return new Promise(function(n3, e4) {\n                n3 = Ie(n3);\n                var r3, i3, o3, t3 = f2.trans, a3 = f2.values, u3 = f2.limit, s3 = f2.query, c3 = u3 === 1 / 0 ? void 0 : u3, l2 = s3.index, s3 = s3.range, t3 = t3.objectStore(w2), l2 = l2.isPrimaryKey ? t3 : t3.index(l2.name), s3 = _2(s3);\n                if (0 === u3) return n3({ result: [] });\n                h2 ? ((c3 = a3 ? l2.getAll(s3, c3) : l2.getAllKeys(s3, c3)).onsuccess = function(e5) {\n                  return n3({ result: e5.target.result });\n                }, c3.onerror = Ft(e4)) : (r3 = 0, i3 = !a3 && "openKeyCursor" in l2 ? l2.openKeyCursor(s3) : l2.openCursor(s3), o3 = [], i3.onsuccess = function(e5) {\n                  var t4 = i3.result;\n                  return t4 ? (o3.push(a3 ? t4.value : t4.primaryKey), ++r3 === u3 ? n3({ result: o3 }) : void t4.continue()) : n3({ result: o3 });\n                }, i3.onerror = Ft(e4));\n              });\n            }), openCursor: function(e4) {\n              var c3 = e4.trans, o3 = e4.values, a3 = e4.query, u3 = e4.reverse, l2 = e4.unique;\n              return new Promise(function(t3, n3) {\n                t3 = Ie(t3);\n                var e5 = a3.index, r3 = a3.range, i3 = c3.objectStore(w2), i3 = e5.isPrimaryKey ? i3 : i3.index(e5.name), e5 = u3 ? l2 ? "prevunique" : "prev" : l2 ? "nextunique" : "next", s3 = !o3 && "openKeyCursor" in i3 ? i3.openKeyCursor(_2(r3), e5) : i3.openCursor(_2(r3), e5);\n                s3.onerror = Ft(n3), s3.onsuccess = Ie(function(e6) {\n                  var r4, i4, o4, a4, u4 = s3.result;\n                  u4 ? (u4.___id = ++Ht, u4.done = false, r4 = u4.continue.bind(u4), i4 = (i4 = u4.continuePrimaryKey) && i4.bind(u4), o4 = u4.advance.bind(u4), a4 = function() {\n                    throw new Error("Cursor not stopped");\n                  }, u4.trans = c3, u4.stop = u4.continue = u4.continuePrimaryKey = u4.advance = function() {\n                    throw new Error("Cursor not started");\n                  }, u4.fail = Ie(n3), u4.next = function() {\n                    var e7 = this, t4 = 1;\n                    return this.start(function() {\n                      return t4-- ? e7.continue() : e7.stop();\n                    }).then(function() {\n                      return e7;\n                    });\n                  }, u4.start = function(e7) {\n                    function t4() {\n                      if (s3.result) try {\n                        e7();\n                      } catch (e8) {\n                        u4.fail(e8);\n                      }\n                      else u4.done = true, u4.start = function() {\n                        throw new Error("Cursor behind last entry");\n                      }, u4.stop();\n                    }\n                    var n4 = new Promise(function(t5, e8) {\n                      t5 = Ie(t5), s3.onerror = Ft(e8), u4.fail = e8, u4.stop = function(e9) {\n                        u4.stop = u4.continue = u4.continuePrimaryKey = u4.advance = a4, t5(e9);\n                      };\n                    });\n                    return s3.onsuccess = Ie(function(e8) {\n                      s3.onsuccess = t4, t4();\n                    }), u4.continue = r4, u4.continuePrimaryKey = i4, u4.advance = o4, t4(), n4;\n                  }, t3(u4)) : t3(null);\n                }, n3);\n              });\n            }, count: function(e4) {\n              var t3 = e4.query, i3 = e4.trans, o3 = t3.index, a3 = t3.range;\n              return new Promise(function(t4, e5) {\n                var n3 = i3.objectStore(w2), r3 = o3.isPrimaryKey ? n3 : n3.index(o3.name), n3 = _2(a3), r3 = n3 ? r3.count(n3) : r3.count();\n                r3.onsuccess = Ie(function(e6) {\n                  return t4(e6.target.result);\n                }), r3.onerror = Ft(e5);\n              });\n            } };\n          }\n          var r2, o2, a2, u2 = (o2 = t2, a2 = Xt((r2 = e2).objectStoreNames), { schema: { name: r2.name, tables: a2.map(function(e3) {\n            return o2.objectStore(e3);\n          }).map(function(t3) {\n            var e3 = t3.keyPath, n3 = t3.autoIncrement, r3 = x(e3), i3 = {}, n3 = { name: t3.name, primaryKey: { name: null, isPrimaryKey: true, outbound: null == e3, compound: r3, keyPath: e3, autoIncrement: n3, unique: true, extractKey: Gt(e3) }, indexes: Xt(t3.indexNames).map(function(e4) {\n              return t3.index(e4);\n            }).map(function(e4) {\n              var t4 = e4.name, n4 = e4.unique, r4 = e4.multiEntry, e4 = e4.keyPath, r4 = { name: t4, compound: x(e4), keyPath: e4, unique: n4, multiEntry: r4, extractKey: Gt(e4) };\n              return i3[Jt(e4)] = r4;\n            }), getIndexByKeyPath: function(e4) {\n              return i3[Jt(e4)];\n            } };\n            return i3[":id"] = n3.primaryKey, null != e3 && (i3[Jt(e3)] = n3.primaryKey), n3;\n          }) }, hasGetAll: 0 < a2.length && "getAll" in o2.objectStore(a2[0]) && !("undefined" != typeof navigator && /Safari/.test(navigator.userAgent) && !/(Chrome\\/|Edge\\/)/.test(navigator.userAgent) && [].concat(navigator.userAgent.match(/Safari\\/(\\d*)/))[1] < 604) }), t2 = u2.schema, s2 = u2.hasGetAll, u2 = t2.tables.map(n2), c2 = {};\n          return u2.forEach(function(e3) {\n            return c2[e3.name] = e3;\n          }), { stack: "dbcore", transaction: e2.transaction.bind(e2), table: function(e3) {\n            if (!c2[e3]) throw new Error("Table \'".concat(e3, "\' not found"));\n            return c2[e3];\n          }, MIN_KEY: -1 / 0, MAX_KEY: Qt(i2), schema: t2 };\n        }\n        function en(e2, t2, n2, r2) {\n          var i2 = n2.IDBKeyRange;\n          return n2.indexedDB, { dbcore: (r2 = Zt(t2, i2, r2), e2.dbcore.reduce(function(e3, t3) {\n            t3 = t3.create;\n            return _(_({}, e3), t3(e3));\n          }, r2)) };\n        }\n        function tn(n2, e2) {\n          var t2 = e2.db, e2 = en(n2._middlewares, t2, n2._deps, e2);\n          n2.core = e2.dbcore, n2.tables.forEach(function(e3) {\n            var t3 = e3.name;\n            n2.core.schema.tables.some(function(e4) {\n              return e4.name === t3;\n            }) && (e3.core = n2.core.table(t3), n2[t3] instanceof n2.Table && (n2[t3].core = e3.core));\n          });\n        }\n        function nn(i2, e2, t2, o2) {\n          t2.forEach(function(n2) {\n            var r2 = o2[n2];\n            e2.forEach(function(e3) {\n              var t3 = (function e4(t4, n3) {\n                return h(t4, n3) || (t4 = c(t4)) && e4(t4, n3);\n              })(e3, n2);\n              (!t3 || "value" in t3 && void 0 === t3.value) && (e3 === i2.Transaction.prototype || e3 instanceof i2.Transaction ? l(e3, n2, { get: function() {\n                return this.table(n2);\n              }, set: function(e4) {\n                u(this, n2, { value: e4, writable: true, configurable: true, enumerable: true });\n              } }) : e3[n2] = new i2.Table(n2, r2));\n            });\n          });\n        }\n        function rn(n2, e2) {\n          e2.forEach(function(e3) {\n            for (var t2 in e3) e3[t2] instanceof n2.Table && delete e3[t2];\n          });\n        }\n        function on(e2, t2) {\n          return e2._cfg.version - t2._cfg.version;\n        }\n        function an(n2, r2, i2, e2) {\n          var o2 = n2._dbSchema;\n          i2.objectStoreNames.contains("$meta") && !o2.$meta && (o2.$meta = $t("$meta", pn("")[0], []), n2._storeNames.push("$meta"));\n          var a2 = n2._createTransaction("readwrite", n2._storeNames, o2);\n          a2.create(i2), a2._completion.catch(e2);\n          var u2 = a2._reject.bind(a2), s2 = me.transless || me;\n          Ne(function() {\n            return me.trans = a2, me.transless = s2, 0 !== r2 ? (tn(n2, i2), t2 = r2, ((e3 = a2).storeNames.includes("$meta") ? e3.table("$meta").get("version").then(function(e4) {\n              return null != e4 ? e4 : t2;\n            }) : _e.resolve(t2)).then(function(e4) {\n              return c2 = e4, l2 = a2, f2 = i2, t3 = [], e4 = (s3 = n2)._versions, h2 = s3._dbSchema = hn(0, s3.idbdb, f2), 0 !== (e4 = e4.filter(function(e5) {\n                return e5._cfg.version >= c2;\n              })).length ? (e4.forEach(function(u3) {\n                t3.push(function() {\n                  var t4 = h2, e5 = u3._cfg.dbschema;\n                  dn(s3, t4, f2), dn(s3, e5, f2), h2 = s3._dbSchema = e5;\n                  var n3 = sn(t4, e5);\n                  n3.add.forEach(function(e6) {\n                    cn(f2, e6[0], e6[1].primKey, e6[1].indexes);\n                  }), n3.change.forEach(function(e6) {\n                    if (e6.recreate) throw new Y.Upgrade("Not yet support for changing primary key");\n                    var t5 = f2.objectStore(e6.name);\n                    e6.add.forEach(function(e7) {\n                      return fn(t5, e7);\n                    }), e6.change.forEach(function(e7) {\n                      t5.deleteIndex(e7.name), fn(t5, e7);\n                    }), e6.del.forEach(function(e7) {\n                      return t5.deleteIndex(e7);\n                    });\n                  });\n                  var r3 = u3._cfg.contentUpgrade;\n                  if (r3 && u3._cfg.version > c2) {\n                    tn(s3, f2), l2._memoizedTables = {};\n                    var i3 = k(e5);\n                    n3.del.forEach(function(e6) {\n                      i3[e6] = t4[e6];\n                    }), rn(s3, [s3.Transaction.prototype]), nn(s3, [s3.Transaction.prototype], O(i3), i3), l2.schema = i3;\n                    var o3, a3 = B(r3);\n                    a3 && Le();\n                    n3 = _e.follow(function() {\n                      var e6;\n                      (o3 = r3(l2)) && a3 && (e6 = Ue.bind(null, null), o3.then(e6, e6));\n                    });\n                    return o3 && "function" == typeof o3.then ? _e.resolve(o3) : n3.then(function() {\n                      return o3;\n                    });\n                  }\n                }), t3.push(function(e5) {\n                  var t4, n3, r3 = u3._cfg.dbschema;\n                  t4 = r3, n3 = e5, [].slice.call(n3.db.objectStoreNames).forEach(function(e6) {\n                    return null == t4[e6] && n3.db.deleteObjectStore(e6);\n                  }), rn(s3, [s3.Transaction.prototype]), nn(s3, [s3.Transaction.prototype], s3._storeNames, s3._dbSchema), l2.schema = s3._dbSchema;\n                }), t3.push(function(e5) {\n                  s3.idbdb.objectStoreNames.contains("$meta") && (Math.ceil(s3.idbdb.version / 10) === u3._cfg.version ? (s3.idbdb.deleteObjectStore("$meta"), delete s3._dbSchema.$meta, s3._storeNames = s3._storeNames.filter(function(e6) {\n                    return "$meta" !== e6;\n                  })) : e5.objectStore("$meta").put(u3._cfg.version, "version"));\n                });\n              }), (function e5() {\n                return t3.length ? _e.resolve(t3.shift()(l2.idbtrans)).then(e5) : _e.resolve();\n              })().then(function() {\n                ln(h2, f2);\n              })) : _e.resolve();\n              var s3, c2, l2, f2, t3, h2;\n            }).catch(u2)) : (O(o2).forEach(function(e4) {\n              cn(i2, e4, o2[e4].primKey, o2[e4].indexes);\n            }), tn(n2, i2), void _e.follow(function() {\n              return n2.on.populate.fire(a2);\n            }).catch(u2));\n            var e3, t2;\n          });\n        }\n        function un(e2, r2) {\n          ln(e2._dbSchema, r2), r2.db.version % 10 != 0 || r2.objectStoreNames.contains("$meta") || r2.db.createObjectStore("$meta").add(Math.ceil(r2.db.version / 10 - 1), "version");\n          var t2 = hn(0, e2.idbdb, r2);\n          dn(e2, e2._dbSchema, r2);\n          for (var n2 = 0, i2 = sn(t2, e2._dbSchema).change; n2 < i2.length; n2++) {\n            var o2 = (function(t3) {\n              if (t3.change.length || t3.recreate) return console.warn("Unable to patch indexes of table ".concat(t3.name, " because it has changes on the type of index or primary key.")), { value: void 0 };\n              var n3 = r2.objectStore(t3.name);\n              t3.add.forEach(function(e3) {\n                ie && console.debug("Dexie upgrade patch: Creating missing index ".concat(t3.name, ".").concat(e3.src)), fn(n3, e3);\n              });\n            })(i2[n2]);\n            if ("object" == typeof o2) return o2.value;\n          }\n        }\n        function sn(e2, t2) {\n          var n2, r2 = { del: [], add: [], change: [] };\n          for (n2 in e2) t2[n2] || r2.del.push(n2);\n          for (n2 in t2) {\n            var i2 = e2[n2], o2 = t2[n2];\n            if (i2) {\n              var a2 = { name: n2, def: o2, recreate: false, del: [], add: [], change: [] };\n              if ("" + (i2.primKey.keyPath || "") != "" + (o2.primKey.keyPath || "") || i2.primKey.auto !== o2.primKey.auto) a2.recreate = true, r2.change.push(a2);\n              else {\n                var u2 = i2.idxByName, s2 = o2.idxByName, c2 = void 0;\n                for (c2 in u2) s2[c2] || a2.del.push(c2);\n                for (c2 in s2) {\n                  var l2 = u2[c2], f2 = s2[c2];\n                  l2 ? l2.src !== f2.src && a2.change.push(f2) : a2.add.push(f2);\n                }\n                (0 < a2.del.length || 0 < a2.add.length || 0 < a2.change.length) && r2.change.push(a2);\n              }\n            } else r2.add.push([n2, o2]);\n          }\n          return r2;\n        }\n        function cn(e2, t2, n2, r2) {\n          var i2 = e2.db.createObjectStore(t2, n2.keyPath ? { keyPath: n2.keyPath, autoIncrement: n2.auto } : { autoIncrement: n2.auto });\n          return r2.forEach(function(e3) {\n            return fn(i2, e3);\n          }), i2;\n        }\n        function ln(t2, n2) {\n          O(t2).forEach(function(e2) {\n            n2.db.objectStoreNames.contains(e2) || (ie && console.debug("Dexie: Creating missing table", e2), cn(n2, e2, t2[e2].primKey, t2[e2].indexes));\n          });\n        }\n        function fn(e2, t2) {\n          e2.createIndex(t2.name, t2.keyPath, { unique: t2.unique, multiEntry: t2.multi });\n        }\n        function hn(e2, t2, u2) {\n          var s2 = {};\n          return b(t2.objectStoreNames, 0).forEach(function(e3) {\n            for (var t3 = u2.objectStore(e3), n2 = Wt(Yt(a2 = t3.keyPath), a2 || "", true, false, !!t3.autoIncrement, a2 && "string" != typeof a2, true), r2 = [], i2 = 0; i2 < t3.indexNames.length; ++i2) {\n              var o2 = t3.index(t3.indexNames[i2]), a2 = o2.keyPath, o2 = Wt(o2.name, a2, !!o2.unique, !!o2.multiEntry, false, a2 && "string" != typeof a2, false);\n              r2.push(o2);\n            }\n            s2[e3] = $t(e3, n2, r2);\n          }), s2;\n        }\n        function dn(e2, t2, n2) {\n          for (var r2 = n2.db.objectStoreNames, i2 = 0; i2 < r2.length; ++i2) {\n            var o2 = r2[i2], a2 = n2.objectStore(o2);\n            e2._hasGetAll = "getAll" in a2;\n            for (var u2 = 0; u2 < a2.indexNames.length; ++u2) {\n              var s2 = a2.indexNames[u2], c2 = a2.index(s2).keyPath, l2 = "string" == typeof c2 ? c2 : "[" + b(c2).join("+") + "]";\n              !t2[o2] || (c2 = t2[o2].idxByName[l2]) && (c2.name = s2, delete t2[o2].idxByName[l2], t2[o2].idxByName[s2] = c2);\n            }\n          }\n          "undefined" != typeof navigator && /Safari/.test(navigator.userAgent) && !/(Chrome\\/|Edge\\/)/.test(navigator.userAgent) && f.WorkerGlobalScope && f instanceof f.WorkerGlobalScope && [].concat(navigator.userAgent.match(/Safari\\/(\\d*)/))[1] < 604 && (e2._hasGetAll = false);\n        }\n        function pn(e2) {\n          return e2.split(",").map(function(e3, t2) {\n            var n2 = e3.split(":"), r2 = null === (i2 = n2[1]) || void 0 === i2 ? void 0 : i2.trim(), i2 = (e3 = n2[0].trim()).replace(/([&*]|\\+\\+)/g, ""), n2 = /^\\[/.test(i2) ? i2.match(/^\\[(.*)\\]$/)[1].split("+") : i2;\n            return Wt(i2, n2 || null, /\\&/.test(e3), /\\*/.test(e3), /\\+\\+/.test(e3), x(n2), 0 === t2, r2);\n          });\n        }\n        var yn = (vn.prototype._createTableSchema = $t, vn.prototype._parseIndexSyntax = pn, vn.prototype._parseStoresSpec = function(r2, i2) {\n          var o2 = this;\n          O(r2).forEach(function(e2) {\n            if (null !== r2[e2]) {\n              var t2 = o2._parseIndexSyntax(r2[e2]), n2 = t2.shift();\n              if (!n2) throw new Y.Schema("Invalid schema for table " + e2 + ": " + r2[e2]);\n              if (n2.unique = true, n2.multi) throw new Y.Schema("Primary key cannot be multiEntry*");\n              t2.forEach(function(e3) {\n                if (e3.auto) throw new Y.Schema("Only primary key can be marked as autoIncrement (++)");\n                if (!e3.keyPath) throw new Y.Schema("Index must have a name and cannot be an empty string");\n              });\n              t2 = o2._createTableSchema(e2, n2, t2);\n              i2[e2] = t2;\n            }\n          });\n        }, vn.prototype.stores = function(e2) {\n          var t2 = this.db;\n          this._cfg.storesSource = this._cfg.storesSource ? a(this._cfg.storesSource, e2) : e2;\n          var e2 = t2._versions, n2 = {}, r2 = {};\n          return e2.forEach(function(e3) {\n            a(n2, e3._cfg.storesSource), r2 = e3._cfg.dbschema = {}, e3._parseStoresSpec(n2, r2);\n          }), t2._dbSchema = r2, rn(t2, [t2._allTables, t2, t2.Transaction.prototype]), nn(t2, [t2._allTables, t2, t2.Transaction.prototype, this._cfg.tables], O(r2), r2), t2._storeNames = O(r2), this;\n        }, vn.prototype.upgrade = function(e2) {\n          return this._cfg.contentUpgrade = re(this._cfg.contentUpgrade || G, e2), this;\n        }, vn);\n        function vn() {\n        }\n        function mn(e2, t2) {\n          var n2 = e2._dbNamesDB;\n          return n2 || (n2 = e2._dbNamesDB = new nr(tt, { addons: [], indexedDB: e2, IDBKeyRange: t2 })).version(1).stores({ dbnames: "name" }), n2.table("dbnames");\n        }\n        function bn(e2) {\n          return e2 && "function" == typeof e2.databases;\n        }\n        function gn(e2) {\n          return Ne(function() {\n            return me.letThrough = true, e2();\n          });\n        }\n        function wn(e2) {\n          return !("from" in e2);\n        }\n        var _n = function(e2, t2) {\n          if (!this) {\n            var n2 = new _n();\n            return e2 && "d" in e2 && a(n2, e2), n2;\n          }\n          a(this, arguments.length ? { d: 1, from: e2, to: 1 < arguments.length ? t2 : e2 } : { d: 0 });\n        };\n        function xn(e2, t2, n2) {\n          var r2 = st(t2, n2);\n          if (!isNaN(r2)) {\n            if (0 < r2) throw RangeError();\n            if (wn(e2)) return a(e2, { from: t2, to: n2, d: 1 });\n            var i2 = e2.l, r2 = e2.r;\n            if (st(n2, e2.from) < 0) return i2 ? xn(i2, t2, n2) : e2.l = { from: t2, to: n2, d: 1, l: null, r: null }, Kn(e2);\n            if (0 < st(t2, e2.to)) return r2 ? xn(r2, t2, n2) : e2.r = { from: t2, to: n2, d: 1, l: null, r: null }, Kn(e2);\n            st(t2, e2.from) < 0 && (e2.from = t2, e2.l = null, e2.d = r2 ? r2.d + 1 : 1), 0 < st(n2, e2.to) && (e2.to = n2, e2.r = null, e2.d = e2.l ? e2.l.d + 1 : 1);\n            n2 = !e2.r;\n            i2 && !e2.l && kn(e2, i2), r2 && n2 && kn(e2, r2);\n          }\n        }\n        function kn(e2, t2) {\n          wn(t2) || (function e3(t3, n2) {\n            var r2 = n2.from, i2 = n2.to, o2 = n2.l, n2 = n2.r;\n            xn(t3, r2, i2), o2 && e3(t3, o2), n2 && e3(t3, n2);\n          })(e2, t2);\n        }\n        function On(e2, t2) {\n          var n2 = Pn(t2), r2 = n2.next();\n          if (r2.done) return false;\n          for (var i2 = r2.value, o2 = Pn(e2), a2 = o2.next(i2.from), u2 = a2.value; !r2.done && !a2.done; ) {\n            if (st(u2.from, i2.to) <= 0 && 0 <= st(u2.to, i2.from)) return true;\n            st(i2.from, u2.from) < 0 ? i2 = (r2 = n2.next(u2.from)).value : u2 = (a2 = o2.next(i2.from)).value;\n          }\n          return false;\n        }\n        function Pn(e2) {\n          var n2 = wn(e2) ? null : { s: 0, n: e2 };\n          return { next: function(e3) {\n            for (var t2 = 0 < arguments.length; n2; ) switch (n2.s) {\n              case 0:\n                if (n2.s = 1, t2) for (; n2.n.l && st(e3, n2.n.from) < 0; ) n2 = { up: n2, n: n2.n.l, s: 1 };\n                else for (; n2.n.l; ) n2 = { up: n2, n: n2.n.l, s: 1 };\n              case 1:\n                if (n2.s = 2, !t2 || st(e3, n2.n.to) <= 0) return { value: n2.n, done: false };\n              case 2:\n                if (n2.n.r) {\n                  n2.s = 3, n2 = { up: n2, n: n2.n.r, s: 0 };\n                  continue;\n                }\n              case 3:\n                n2 = n2.up;\n            }\n            return { done: true };\n          } };\n        }\n        function Kn(e2) {\n          var t2, n2, r2 = ((null === (t2 = e2.r) || void 0 === t2 ? void 0 : t2.d) || 0) - ((null === (n2 = e2.l) || void 0 === n2 ? void 0 : n2.d) || 0), i2 = 1 < r2 ? "r" : r2 < -1 ? "l" : "";\n          i2 && (t2 = "r" == i2 ? "l" : "r", n2 = _({}, e2), r2 = e2[i2], e2.from = r2.from, e2.to = r2.to, e2[i2] = r2[i2], n2[i2] = r2[t2], (e2[t2] = n2).d = En(n2)), e2.d = En(e2);\n        }\n        function En(e2) {\n          var t2 = e2.r, e2 = e2.l;\n          return (t2 ? e2 ? Math.max(t2.d, e2.d) : t2.d : e2 ? e2.d : 0) + 1;\n        }\n        function Sn(t2, n2) {\n          return O(n2).forEach(function(e2) {\n            t2[e2] ? kn(t2[e2], n2[e2]) : t2[e2] = (function e3(t3) {\n              var n3, r2, i2 = {};\n              for (n3 in t3) m(t3, n3) && (r2 = t3[n3], i2[n3] = !r2 || "object" != typeof r2 || K.has(r2.constructor) ? r2 : e3(r2));\n              return i2;\n            })(n2[e2]);\n          }), t2;\n        }\n        function jn(t2, n2) {\n          return t2.all || n2.all || Object.keys(t2).some(function(e2) {\n            return n2[e2] && On(n2[e2], t2[e2]);\n          });\n        }\n        r(_n.prototype, ((F = { add: function(e2) {\n          return kn(this, e2), this;\n        }, addKey: function(e2) {\n          return xn(this, e2, e2), this;\n        }, addKeys: function(e2) {\n          var t2 = this;\n          return e2.forEach(function(e3) {\n            return xn(t2, e3, e3);\n          }), this;\n        }, hasKey: function(e2) {\n          var t2 = Pn(this).next(e2).value;\n          return t2 && st(t2.from, e2) <= 0 && 0 <= st(t2.to, e2);\n        } })[C] = function() {\n          return Pn(this);\n        }, F));\n        var An = {}, Cn = {}, Tn = false;\n        function In(e2) {\n          Sn(Cn, e2), Tn || (Tn = true, setTimeout(function() {\n            Tn = false, qn(Cn, !(Cn = {}));\n          }, 0));\n        }\n        function qn(e2, t2) {\n          void 0 === t2 && (t2 = false);\n          var n2 = /* @__PURE__ */ new Set();\n          if (e2.all) for (var r2 = 0, i2 = Object.values(An); r2 < i2.length; r2++) Dn(a2 = i2[r2], e2, n2, t2);\n          else for (var o2 in e2) {\n            var a2, u2 = /^idb\\:\\/\\/(.*)\\/(.*)\\//.exec(o2);\n            u2 && (o2 = u2[1], u2 = u2[2], (a2 = An["idb://".concat(o2, "/").concat(u2)]) && Dn(a2, e2, n2, t2));\n          }\n          n2.forEach(function(e3) {\n            return e3();\n          });\n        }\n        function Dn(e2, t2, n2, r2) {\n          for (var i2 = [], o2 = 0, a2 = Object.entries(e2.queries.query); o2 < a2.length; o2++) {\n            for (var u2 = a2[o2], s2 = u2[0], c2 = [], l2 = 0, f2 = u2[1]; l2 < f2.length; l2++) {\n              var h2 = f2[l2];\n              jn(t2, h2.obsSet) ? h2.subscribers.forEach(function(e3) {\n                return n2.add(e3);\n              }) : r2 && c2.push(h2);\n            }\n            r2 && i2.push([s2, c2]);\n          }\n          if (r2) for (var d2 = 0, p2 = i2; d2 < p2.length; d2++) {\n            var y2 = p2[d2], s2 = y2[0], c2 = y2[1];\n            e2.queries.query[s2] = c2;\n          }\n        }\n        function Bn(f2) {\n          var h2 = f2._state, r2 = f2._deps.indexedDB;\n          if (h2.isBeingOpened || f2.idbdb) return h2.dbReadyPromise.then(function() {\n            return h2.dbOpenError ? Xe(h2.dbOpenError) : f2;\n          });\n          h2.isBeingOpened = true, h2.dbOpenError = null, h2.openComplete = false;\n          var t2 = h2.openCanceller, d2 = Math.round(10 * f2.verno), p2 = false;\n          function e2() {\n            if (h2.openCanceller !== t2) throw new Y.DatabaseClosed("db.open() was cancelled");\n          }\n          function y2() {\n            return new _e(function(s2, n3) {\n              if (e2(), !r2) throw new Y.MissingAPI();\n              var c2 = f2.name, l2 = h2.autoSchema || !d2 ? r2.open(c2) : r2.open(c2, d2);\n              if (!l2) throw new Y.MissingAPI();\n              l2.onerror = Ft(n3), l2.onblocked = Ie(f2._fireOnBlocked), l2.onupgradeneeded = Ie(function(e3) {\n                var t3;\n                v2 = l2.transaction, h2.autoSchema && !f2._options.allowEmptyDB ? (l2.onerror = Mt, v2.abort(), l2.result.close(), (t3 = r2.deleteDatabase(c2)).onsuccess = t3.onerror = Ie(function() {\n                  n3(new Y.NoSuchDatabase("Database ".concat(c2, " doesnt exist")));\n                })) : (v2.onerror = Ft(n3), e3 = e3.oldVersion > Math.pow(2, 62) ? 0 : e3.oldVersion, m2 = e3 < 1, f2.idbdb = l2.result, p2 && un(f2, v2), an(f2, e3 / 10, v2, n3));\n              }, n3), l2.onsuccess = Ie(function() {\n                v2 = null;\n                var e3, t3, n4, r3, i3, o2 = f2.idbdb = l2.result, a2 = b(o2.objectStoreNames);\n                if (0 < a2.length) try {\n                  var u2 = o2.transaction(1 === (r3 = a2).length ? r3[0] : r3, "readonly");\n                  if (h2.autoSchema) t3 = o2, n4 = u2, (e3 = f2).verno = t3.version / 10, n4 = e3._dbSchema = hn(0, t3, n4), e3._storeNames = b(t3.objectStoreNames, 0), nn(e3, [e3._allTables], O(n4), n4);\n                  else if (dn(f2, f2._dbSchema, u2), ((i3 = sn(hn(0, (i3 = f2).idbdb, u2), i3._dbSchema)).add.length || i3.change.some(function(e4) {\n                    return e4.add.length || e4.change.length;\n                  })) && !p2) return console.warn("Dexie SchemaDiff: Schema was extended without increasing the number passed to db.version(). Dexie will add missing parts and increment native version number to workaround this."), o2.close(), d2 = o2.version + 1, p2 = true, s2(y2());\n                  tn(f2, u2);\n                } catch (e4) {\n                }\n                et.push(f2), o2.onversionchange = Ie(function(e4) {\n                  h2.vcFired = true, f2.on("versionchange").fire(e4);\n                }), o2.onclose = Ie(function() {\n                  f2.close({ disableAutoOpen: false });\n                }), m2 && (i3 = f2._deps, u2 = c2, o2 = i3.indexedDB, i3 = i3.IDBKeyRange, bn(o2) || u2 === tt || mn(o2, i3).put({ name: u2 }).catch(G)), s2();\n              }, n3);\n            }).catch(function(e3) {\n              switch (null == e3 ? void 0 : e3.name) {\n                case "UnknownError":\n                  if (0 < h2.PR1398_maxLoop) return h2.PR1398_maxLoop--, console.warn("Dexie: Workaround for Chrome UnknownError on open()"), y2();\n                  break;\n                case "VersionError":\n                  if (0 < d2) return d2 = 0, y2();\n              }\n              return _e.reject(e3);\n            });\n          }\n          var n2, i2 = h2.dbReadyResolve, v2 = null, m2 = false;\n          return _e.race([t2, ("undefined" == typeof navigator ? _e.resolve() : !navigator.userAgentData && /Safari\\//.test(navigator.userAgent) && !/Chrom(e|ium)\\//.test(navigator.userAgent) && indexedDB.databases ? new Promise(function(e3) {\n            function t3() {\n              return indexedDB.databases().finally(e3);\n            }\n            n2 = setInterval(t3, 100), t3();\n          }).finally(function() {\n            return clearInterval(n2);\n          }) : Promise.resolve()).then(y2)]).then(function() {\n            return e2(), h2.onReadyBeingFired = [], _e.resolve(gn(function() {\n              return f2.on.ready.fire(f2.vip);\n            })).then(function e3() {\n              if (0 < h2.onReadyBeingFired.length) {\n                var t3 = h2.onReadyBeingFired.reduce(re, G);\n                return h2.onReadyBeingFired = [], _e.resolve(gn(function() {\n                  return t3(f2.vip);\n                })).then(e3);\n              }\n            });\n          }).finally(function() {\n            h2.openCanceller === t2 && (h2.onReadyBeingFired = null, h2.isBeingOpened = false);\n          }).catch(function(e3) {\n            h2.dbOpenError = e3;\n            try {\n              v2 && v2.abort();\n            } catch (e4) {\n            }\n            return t2 === h2.openCanceller && f2._close(), Xe(e3);\n          }).finally(function() {\n            h2.openComplete = true, i2();\n          }).then(function() {\n            var n3;\n            return m2 && (n3 = {}, f2.tables.forEach(function(t3) {\n              t3.schema.indexes.forEach(function(e3) {\n                e3.name && (n3["idb://".concat(f2.name, "/").concat(t3.name, "/").concat(e3.name)] = new _n(-1 / 0, [[[]]]));\n              }), n3["idb://".concat(f2.name, "/").concat(t3.name, "/")] = n3["idb://".concat(f2.name, "/").concat(t3.name, "/:dels")] = new _n(-1 / 0, [[[]]]);\n            }), Ut(Nt).fire(n3), qn(n3, true)), f2;\n          });\n        }\n        function Rn(t2) {\n          function e2(e3) {\n            return t2.next(e3);\n          }\n          var r2 = n2(e2), i2 = n2(function(e3) {\n            return t2.throw(e3);\n          });\n          function n2(n3) {\n            return function(e3) {\n              var t3 = n3(e3), e3 = t3.value;\n              return t3.done ? e3 : e3 && "function" == typeof e3.then ? e3.then(r2, i2) : x(e3) ? Promise.all(e3).then(r2, i2) : r2(e3);\n            };\n          }\n          return n2(e2)();\n        }\n        function Fn(e2, t2, n2) {\n          for (var r2 = x(e2) ? e2.slice() : [e2], i2 = 0; i2 < n2; ++i2) r2.push(t2);\n          return r2;\n        }\n        var Mn = { stack: "dbcore", name: "VirtualIndexMiddleware", level: 1, create: function(f2) {\n          return _(_({}, f2), { table: function(e2) {\n            var a2 = f2.table(e2), t2 = a2.schema, u2 = {}, s2 = [];\n            function c2(e3, t3, n3) {\n              var r3 = Jt(e3), i3 = u2[r3] = u2[r3] || [], o2 = null == e3 ? 0 : "string" == typeof e3 ? 1 : e3.length, a3 = 0 < t3, a3 = _(_({}, n3), { name: a3 ? "".concat(r3, "(virtual-from:").concat(n3.name, ")") : n3.name, lowLevelIndex: n3, isVirtual: a3, keyTail: t3, keyLength: o2, extractKey: Gt(e3), unique: !a3 && n3.unique });\n              return i3.push(a3), a3.isPrimaryKey || s2.push(a3), 1 < o2 && c2(2 === o2 ? e3[0] : e3.slice(0, o2 - 1), t3 + 1, n3), i3.sort(function(e4, t4) {\n                return e4.keyTail - t4.keyTail;\n              }), a3;\n            }\n            e2 = c2(t2.primaryKey.keyPath, 0, t2.primaryKey);\n            u2[":id"] = [e2];\n            for (var n2 = 0, r2 = t2.indexes; n2 < r2.length; n2++) {\n              var i2 = r2[n2];\n              c2(i2.keyPath, 0, i2);\n            }\n            function l2(e3) {\n              var t3, n3 = e3.query.index;\n              return n3.isVirtual ? _(_({}, e3), { query: { index: n3.lowLevelIndex, range: (t3 = e3.query.range, n3 = n3.keyTail, { type: 1 === t3.type ? 2 : t3.type, lower: Fn(t3.lower, t3.lowerOpen ? f2.MAX_KEY : f2.MIN_KEY, n3), lowerOpen: true, upper: Fn(t3.upper, t3.upperOpen ? f2.MIN_KEY : f2.MAX_KEY, n3), upperOpen: true }) } }) : e3;\n            }\n            return _(_({}, a2), { schema: _(_({}, t2), { primaryKey: e2, indexes: s2, getIndexByKeyPath: function(e3) {\n              return (e3 = u2[Jt(e3)]) && e3[0];\n            } }), count: function(e3) {\n              return a2.count(l2(e3));\n            }, query: function(e3) {\n              return a2.query(l2(e3));\n            }, openCursor: function(t3) {\n              var e3 = t3.query.index, r3 = e3.keyTail, n3 = e3.isVirtual, i3 = e3.keyLength;\n              return n3 ? a2.openCursor(l2(t3)).then(function(e4) {\n                return e4 && o2(e4);\n              }) : a2.openCursor(t3);\n              function o2(n4) {\n                return Object.create(n4, { continue: { value: function(e4) {\n                  null != e4 ? n4.continue(Fn(e4, t3.reverse ? f2.MAX_KEY : f2.MIN_KEY, r3)) : t3.unique ? n4.continue(n4.key.slice(0, i3).concat(t3.reverse ? f2.MIN_KEY : f2.MAX_KEY, r3)) : n4.continue();\n                } }, continuePrimaryKey: { value: function(e4, t4) {\n                  n4.continuePrimaryKey(Fn(e4, f2.MAX_KEY, r3), t4);\n                } }, primaryKey: { get: function() {\n                  return n4.primaryKey;\n                } }, key: { get: function() {\n                  var e4 = n4.key;\n                  return 1 === i3 ? e4[0] : e4.slice(0, i3);\n                } }, value: { get: function() {\n                  return n4.value;\n                } } });\n              }\n            } });\n          } });\n        } };\n        function Nn(i2, o2, a2, u2) {\n          return a2 = a2 || {}, u2 = u2 || "", O(i2).forEach(function(e2) {\n            var t2, n2, r2;\n            m(o2, e2) ? (t2 = i2[e2], n2 = o2[e2], "object" == typeof t2 && "object" == typeof n2 && t2 && n2 ? (r2 = A(t2)) !== A(n2) ? a2[u2 + e2] = o2[e2] : "Object" === r2 ? Nn(t2, n2, a2, u2 + e2 + ".") : t2 !== n2 && (a2[u2 + e2] = o2[e2]) : t2 !== n2 && (a2[u2 + e2] = o2[e2])) : a2[u2 + e2] = void 0;\n          }), O(o2).forEach(function(e2) {\n            m(i2, e2) || (a2[u2 + e2] = o2[e2]);\n          }), a2;\n        }\n        function Ln(e2, t2) {\n          return "delete" === t2.type ? t2.keys : t2.keys || t2.values.map(e2.extractKey);\n        }\n        var Un = { stack: "dbcore", name: "HooksMiddleware", level: 2, create: function(e2) {\n          return _(_({}, e2), { table: function(r2) {\n            var y2 = e2.table(r2), v2 = y2.schema.primaryKey;\n            return _(_({}, y2), { mutate: function(e3) {\n              var t2 = me.trans, n2 = t2.table(r2).hook, h2 = n2.deleting, d2 = n2.creating, p2 = n2.updating;\n              switch (e3.type) {\n                case "add":\n                  if (d2.fire === G) break;\n                  return t2._promise("readwrite", function() {\n                    return a2(e3);\n                  }, true);\n                case "put":\n                  if (d2.fire === G && p2.fire === G) break;\n                  return t2._promise("readwrite", function() {\n                    return a2(e3);\n                  }, true);\n                case "delete":\n                  if (h2.fire === G) break;\n                  return t2._promise("readwrite", function() {\n                    return a2(e3);\n                  }, true);\n                case "deleteRange":\n                  if (h2.fire === G) break;\n                  return t2._promise("readwrite", function() {\n                    return (function n3(r3, i2, o2) {\n                      return y2.query({ trans: r3, values: false, query: { index: v2, range: i2 }, limit: o2 }).then(function(e4) {\n                        var t3 = e4.result;\n                        return a2({ type: "delete", keys: t3, trans: r3 }).then(function(e5) {\n                          return 0 < e5.numFailures ? Promise.reject(e5.failures[0]) : t3.length < o2 ? { failures: [], numFailures: 0, lastResult: void 0 } : n3(r3, _(_({}, i2), { lower: t3[t3.length - 1], lowerOpen: true }), o2);\n                        });\n                      });\n                    })(e3.trans, e3.range, 1e4);\n                  }, true);\n              }\n              return y2.mutate(e3);\n              function a2(c2) {\n                var e4, t3, n3, l2 = me.trans, f2 = c2.keys || Ln(v2, c2);\n                if (!f2) throw new Error("Keys missing");\n                return "delete" !== (c2 = "add" === c2.type || "put" === c2.type ? _(_({}, c2), { keys: f2 }) : _({}, c2)).type && (c2.values = i([], c2.values)), c2.keys && (c2.keys = i([], c2.keys)), e4 = y2, n3 = f2, ("add" === (t3 = c2).type ? Promise.resolve([]) : e4.getMany({ trans: t3.trans, keys: n3, cache: "immutable" })).then(function(u2) {\n                  var s2 = f2.map(function(e5, t4) {\n                    var n4, r3, i2, o2 = u2[t4], a3 = { onerror: null, onsuccess: null };\n                    return "delete" === c2.type ? h2.fire.call(a3, e5, o2, l2) : "add" === c2.type || void 0 === o2 ? (n4 = d2.fire.call(a3, e5, c2.values[t4], l2), null == e5 && null != n4 && (c2.keys[t4] = e5 = n4, v2.outbound || w(c2.values[t4], v2.keyPath, e5))) : (n4 = Nn(o2, c2.values[t4]), (r3 = p2.fire.call(a3, n4, e5, o2, l2)) && (i2 = c2.values[t4], Object.keys(r3).forEach(function(e6) {\n                      m(i2, e6) ? i2[e6] = r3[e6] : w(i2, e6, r3[e6]);\n                    }))), a3;\n                  });\n                  return y2.mutate(c2).then(function(e5) {\n                    for (var t4 = e5.failures, n4 = e5.results, r3 = e5.numFailures, e5 = e5.lastResult, i2 = 0; i2 < f2.length; ++i2) {\n                      var o2 = (n4 || f2)[i2], a3 = s2[i2];\n                      null == o2 ? a3.onerror && a3.onerror(t4[i2]) : a3.onsuccess && a3.onsuccess("put" === c2.type && u2[i2] ? c2.values[i2] : o2);\n                    }\n                    return { failures: t4, results: n4, numFailures: r3, lastResult: e5 };\n                  }).catch(function(t4) {\n                    return s2.forEach(function(e5) {\n                      return e5.onerror && e5.onerror(t4);\n                    }), Promise.reject(t4);\n                  });\n                });\n              }\n            } });\n          } });\n        } };\n        function Vn(e2, t2, n2) {\n          try {\n            if (!t2) return null;\n            if (t2.keys.length < e2.length) return null;\n            for (var r2 = [], i2 = 0, o2 = 0; i2 < t2.keys.length && o2 < e2.length; ++i2) 0 === st(t2.keys[i2], e2[o2]) && (r2.push(n2 ? S(t2.values[i2]) : t2.values[i2]), ++o2);\n            return r2.length === e2.length ? r2 : null;\n          } catch (e3) {\n            return null;\n          }\n        }\n        var zn = { stack: "dbcore", level: -1, create: function(t2) {\n          return { table: function(e2) {\n            var n2 = t2.table(e2);\n            return _(_({}, n2), { getMany: function(t3) {\n              if (!t3.cache) return n2.getMany(t3);\n              var e3 = Vn(t3.keys, t3.trans._cache, "clone" === t3.cache);\n              return e3 ? _e.resolve(e3) : n2.getMany(t3).then(function(e4) {\n                return t3.trans._cache = { keys: t3.keys, values: "clone" === t3.cache ? S(e4) : e4 }, e4;\n              });\n            }, mutate: function(e3) {\n              return "add" !== e3.type && (e3.trans._cache = null), n2.mutate(e3);\n            } });\n          } };\n        } };\n        function Wn(e2, t2) {\n          return "readonly" === e2.trans.mode && !!e2.subscr && !e2.trans.explicit && "disabled" !== e2.trans.db._options.cache && !t2.schema.primaryKey.outbound;\n        }\n        function Yn(e2, t2) {\n          switch (e2) {\n            case "query":\n              return t2.values && !t2.unique;\n            case "get":\n            case "getMany":\n            case "count":\n            case "openCursor":\n              return false;\n          }\n        }\n        var $n = { stack: "dbcore", level: 0, name: "Observability", create: function(b2) {\n          var g2 = b2.schema.name, w2 = new _n(b2.MIN_KEY, b2.MAX_KEY);\n          return _(_({}, b2), { transaction: function(e2, t2, n2) {\n            if (me.subscr && "readonly" !== t2) throw new Y.ReadOnly("Readwrite transaction in liveQuery context. Querier source: ".concat(me.querier));\n            return b2.transaction(e2, t2, n2);\n          }, table: function(d2) {\n            var p2 = b2.table(d2), y2 = p2.schema, v2 = y2.primaryKey, e2 = y2.indexes, c2 = v2.extractKey, l2 = v2.outbound, m2 = v2.autoIncrement && e2.filter(function(e3) {\n              return e3.compound && e3.keyPath.includes(v2.keyPath);\n            }), t2 = _(_({}, p2), { mutate: function(a2) {\n              function u2(e4) {\n                return e4 = "idb://".concat(g2, "/").concat(d2, "/").concat(e4), n2[e4] || (n2[e4] = new _n());\n              }\n              var e3, o2, s2, t3 = a2.trans, n2 = a2.mutatedParts || (a2.mutatedParts = {}), r2 = u2(""), i2 = u2(":dels"), c3 = a2.type, l3 = "deleteRange" === a2.type ? [a2.range] : "delete" === a2.type ? [a2.keys] : a2.values.length < 50 ? [Ln(v2, a2).filter(function(e4) {\n                return e4;\n              }), a2.values] : [], f3 = l3[0], h2 = l3[1], l3 = a2.trans._cache;\n              return x(f3) ? (r2.addKeys(f3), (l3 = "delete" === c3 || f3.length === h2.length ? Vn(f3, l3) : null) || i2.addKeys(f3), (l3 || h2) && (e3 = u2, o2 = l3, s2 = h2, y2.indexes.forEach(function(t4) {\n                var n3 = e3(t4.name || "");\n                function r3(e4) {\n                  return null != e4 ? t4.extractKey(e4) : null;\n                }\n                function i3(e4) {\n                  return t4.multiEntry && x(e4) ? e4.forEach(function(e5) {\n                    return n3.addKey(e5);\n                  }) : n3.addKey(e4);\n                }\n                (o2 || s2).forEach(function(e4, t5) {\n                  var n4 = o2 && r3(o2[t5]), t5 = s2 && r3(s2[t5]);\n                  0 !== st(n4, t5) && (null != n4 && i3(n4), null != t5 && i3(t5));\n                });\n              }))) : f3 ? (h2 = { from: null !== (h2 = f3.lower) && void 0 !== h2 ? h2 : b2.MIN_KEY, to: null !== (h2 = f3.upper) && void 0 !== h2 ? h2 : b2.MAX_KEY }, i2.add(h2), r2.add(h2)) : (r2.add(w2), i2.add(w2), y2.indexes.forEach(function(e4) {\n                return u2(e4.name).add(w2);\n              })), p2.mutate(a2).then(function(o3) {\n                return !f3 || "add" !== a2.type && "put" !== a2.type || (r2.addKeys(o3.results), m2 && m2.forEach(function(t4) {\n                  for (var e4 = a2.values.map(function(e5) {\n                    return t4.extractKey(e5);\n                  }), n3 = t4.keyPath.findIndex(function(e5) {\n                    return e5 === v2.keyPath;\n                  }), r3 = 0, i3 = o3.results.length; r3 < i3; ++r3) e4[r3][n3] = o3.results[r3];\n                  u2(t4.name).addKeys(e4);\n                })), t3.mutatedParts = Sn(t3.mutatedParts || {}, n2), o3;\n              });\n            } }), e2 = function(e3) {\n              var t3 = e3.query, e3 = t3.index, t3 = t3.range;\n              return [e3, new _n(null !== (e3 = t3.lower) && void 0 !== e3 ? e3 : b2.MIN_KEY, null !== (t3 = t3.upper) && void 0 !== t3 ? t3 : b2.MAX_KEY)];\n            }, f2 = { get: function(e3) {\n              return [v2, new _n(e3.key)];\n            }, getMany: function(e3) {\n              return [v2, new _n().addKeys(e3.keys)];\n            }, count: e2, query: e2, openCursor: e2 };\n            return O(f2).forEach(function(s2) {\n              t2[s2] = function(i2) {\n                var e3 = me.subscr, t3 = !!e3, n2 = Wn(me, p2) && Yn(s2, i2) ? i2.obsSet = {} : e3;\n                if (t3) {\n                  var r2 = function(e4) {\n                    e4 = "idb://".concat(g2, "/").concat(d2, "/").concat(e4);\n                    return n2[e4] || (n2[e4] = new _n());\n                  }, o2 = r2(""), a2 = r2(":dels"), e3 = f2[s2](i2), t3 = e3[0], e3 = e3[1];\n                  if (("query" === s2 && t3.isPrimaryKey && !i2.values ? a2 : r2(t3.name || "")).add(e3), !t3.isPrimaryKey) {\n                    if ("count" !== s2) {\n                      var u2 = "query" === s2 && l2 && i2.values && p2.query(_(_({}, i2), { values: false }));\n                      return p2[s2].apply(this, arguments).then(function(t4) {\n                        if ("query" === s2) {\n                          if (l2 && i2.values) return u2.then(function(e5) {\n                            e5 = e5.result;\n                            return o2.addKeys(e5), t4;\n                          });\n                          var e4 = i2.values ? t4.result.map(c2) : t4.result;\n                          (i2.values ? o2 : a2).addKeys(e4);\n                        } else if ("openCursor" === s2) {\n                          var n3 = t4, r3 = i2.values;\n                          return n3 && Object.create(n3, { key: { get: function() {\n                            return a2.addKey(n3.primaryKey), n3.key;\n                          } }, primaryKey: { get: function() {\n                            var e5 = n3.primaryKey;\n                            return a2.addKey(e5), e5;\n                          } }, value: { get: function() {\n                            return r3 && o2.addKey(n3.primaryKey), n3.value;\n                          } } });\n                        }\n                        return t4;\n                      });\n                    }\n                    a2.add(w2);\n                  }\n                }\n                return p2[s2].apply(this, arguments);\n              };\n            }), t2;\n          } });\n        } };\n        function Qn(e2, t2, n2) {\n          if (0 === n2.numFailures) return t2;\n          if ("deleteRange" === t2.type) return null;\n          var r2 = t2.keys ? t2.keys.length : "values" in t2 && t2.values ? t2.values.length : 1;\n          if (n2.numFailures === r2) return null;\n          t2 = _({}, t2);\n          return x(t2.keys) && (t2.keys = t2.keys.filter(function(e3, t3) {\n            return !(t3 in n2.failures);\n          })), "values" in t2 && x(t2.values) && (t2.values = t2.values.filter(function(e3, t3) {\n            return !(t3 in n2.failures);\n          })), t2;\n        }\n        function Gn(e2, t2) {\n          return n2 = e2, (void 0 === (r2 = t2).lower || (r2.lowerOpen ? 0 < st(n2, r2.lower) : 0 <= st(n2, r2.lower))) && (e2 = e2, void 0 === (t2 = t2).upper || (t2.upperOpen ? st(e2, t2.upper) < 0 : st(e2, t2.upper) <= 0));\n          var n2, r2;\n        }\n        function Xn(e2, d2, t2, n2, r2, i2) {\n          if (!t2 || 0 === t2.length) return e2;\n          var o2 = d2.query.index, p2 = o2.multiEntry, y2 = d2.query.range, v2 = n2.schema.primaryKey.extractKey, m2 = o2.extractKey, a2 = (o2.lowLevelIndex || o2).extractKey, t2 = t2.reduce(function(e3, t3) {\n            var n3 = e3, r3 = [];\n            if ("add" === t3.type || "put" === t3.type) for (var i3 = new _n(), o3 = t3.values.length - 1; 0 <= o3; --o3) {\n              var a3, u2 = t3.values[o3], s2 = v2(u2);\n              i3.hasKey(s2) || (a3 = m2(u2), (p2 && x(a3) ? a3.some(function(e4) {\n                return Gn(e4, y2);\n              }) : Gn(a3, y2)) && (i3.addKey(s2), r3.push(u2)));\n            }\n            switch (t3.type) {\n              case "add":\n                var c2 = new _n().addKeys(d2.values ? e3.map(function(e4) {\n                  return v2(e4);\n                }) : e3), n3 = e3.concat(d2.values ? r3.filter(function(e4) {\n                  e4 = v2(e4);\n                  return !c2.hasKey(e4) && (c2.addKey(e4), true);\n                }) : r3.map(function(e4) {\n                  return v2(e4);\n                }).filter(function(e4) {\n                  return !c2.hasKey(e4) && (c2.addKey(e4), true);\n                }));\n                break;\n              case "put":\n                var l2 = new _n().addKeys(t3.values.map(function(e4) {\n                  return v2(e4);\n                }));\n                n3 = e3.filter(function(e4) {\n                  return !l2.hasKey(d2.values ? v2(e4) : e4);\n                }).concat(d2.values ? r3 : r3.map(function(e4) {\n                  return v2(e4);\n                }));\n                break;\n              case "delete":\n                var f2 = new _n().addKeys(t3.keys);\n                n3 = e3.filter(function(e4) {\n                  return !f2.hasKey(d2.values ? v2(e4) : e4);\n                });\n                break;\n              case "deleteRange":\n                var h2 = t3.range;\n                n3 = e3.filter(function(e4) {\n                  return !Gn(v2(e4), h2);\n                });\n            }\n            return n3;\n          }, e2);\n          return t2 === e2 ? e2 : (t2.sort(function(e3, t3) {\n            return st(a2(e3), a2(t3)) || st(v2(e3), v2(t3));\n          }), d2.limit && d2.limit < 1 / 0 && (t2.length > d2.limit ? t2.length = d2.limit : e2.length === d2.limit && t2.length < d2.limit && (r2.dirty = true)), i2 ? Object.freeze(t2) : t2);\n        }\n        function Hn(e2, t2) {\n          return 0 === st(e2.lower, t2.lower) && 0 === st(e2.upper, t2.upper) && !!e2.lowerOpen == !!t2.lowerOpen && !!e2.upperOpen == !!t2.upperOpen;\n        }\n        function Jn(e2, t2) {\n          return (function(e3, t3, n2, r2) {\n            if (void 0 === e3) return void 0 !== t3 ? -1 : 0;\n            if (void 0 === t3) return 1;\n            if (0 === (t3 = st(e3, t3))) {\n              if (n2 && r2) return 0;\n              if (n2) return 1;\n              if (r2) return -1;\n            }\n            return t3;\n          })(e2.lower, t2.lower, e2.lowerOpen, t2.lowerOpen) <= 0 && 0 <= (function(e3, t3, n2, r2) {\n            if (void 0 === e3) return void 0 !== t3 ? 1 : 0;\n            if (void 0 === t3) return -1;\n            if (0 === (t3 = st(e3, t3))) {\n              if (n2 && r2) return 0;\n              if (n2) return -1;\n              if (r2) return 1;\n            }\n            return t3;\n          })(e2.upper, t2.upper, e2.upperOpen, t2.upperOpen);\n        }\n        function Zn(n2, r2, i2, e2) {\n          n2.subscribers.add(i2), e2.addEventListener("abort", function() {\n            var e3, t2;\n            n2.subscribers.delete(i2), 0 === n2.subscribers.size && (e3 = n2, t2 = r2, setTimeout(function() {\n              0 === e3.subscribers.size && I(t2, e3);\n            }, 3e3));\n          });\n        }\n        var er = { stack: "dbcore", level: 0, name: "Cache", create: function(k2) {\n          var O2 = k2.schema.name;\n          return _(_({}, k2), { transaction: function(g2, w2, e2) {\n            var _2, t2, x2 = k2.transaction(g2, w2, e2);\n            return "readwrite" === w2 && (t2 = (_2 = new AbortController()).signal, e2 = function(b2) {\n              return function() {\n                if (_2.abort(), "readwrite" === w2) {\n                  for (var t3 = /* @__PURE__ */ new Set(), e3 = 0, n2 = g2; e3 < n2.length; e3++) {\n                    var r2 = n2[e3], i2 = An["idb://".concat(O2, "/").concat(r2)];\n                    if (i2) {\n                      var o2 = k2.table(r2), a2 = i2.optimisticOps.filter(function(e4) {\n                        return e4.trans === x2;\n                      });\n                      if (x2._explicit && b2 && x2.mutatedParts) for (var u2 = 0, s2 = Object.values(i2.queries.query); u2 < s2.length; u2++) for (var c2 = 0, l2 = (d2 = s2[u2]).slice(); c2 < l2.length; c2++) jn((p2 = l2[c2]).obsSet, x2.mutatedParts) && (I(d2, p2), p2.subscribers.forEach(function(e4) {\n                        return t3.add(e4);\n                      }));\n                      else if (0 < a2.length) {\n                        i2.optimisticOps = i2.optimisticOps.filter(function(e4) {\n                          return e4.trans !== x2;\n                        });\n                        for (var f2 = 0, h2 = Object.values(i2.queries.query); f2 < h2.length; f2++) for (var d2, p2, y2, v2 = 0, m2 = (d2 = h2[f2]).slice(); v2 < m2.length; v2++) null != (p2 = m2[v2]).res && x2.mutatedParts && (b2 && !p2.dirty ? (y2 = Object.isFrozen(p2.res), y2 = Xn(p2.res, p2.req, a2, o2, p2, y2), p2.dirty ? (I(d2, p2), p2.subscribers.forEach(function(e4) {\n                          return t3.add(e4);\n                        })) : y2 !== p2.res && (p2.res = y2, p2.promise = _e.resolve({ result: y2 }))) : (p2.dirty && I(d2, p2), p2.subscribers.forEach(function(e4) {\n                          return t3.add(e4);\n                        })));\n                      }\n                    }\n                  }\n                  t3.forEach(function(e4) {\n                    return e4();\n                  });\n                }\n              };\n            }, x2.addEventListener("abort", e2(false), { signal: t2 }), x2.addEventListener("error", e2(false), { signal: t2 }), x2.addEventListener("complete", e2(true), { signal: t2 })), x2;\n          }, table: function(c2) {\n            var l2 = k2.table(c2), i2 = l2.schema.primaryKey;\n            return _(_({}, l2), { mutate: function(t2) {\n              var e2 = me.trans;\n              if (i2.outbound || "disabled" === e2.db._options.cache || e2.explicit || "readwrite" !== e2.idbtrans.mode) return l2.mutate(t2);\n              var n2 = An["idb://".concat(O2, "/").concat(c2)];\n              if (!n2) return l2.mutate(t2);\n              e2 = l2.mutate(t2);\n              return "add" !== t2.type && "put" !== t2.type || !(50 <= t2.values.length || Ln(i2, t2).some(function(e3) {\n                return null == e3;\n              })) ? (n2.optimisticOps.push(t2), t2.mutatedParts && In(t2.mutatedParts), e2.then(function(e3) {\n                0 < e3.numFailures && (I(n2.optimisticOps, t2), (e3 = Qn(0, t2, e3)) && n2.optimisticOps.push(e3), t2.mutatedParts && In(t2.mutatedParts));\n              }), e2.catch(function() {\n                I(n2.optimisticOps, t2), t2.mutatedParts && In(t2.mutatedParts);\n              })) : e2.then(function(r2) {\n                var e3 = Qn(0, _(_({}, t2), { values: t2.values.map(function(e4, t3) {\n                  var n3;\n                  if (r2.failures[t3]) return e4;\n                  e4 = null !== (n3 = i2.keyPath) && void 0 !== n3 && n3.includes(".") ? S(e4) : _({}, e4);\n                  return w(e4, i2.keyPath, r2.results[t3]), e4;\n                }) }), r2);\n                n2.optimisticOps.push(e3), queueMicrotask(function() {\n                  return t2.mutatedParts && In(t2.mutatedParts);\n                });\n              }), e2;\n            }, query: function(t2) {\n              if (!Wn(me, l2) || !Yn("query", t2)) return l2.query(t2);\n              var i3 = "immutable" === (null === (o2 = me.trans) || void 0 === o2 ? void 0 : o2.db._options.cache), e2 = me, n2 = e2.requery, r2 = e2.signal, o2 = (function(e3, t3, n3, r3) {\n                var i4 = An["idb://".concat(e3, "/").concat(t3)];\n                if (!i4) return [];\n                if (!(t3 = i4.queries[n3])) return [null, false, i4, null];\n                var o3 = t3[(r3.query ? r3.query.index.name : null) || ""];\n                if (!o3) return [null, false, i4, null];\n                switch (n3) {\n                  case "query":\n                    var a3 = o3.find(function(e4) {\n                      return e4.req.limit === r3.limit && e4.req.values === r3.values && Hn(e4.req.query.range, r3.query.range);\n                    });\n                    return a3 ? [a3, true, i4, o3] : [o3.find(function(e4) {\n                      return ("limit" in e4.req ? e4.req.limit : 1 / 0) >= r3.limit && (!r3.values || e4.req.values) && Jn(e4.req.query.range, r3.query.range);\n                    }), false, i4, o3];\n                  case "count":\n                    a3 = o3.find(function(e4) {\n                      return Hn(e4.req.query.range, r3.query.range);\n                    });\n                    return [a3, !!a3, i4, o3];\n                }\n              })(O2, c2, "query", t2), a2 = o2[0], e2 = o2[1], u2 = o2[2], s2 = o2[3];\n              return a2 && e2 ? a2.obsSet = t2.obsSet : (e2 = l2.query(t2).then(function(e3) {\n                var t3 = e3.result;\n                if (a2 && (a2.res = t3), i3) {\n                  for (var n3 = 0, r3 = t3.length; n3 < r3; ++n3) Object.freeze(t3[n3]);\n                  Object.freeze(t3);\n                } else e3.result = S(t3);\n                return e3;\n              }).catch(function(e3) {\n                return s2 && a2 && I(s2, a2), Promise.reject(e3);\n              }), a2 = { obsSet: t2.obsSet, promise: e2, subscribers: /* @__PURE__ */ new Set(), type: "query", req: t2, dirty: false }, s2 ? s2.push(a2) : (s2 = [a2], (u2 = u2 || (An["idb://".concat(O2, "/").concat(c2)] = { queries: { query: {}, count: {} }, objs: /* @__PURE__ */ new Map(), optimisticOps: [], unsignaledParts: {} })).queries.query[t2.query.index.name || ""] = s2)), Zn(a2, s2, n2, r2), a2.promise.then(function(e3) {\n                return { result: Xn(e3.result, t2, null == u2 ? void 0 : u2.optimisticOps, l2, a2, i3) };\n              });\n            } });\n          } });\n        } };\n        function tr(e2, r2) {\n          return new Proxy(e2, { get: function(e3, t2, n2) {\n            return "db" === t2 ? r2 : Reflect.get(e3, t2, n2);\n          } });\n        }\n        var nr = (rr.prototype.version = function(t2) {\n          if (isNaN(t2) || t2 < 0.1) throw new Y.Type("Given version is not a positive number");\n          if (t2 = Math.round(10 * t2) / 10, this.idbdb || this._state.isBeingOpened) throw new Y.Schema("Cannot add version when database is open");\n          this.verno = Math.max(this.verno, t2);\n          var e2 = this._versions, n2 = e2.filter(function(e3) {\n            return e3._cfg.version === t2;\n          })[0];\n          return n2 || (n2 = new this.Version(t2), e2.push(n2), e2.sort(on), n2.stores({}), this._state.autoSchema = false, n2);\n        }, rr.prototype._whenReady = function(e2) {\n          var n2 = this;\n          return this.idbdb && (this._state.openComplete || me.letThrough || this._vip) ? e2() : new _e(function(e3, t2) {\n            if (n2._state.openComplete) return t2(new Y.DatabaseClosed(n2._state.dbOpenError));\n            if (!n2._state.isBeingOpened) {\n              if (!n2._state.autoOpen) return void t2(new Y.DatabaseClosed());\n              n2.open().catch(G);\n            }\n            n2._state.dbReadyPromise.then(e3, t2);\n          }).then(e2);\n        }, rr.prototype.use = function(e2) {\n          var t2 = e2.stack, n2 = e2.create, r2 = e2.level, i2 = e2.name;\n          i2 && this.unuse({ stack: t2, name: i2 });\n          e2 = this._middlewares[t2] || (this._middlewares[t2] = []);\n          return e2.push({ stack: t2, create: n2, level: null == r2 ? 10 : r2, name: i2 }), e2.sort(function(e3, t3) {\n            return e3.level - t3.level;\n          }), this;\n        }, rr.prototype.unuse = function(e2) {\n          var t2 = e2.stack, n2 = e2.name, r2 = e2.create;\n          return t2 && this._middlewares[t2] && (this._middlewares[t2] = this._middlewares[t2].filter(function(e3) {\n            return r2 ? e3.create !== r2 : !!n2 && e3.name !== n2;\n          })), this;\n        }, rr.prototype.open = function() {\n          var e2 = this;\n          return $e(ve, function() {\n            return Bn(e2);\n          });\n        }, rr.prototype._close = function() {\n          this.on.close.fire(new CustomEvent("close"));\n          var n2 = this._state, e2 = et.indexOf(this);\n          if (0 <= e2 && et.splice(e2, 1), this.idbdb) {\n            try {\n              this.idbdb.close();\n            } catch (e3) {\n            }\n            this.idbdb = null;\n          }\n          n2.isBeingOpened || (n2.dbReadyPromise = new _e(function(e3) {\n            n2.dbReadyResolve = e3;\n          }), n2.openCanceller = new _e(function(e3, t2) {\n            n2.cancelOpen = t2;\n          }));\n        }, rr.prototype.close = function(e2) {\n          var t2 = (void 0 === e2 ? { disableAutoOpen: true } : e2).disableAutoOpen, e2 = this._state;\n          t2 ? (e2.isBeingOpened && e2.cancelOpen(new Y.DatabaseClosed()), this._close(), e2.autoOpen = false, e2.dbOpenError = new Y.DatabaseClosed()) : (this._close(), e2.autoOpen = this._options.autoOpen || e2.isBeingOpened, e2.openComplete = false, e2.dbOpenError = null);\n        }, rr.prototype.delete = function(n2) {\n          var i2 = this;\n          void 0 === n2 && (n2 = { disableAutoOpen: true });\n          var o2 = 0 < arguments.length && "object" != typeof arguments[0], a2 = this._state;\n          return new _e(function(r2, t2) {\n            function e2() {\n              i2.close(n2);\n              var e3 = i2._deps.indexedDB.deleteDatabase(i2.name);\n              e3.onsuccess = Ie(function() {\n                var e4, t3, n3;\n                e4 = i2._deps, t3 = i2.name, n3 = e4.indexedDB, e4 = e4.IDBKeyRange, bn(n3) || t3 === tt || mn(n3, e4).delete(t3).catch(G), r2();\n              }), e3.onerror = Ft(t2), e3.onblocked = i2._fireOnBlocked;\n            }\n            if (o2) throw new Y.InvalidArgument("Invalid closeOptions argument to db.delete()");\n            a2.isBeingOpened ? a2.dbReadyPromise.then(e2) : e2();\n          });\n        }, rr.prototype.backendDB = function() {\n          return this.idbdb;\n        }, rr.prototype.isOpen = function() {\n          return null !== this.idbdb;\n        }, rr.prototype.hasBeenClosed = function() {\n          var e2 = this._state.dbOpenError;\n          return e2 && "DatabaseClosed" === e2.name;\n        }, rr.prototype.hasFailed = function() {\n          return null !== this._state.dbOpenError;\n        }, rr.prototype.dynamicallyOpened = function() {\n          return this._state.autoSchema;\n        }, Object.defineProperty(rr.prototype, "tables", { get: function() {\n          var t2 = this;\n          return O(this._allTables).map(function(e2) {\n            return t2._allTables[e2];\n          });\n        }, enumerable: false, configurable: true }), rr.prototype.transaction = function() {\n          var e2 = function(e3, t2, n2) {\n            var r2 = arguments.length;\n            if (r2 < 2) throw new Y.InvalidArgument("Too few arguments");\n            for (var i2 = new Array(r2 - 1); --r2; ) i2[r2 - 1] = arguments[r2];\n            return n2 = i2.pop(), [e3, P(i2), n2];\n          }.apply(this, arguments);\n          return this._transaction.apply(this, e2);\n        }, rr.prototype._transaction = function(e2, t2, n2) {\n          var r2 = this, i2 = me.trans;\n          i2 && i2.db === this && -1 === e2.indexOf("!") || (i2 = null);\n          var o2, a2, u2 = -1 !== e2.indexOf("?");\n          e2 = e2.replace("!", "").replace("?", "");\n          try {\n            if (a2 = t2.map(function(e3) {\n              e3 = e3 instanceof r2.Table ? e3.name : e3;\n              if ("string" != typeof e3) throw new TypeError("Invalid table argument to Dexie.transaction(). Only Table or String are allowed");\n              return e3;\n            }), "r" == e2 || e2 === nt) o2 = nt;\n            else {\n              if ("rw" != e2 && e2 != rt) throw new Y.InvalidArgument("Invalid transaction mode: " + e2);\n              o2 = rt;\n            }\n            if (i2) {\n              if (i2.mode === nt && o2 === rt) {\n                if (!u2) throw new Y.SubTransaction("Cannot enter a sub-transaction with READWRITE mode when parent transaction is READONLY");\n                i2 = null;\n              }\n              i2 && a2.forEach(function(e3) {\n                if (i2 && -1 === i2.storeNames.indexOf(e3)) {\n                  if (!u2) throw new Y.SubTransaction("Table " + e3 + " not included in parent transaction.");\n                  i2 = null;\n                }\n              }), u2 && i2 && !i2.active && (i2 = null);\n            }\n          } catch (n3) {\n            return i2 ? i2._promise(null, function(e3, t3) {\n              t3(n3);\n            }) : Xe(n3);\n          }\n          var s2 = function i3(o3, a3, u3, s3, c2) {\n            return _e.resolve().then(function() {\n              var e3 = me.transless || me, t3 = o3._createTransaction(a3, u3, o3._dbSchema, s3);\n              if (t3.explicit = true, e3 = { trans: t3, transless: e3 }, s3) t3.idbtrans = s3.idbtrans;\n              else try {\n                t3.create(), t3.idbtrans._explicit = true, o3._state.PR1398_maxLoop = 3;\n              } catch (e4) {\n                return e4.name === z.InvalidState && o3.isOpen() && 0 < --o3._state.PR1398_maxLoop ? (console.warn("Dexie: Need to reopen db"), o3.close({ disableAutoOpen: false }), o3.open().then(function() {\n                  return i3(o3, a3, u3, null, c2);\n                })) : Xe(e4);\n              }\n              var n3, r3 = B(c2);\n              return r3 && Le(), e3 = _e.follow(function() {\n                var e4;\n                (n3 = c2.call(t3, t3)) && (r3 ? (e4 = Ue.bind(null, null), n3.then(e4, e4)) : "function" == typeof n3.next && "function" == typeof n3.throw && (n3 = Rn(n3)));\n              }, e3), (n3 && "function" == typeof n3.then ? _e.resolve(n3).then(function(e4) {\n                return t3.active ? e4 : Xe(new Y.PrematureCommit("Transaction committed too early. See http://bit.ly/2kdckMn"));\n              }) : e3.then(function() {\n                return n3;\n              })).then(function(e4) {\n                return s3 && t3._resolve(), t3._completion.then(function() {\n                  return e4;\n                });\n              }).catch(function(e4) {\n                return t3._reject(e4), Xe(e4);\n              });\n            });\n          }.bind(null, this, o2, a2, i2, n2);\n          return i2 ? i2._promise(o2, s2, "lock") : me.trans ? $e(me.transless, function() {\n            return r2._whenReady(s2);\n          }) : this._whenReady(s2);\n        }, rr.prototype.table = function(e2) {\n          if (!m(this._allTables, e2)) throw new Y.InvalidTable("Table ".concat(e2, " does not exist"));\n          return this._allTables[e2];\n        }, rr);\n        function rr(e2, t2) {\n          var o2 = this;\n          this._middlewares = {}, this.verno = 0;\n          var n2 = rr.dependencies;\n          this._options = t2 = _({ addons: rr.addons, autoOpen: true, indexedDB: n2.indexedDB, IDBKeyRange: n2.IDBKeyRange, cache: "cloned" }, t2), this._deps = { indexedDB: t2.indexedDB, IDBKeyRange: t2.IDBKeyRange };\n          n2 = t2.addons;\n          this._dbSchema = {}, this._versions = [], this._storeNames = [], this._allTables = {}, this.idbdb = null, this._novip = this;\n          var a2, r2, u2, i2, s2, c2 = { dbOpenError: null, isBeingOpened: false, onReadyBeingFired: null, openComplete: false, dbReadyResolve: G, dbReadyPromise: null, cancelOpen: G, openCanceller: null, autoSchema: true, PR1398_maxLoop: 3, autoOpen: t2.autoOpen };\n          c2.dbReadyPromise = new _e(function(e3) {\n            c2.dbReadyResolve = e3;\n          }), c2.openCanceller = new _e(function(e3, t3) {\n            c2.cancelOpen = t3;\n          }), this._state = c2, this.name = e2, this.on = mt(this, "populate", "blocked", "versionchange", "close", { ready: [re, G] }), this.once = function(n3, r3) {\n            var i3 = function() {\n              for (var e3 = [], t3 = 0; t3 < arguments.length; t3++) e3[t3] = arguments[t3];\n              o2.on(n3).unsubscribe(i3), r3.apply(o2, e3);\n            };\n            return o2.on(n3, i3);\n          }, this.on.ready.subscribe = p(this.on.ready.subscribe, function(i3) {\n            return function(n3, r3) {\n              rr.vip(function() {\n                var t3, e3 = o2._state;\n                e3.openComplete ? (e3.dbOpenError || _e.resolve().then(n3), r3 && i3(n3)) : e3.onReadyBeingFired ? (e3.onReadyBeingFired.push(n3), r3 && i3(n3)) : (i3(n3), t3 = o2, r3 || i3(function e4() {\n                  t3.on.ready.unsubscribe(n3), t3.on.ready.unsubscribe(e4);\n                }));\n              });\n            };\n          }), this.Collection = (a2 = this, bt(Kt.prototype, function(e3, t3) {\n            this.db = a2;\n            var n3 = ot, r3 = null;\n            if (t3) try {\n              n3 = t3();\n            } catch (e4) {\n              r3 = e4;\n            }\n            var i3 = e3._ctx, t3 = i3.table, e3 = t3.hook.reading.fire;\n            this._ctx = { table: t3, index: i3.index, isPrimKey: !i3.index || t3.schema.primKey.keyPath && i3.index === t3.schema.primKey.name, range: n3, keysOnly: false, dir: "next", unique: "", algorithm: null, filter: null, replayFilter: null, justLimit: true, isMatch: null, offset: 0, limit: 1 / 0, error: r3, or: i3.or, valueMapper: e3 !== X ? e3 : null };\n          })), this.Table = (r2 = this, bt(yt.prototype, function(e3, t3, n3) {\n            this.db = r2, this._tx = n3, this.name = e3, this.schema = t3, this.hook = r2._allTables[e3] ? r2._allTables[e3].hook : mt(null, { creating: [Z, G], reading: [H, X], updating: [te, G], deleting: [ee, G] });\n          })), this.Transaction = (u2 = this, bt(Vt.prototype, function(e3, t3, n3, r3, i3) {\n            var o3 = this;\n            "readonly" !== e3 && t3.forEach(function(e4) {\n              e4 = null === (e4 = n3[e4]) || void 0 === e4 ? void 0 : e4.yProps;\n              e4 && (t3 = t3.concat(e4.map(function(e5) {\n                return e5.updatesTable;\n              })));\n            }), this.db = u2, this.mode = e3, this.storeNames = t3, this.schema = n3, this.chromeTransactionDurability = r3, this.idbtrans = null, this.on = mt(this, "complete", "error", "abort"), this.parent = i3 || null, this.active = true, this._reculock = 0, this._blockedFuncs = [], this._resolve = null, this._reject = null, this._waitingFor = null, this._waitingQueue = null, this._spinCount = 0, this._completion = new _e(function(e4, t4) {\n              o3._resolve = e4, o3._reject = t4;\n            }), this._completion.then(function() {\n              o3.active = false, o3.on.complete.fire();\n            }, function(e4) {\n              var t4 = o3.active;\n              return o3.active = false, o3.on.error.fire(e4), o3.parent ? o3.parent._reject(e4) : t4 && o3.idbtrans && o3.idbtrans.abort(), Xe(e4);\n            });\n          })), this.Version = (i2 = this, bt(yn.prototype, function(e3) {\n            this.db = i2, this._cfg = { version: e3, storesSource: null, dbschema: {}, tables: {}, contentUpgrade: null };\n          })), this.WhereClause = (s2 = this, bt(Bt.prototype, function(e3, t3, n3) {\n            if (this.db = s2, this._ctx = { table: e3, index: ":id" === t3 ? null : t3, or: n3 }, this._cmp = this._ascending = st, this._descending = function(e4, t4) {\n              return st(t4, e4);\n            }, this._max = function(e4, t4) {\n              return 0 < st(e4, t4) ? e4 : t4;\n            }, this._min = function(e4, t4) {\n              return st(e4, t4) < 0 ? e4 : t4;\n            }, this._IDBKeyRange = s2._deps.IDBKeyRange, !this._IDBKeyRange) throw new Y.MissingAPI();\n          })), this.on("versionchange", function(e3) {\n            0 < e3.newVersion ? console.warn("Another connection wants to upgrade database \'".concat(o2.name, "\'. Closing db now to resume the upgrade.")) : console.warn("Another connection wants to delete database \'".concat(o2.name, "\'. Closing db now to resume the delete request.")), o2.close({ disableAutoOpen: false });\n          }), this.on("blocked", function(e3) {\n            !e3.newVersion || e3.newVersion < e3.oldVersion ? console.warn("Dexie.delete(\'".concat(o2.name, "\') was blocked")) : console.warn("Upgrade \'".concat(o2.name, "\' blocked by other connection holding version ").concat(e3.oldVersion / 10));\n          }), this._maxKey = Qt(t2.IDBKeyRange), this._createTransaction = function(e3, t3, n3, r3) {\n            return new o2.Transaction(e3, t3, n3, o2._options.chromeTransactionDurability, r3);\n          }, this._fireOnBlocked = function(t3) {\n            o2.on("blocked").fire(t3), et.filter(function(e3) {\n              return e3.name === o2.name && e3 !== o2 && !e3._state.vcFired;\n            }).map(function(e3) {\n              return e3.on("versionchange").fire(t3);\n            });\n          }, this.use(zn), this.use(er), this.use($n), this.use(Mn), this.use(Un);\n          var l2 = new Proxy(this, { get: function(e3, t3, n3) {\n            if ("_vip" === t3) return true;\n            if ("table" === t3) return function(e4) {\n              return tr(o2.table(e4), l2);\n            };\n            var r3 = Reflect.get(e3, t3, n3);\n            return r3 instanceof yt ? tr(r3, l2) : "tables" === t3 ? r3.map(function(e4) {\n              return tr(e4, l2);\n            }) : "_createTransaction" === t3 ? function() {\n              return tr(r3.apply(this, arguments), l2);\n            } : r3;\n          } });\n          this.vip = l2, n2.forEach(function(e3) {\n            return e3(o2);\n          });\n        }\n        var ir, F = "undefined" != typeof Symbol && "observable" in Symbol ? Symbol.observable : "@@observable", or = (ar.prototype.subscribe = function(e2, t2, n2) {\n          return this._subscribe(e2 && "function" != typeof e2 ? e2 : { next: e2, error: t2, complete: n2 });\n        }, ar.prototype[F] = function() {\n          return this;\n        }, ar);\n        function ar(e2) {\n          this._subscribe = e2;\n        }\n        try {\n          ir = { indexedDB: f.indexedDB || f.mozIndexedDB || f.webkitIndexedDB || f.msIndexedDB, IDBKeyRange: f.IDBKeyRange || f.webkitIDBKeyRange };\n        } catch (e2) {\n          ir = { indexedDB: null, IDBKeyRange: null };\n        }\n        function ur(h2) {\n          var d2, p2 = false, e2 = new or(function(r2) {\n            var i2 = B(h2);\n            var o2, a2 = false, u2 = {}, s2 = {}, e3 = { get closed() {\n              return a2;\n            }, unsubscribe: function() {\n              a2 || (a2 = true, o2 && o2.abort(), c2 && Ut.storagemutated.unsubscribe(f2));\n            } };\n            r2.start && r2.start(e3);\n            var c2 = false, l2 = function() {\n              return Ge(t2);\n            };\n            var f2 = function(e4) {\n              Sn(u2, e4), jn(s2, u2) && l2();\n            }, t2 = function() {\n              var t3, n2, e4;\n              !a2 && ir.indexedDB && (u2 = {}, t3 = {}, o2 && o2.abort(), o2 = new AbortController(), e4 = (function(e5) {\n                var t4 = je();\n                try {\n                  i2 && Le();\n                  var n3 = Ne(h2, e5);\n                  return n3 = i2 ? n3.finally(Ue) : n3;\n                } finally {\n                  t4 && Ae();\n                }\n              })(n2 = { subscr: t3, signal: o2.signal, requery: l2, querier: h2, trans: null }), Promise.resolve(e4).then(function(e5) {\n                p2 = true, d2 = e5, a2 || n2.signal.aborted || (u2 = {}, (function(e6) {\n                  for (var t4 in e6) if (m(e6, t4)) return;\n                  return 1;\n                })(s2 = t3) || c2 || (Ut(Nt, f2), c2 = true), Ge(function() {\n                  return !a2 && r2.next && r2.next(e5);\n                }));\n              }, function(e5) {\n                p2 = false, ["DatabaseClosedError", "AbortError"].includes(null == e5 ? void 0 : e5.name) || a2 || Ge(function() {\n                  a2 || r2.error && r2.error(e5);\n                });\n              }));\n            };\n            return setTimeout(l2, 0), e3;\n          });\n          return e2.hasValue = function() {\n            return p2;\n          }, e2.getValue = function() {\n            return d2;\n          }, e2;\n        }\n        var sr = nr;\n        function cr(e2) {\n          var t2 = fr;\n          try {\n            fr = true, Ut.storagemutated.fire(e2), qn(e2, true);\n          } finally {\n            fr = t2;\n          }\n        }\n        r(sr, _(_({}, Q), { delete: function(e2) {\n          return new sr(e2, { addons: [] }).delete();\n        }, exists: function(e2) {\n          return new sr(e2, { addons: [] }).open().then(function(e3) {\n            return e3.close(), true;\n          }).catch("NoSuchDatabaseError", function() {\n            return false;\n          });\n        }, getDatabaseNames: function(e2) {\n          try {\n            return t2 = sr.dependencies, n2 = t2.indexedDB, t2 = t2.IDBKeyRange, (bn(n2) ? Promise.resolve(n2.databases()).then(function(e3) {\n              return e3.map(function(e4) {\n                return e4.name;\n              }).filter(function(e4) {\n                return e4 !== tt;\n              });\n            }) : mn(n2, t2).toCollection().primaryKeys()).then(e2);\n          } catch (e3) {\n            return Xe(new Y.MissingAPI());\n          }\n          var t2, n2;\n        }, defineClass: function() {\n          return function(e2) {\n            a(this, e2);\n          };\n        }, ignoreTransaction: function(e2) {\n          return me.trans ? $e(me.transless, e2) : e2();\n        }, vip: gn, async: function(t2) {\n          return function() {\n            try {\n              var e2 = Rn(t2.apply(this, arguments));\n              return e2 && "function" == typeof e2.then ? e2 : _e.resolve(e2);\n            } catch (e3) {\n              return Xe(e3);\n            }\n          };\n        }, spawn: function(e2, t2, n2) {\n          try {\n            var r2 = Rn(e2.apply(n2, t2 || []));\n            return r2 && "function" == typeof r2.then ? r2 : _e.resolve(r2);\n          } catch (e3) {\n            return Xe(e3);\n          }\n        }, currentTransaction: { get: function() {\n          return me.trans || null;\n        } }, waitFor: function(e2, t2) {\n          t2 = _e.resolve("function" == typeof e2 ? sr.ignoreTransaction(e2) : e2).timeout(t2 || 6e4);\n          return me.trans ? me.trans.waitFor(t2) : t2;\n        }, Promise: _e, debug: { get: function() {\n          return ie;\n        }, set: function(e2) {\n          oe(e2);\n        } }, derive: o, extend: a, props: r, override: p, Events: mt, on: Ut, liveQuery: ur, extendObservabilitySet: Sn, getByKeyPath: g, setByKeyPath: w, delByKeyPath: function(t2, e2) {\n          "string" == typeof e2 ? w(t2, e2, void 0) : "length" in e2 && [].map.call(e2, function(e3) {\n            w(t2, e3, void 0);\n          });\n        }, shallowClone: k, deepClone: S, getObjectDiff: Nn, cmp: st, asap: v, minKey: -1 / 0, addons: [], connections: et, errnames: z, dependencies: ir, cache: An, semVer: "4.2.1", version: "4.2.1".split(".").map(function(e2) {\n          return parseInt(e2);\n        }).reduce(function(e2, t2, n2) {\n          return e2 + t2 / Math.pow(10, 2 * n2);\n        }) })), sr.maxKey = Qt(sr.dependencies.IDBKeyRange), "undefined" != typeof dispatchEvent && "undefined" != typeof addEventListener && (Ut(Nt, function(e2) {\n          fr || (e2 = new CustomEvent(Lt, { detail: e2 }), fr = true, dispatchEvent(e2), fr = false);\n        }), addEventListener(Lt, function(e2) {\n          e2 = e2.detail;\n          fr || cr(e2);\n        }));\n        var lr, fr = false, hr = function() {\n        };\n        return "undefined" != typeof BroadcastChannel && ((hr = function() {\n          (lr = new BroadcastChannel(Lt)).onmessage = function(e2) {\n            return e2.data && cr(e2.data);\n          };\n        })(), "function" == typeof lr.unref && lr.unref(), Ut(Nt, function(e2) {\n          fr || lr.postMessage(e2);\n        })), "undefined" != typeof addEventListener && (addEventListener("pagehide", function(e2) {\n          if (!nr.disableBfCache && e2.persisted) {\n            ie && console.debug("Dexie: handling persisted pagehide"), null != lr && lr.close();\n            for (var t2 = 0, n2 = et; t2 < n2.length; t2++) n2[t2].close({ disableAutoOpen: false });\n          }\n        }), addEventListener("pageshow", function(e2) {\n          !nr.disableBfCache && e2.persisted && (ie && console.debug("Dexie: handling persisted pageshow"), hr(), cr({ all: new _n(-1 / 0, [[]]) }));\n        })), _e.rejectionMapper = function(e2, t2) {\n          return !e2 || e2 instanceof N || e2 instanceof TypeError || e2 instanceof SyntaxError || !e2.name || !$[e2.name] ? e2 : (t2 = new $[e2.name](t2 || e2.message, e2), "stack" in e2 && l(t2, "stack", { get: function() {\n            return this.inner.stack;\n          } }), t2);\n        }, oe(ie), _(nr, Object.freeze({ __proto__: null, Dexie: nr, liveQuery: ur, Entity: ut, cmp: st, PropModification: ht, replacePrefix: function(e2, t2) {\n          return new ht({ replacePrefix: [e2, t2] });\n        }, add: function(e2) {\n          return new ht({ add: e2 });\n        }, remove: function(e2) {\n          return new ht({ remove: e2 });\n        }, default: nr, RangeSet: _n, mergeRanges: kn, rangesOverlap: On }), { default: nr }), nr;\n      });\n    })(dexie_min$1);\n    return dexie_min$1.exports;\n  }\n  var dexie_minExports = requireDexie_min();\n  var _Dexie = /* @__PURE__ */ getDefaultExportFromCjs(dexie_minExports);\n  const DexieSymbol = /* @__PURE__ */ Symbol.for("Dexie");\n  const Dexie = globalThis[DexieSymbol] || (globalThis[DexieSymbol] = _Dexie);\n  if (_Dexie.semVer !== Dexie.semVer) {\n    throw new Error(`Two different versions of Dexie loaded in the same app: ${_Dexie.semVer} and ${Dexie.semVer}`);\n  }\n  const {\n    liveQuery,\n    mergeRanges,\n    rangesOverlap,\n    RangeSet,\n    cmp,\n    Entity,\n    PropModification,\n    replacePrefix,\n    add,\n    remove,\n    DexieYProvider\n  } = Dexie;\n  const anyMap = /* @__PURE__ */ new WeakMap();\n  const eventsMap = /* @__PURE__ */ new WeakMap();\n  const producersMap = /* @__PURE__ */ new WeakMap();\n  const anyProducer = /* @__PURE__ */ Symbol("anyProducer");\n  const resolvedPromise = Promise.resolve();\n  const listenerAdded = /* @__PURE__ */ Symbol("listenerAdded");\n  const listenerRemoved = /* @__PURE__ */ Symbol("listenerRemoved");\n  let canEmitMetaEvents = false;\n  let isGlobalDebugEnabled = false;\n  const isEventKeyType = (key) => typeof key === "string" || typeof key === "symbol" || typeof key === "number";\n  function assertEventName(eventName) {\n    if (!isEventKeyType(eventName)) {\n      throw new TypeError("`eventName` must be a string, symbol, or number");\n    }\n  }\n  function assertListener(listener) {\n    if (typeof listener !== "function") {\n      throw new TypeError("listener must be a function");\n    }\n  }\n  function getListeners(instance, eventName) {\n    const events = eventsMap.get(instance);\n    if (!events.has(eventName)) {\n      return;\n    }\n    return events.get(eventName);\n  }\n  function getEventProducers(instance, eventName) {\n    const key = isEventKeyType(eventName) ? eventName : anyProducer;\n    const producers = producersMap.get(instance);\n    if (!producers.has(key)) {\n      return;\n    }\n    return producers.get(key);\n  }\n  function enqueueProducers(instance, eventName, eventData) {\n    const producers = producersMap.get(instance);\n    if (producers.has(eventName)) {\n      for (const producer of producers.get(eventName)) {\n        producer.enqueue(eventData);\n      }\n    }\n    if (producers.has(anyProducer)) {\n      const item = Promise.all([eventName, eventData]);\n      for (const producer of producers.get(anyProducer)) {\n        producer.enqueue(item);\n      }\n    }\n  }\n  function iterator(instance, eventNames) {\n    eventNames = Array.isArray(eventNames) ? eventNames : [eventNames];\n    let isFinished = false;\n    let flush = () => {\n    };\n    let queue = [];\n    const producer = {\n      enqueue(item) {\n        queue.push(item);\n        flush();\n      },\n      finish() {\n        isFinished = true;\n        flush();\n      }\n    };\n    for (const eventName of eventNames) {\n      let set2 = getEventProducers(instance, eventName);\n      if (!set2) {\n        set2 = /* @__PURE__ */ new Set();\n        const producers = producersMap.get(instance);\n        producers.set(eventName, set2);\n      }\n      set2.add(producer);\n    }\n    return {\n      async next() {\n        if (!queue) {\n          return { done: true };\n        }\n        if (queue.length === 0) {\n          if (isFinished) {\n            queue = void 0;\n            return this.next();\n          }\n          await new Promise((resolve) => {\n            flush = resolve;\n          });\n          return this.next();\n        }\n        return {\n          done: false,\n          value: await queue.shift()\n        };\n      },\n      async return(value) {\n        queue = void 0;\n        for (const eventName of eventNames) {\n          const set2 = getEventProducers(instance, eventName);\n          if (set2) {\n            set2.delete(producer);\n            if (set2.size === 0) {\n              const producers = producersMap.get(instance);\n              producers.delete(eventName);\n            }\n          }\n        }\n        flush();\n        return arguments.length > 0 ? { done: true, value: await value } : { done: true };\n      },\n      [Symbol.asyncIterator]() {\n        return this;\n      }\n    };\n  }\n  function defaultMethodNamesOrAssert(methodNames) {\n    if (methodNames === void 0) {\n      return allEmitteryMethods;\n    }\n    if (!Array.isArray(methodNames)) {\n      throw new TypeError("`methodNames` must be an array of strings");\n    }\n    for (const methodName of methodNames) {\n      if (!allEmitteryMethods.includes(methodName)) {\n        if (typeof methodName !== "string") {\n          throw new TypeError("`methodNames` element must be a string");\n        }\n        throw new Error(`${methodName} is not Emittery method`);\n      }\n    }\n    return methodNames;\n  }\n  const isMetaEvent = (eventName) => eventName === listenerAdded || eventName === listenerRemoved;\n  function emitMetaEvent(emitter, eventName, eventData) {\n    if (!isMetaEvent(eventName)) {\n      return;\n    }\n    try {\n      canEmitMetaEvents = true;\n      emitter.emit(eventName, eventData);\n    } finally {\n      canEmitMetaEvents = false;\n    }\n  }\n  class Emittery {\n    static mixin(emitteryPropertyName, methodNames) {\n      methodNames = defaultMethodNamesOrAssert(methodNames);\n      return (target) => {\n        if (typeof target !== "function") {\n          throw new TypeError("`target` must be function");\n        }\n        for (const methodName of methodNames) {\n          if (target.prototype[methodName] !== void 0) {\n            throw new Error(`The property \\`${methodName}\\` already exists on \\`target\\``);\n          }\n        }\n        function getEmitteryProperty() {\n          Object.defineProperty(this, emitteryPropertyName, {\n            enumerable: false,\n            value: new Emittery()\n          });\n          return this[emitteryPropertyName];\n        }\n        Object.defineProperty(target.prototype, emitteryPropertyName, {\n          enumerable: false,\n          get: getEmitteryProperty\n        });\n        const emitteryMethodCaller = (methodName) => function(...args) {\n          return this[emitteryPropertyName][methodName](...args);\n        };\n        for (const methodName of methodNames) {\n          Object.defineProperty(target.prototype, methodName, {\n            enumerable: false,\n            value: emitteryMethodCaller(methodName)\n          });\n        }\n        return target;\n      };\n    }\n    static get isDebugEnabled() {\n      if (typeof globalThis.process?.env !== "object") {\n        return isGlobalDebugEnabled;\n      }\n      const { env } = globalThis.process ?? { env: {} };\n      return env.DEBUG === "emittery" || env.DEBUG === "*" || isGlobalDebugEnabled;\n    }\n    static set isDebugEnabled(newValue) {\n      isGlobalDebugEnabled = newValue;\n    }\n    constructor(options2 = {}) {\n      anyMap.set(this, /* @__PURE__ */ new Set());\n      eventsMap.set(this, /* @__PURE__ */ new Map());\n      producersMap.set(this, /* @__PURE__ */ new Map());\n      producersMap.get(this).set(anyProducer, /* @__PURE__ */ new Set());\n      this.debug = options2.debug ?? {};\n      if (this.debug.enabled === void 0) {\n        this.debug.enabled = false;\n      }\n      if (!this.debug.logger) {\n        this.debug.logger = (type2, debugName, eventName, eventData) => {\n          try {\n            eventData = JSON.stringify(eventData);\n          } catch {\n            eventData = `Object with the following keys failed to stringify: ${Object.keys(eventData).join(",")}`;\n          }\n          if (typeof eventName === "symbol" || typeof eventName === "number") {\n            eventName = eventName.toString();\n          }\n          const currentTime = /* @__PURE__ */ new Date();\n          const logTime = `${currentTime.getHours()}:${currentTime.getMinutes()}:${currentTime.getSeconds()}.${currentTime.getMilliseconds()}`;\n          console.log(`[${logTime}][emittery:${type2}][${debugName}] Event Name: ${eventName}\n	data: ${eventData}`);\n        };\n      }\n    }\n    logIfDebugEnabled(type2, eventName, eventData) {\n      if (Emittery.isDebugEnabled || this.debug.enabled) {\n        this.debug.logger(type2, this.debug.name, eventName, eventData);\n      }\n    }\n    on(eventNames, listener, { signal } = {}) {\n      assertListener(listener);\n      eventNames = Array.isArray(eventNames) ? eventNames : [eventNames];\n      for (const eventName of eventNames) {\n        assertEventName(eventName);\n        let set2 = getListeners(this, eventName);\n        if (!set2) {\n          set2 = /* @__PURE__ */ new Set();\n          const events = eventsMap.get(this);\n          events.set(eventName, set2);\n        }\n        set2.add(listener);\n        this.logIfDebugEnabled("subscribe", eventName, void 0);\n        if (!isMetaEvent(eventName)) {\n          emitMetaEvent(this, listenerAdded, { eventName, listener });\n        }\n      }\n      const off = () => {\n        this.off(eventNames, listener);\n        signal?.removeEventListener("abort", off);\n      };\n      signal?.addEventListener("abort", off, { once: true });\n      if (signal?.aborted) {\n        off();\n      }\n      return off;\n    }\n    off(eventNames, listener) {\n      assertListener(listener);\n      eventNames = Array.isArray(eventNames) ? eventNames : [eventNames];\n      for (const eventName of eventNames) {\n        assertEventName(eventName);\n        const set2 = getListeners(this, eventName);\n        if (set2) {\n          set2.delete(listener);\n          if (set2.size === 0) {\n            const events = eventsMap.get(this);\n            events.delete(eventName);\n          }\n        }\n        this.logIfDebugEnabled("unsubscribe", eventName, void 0);\n        if (!isMetaEvent(eventName)) {\n          emitMetaEvent(this, listenerRemoved, { eventName, listener });\n        }\n      }\n    }\n    once(eventNames, predicate) {\n      if (predicate !== void 0 && typeof predicate !== "function") {\n        throw new TypeError("predicate must be a function");\n      }\n      let off_;\n      const promise = new Promise((resolve) => {\n        off_ = this.on(eventNames, (data) => {\n          if (predicate && !predicate(data)) {\n            return;\n          }\n          off_();\n          resolve(data);\n        });\n      });\n      promise.off = off_;\n      return promise;\n    }\n    events(eventNames) {\n      eventNames = Array.isArray(eventNames) ? eventNames : [eventNames];\n      for (const eventName of eventNames) {\n        assertEventName(eventName);\n      }\n      return iterator(this, eventNames);\n    }\n    async emit(eventName, eventData) {\n      assertEventName(eventName);\n      if (isMetaEvent(eventName) && !canEmitMetaEvents) {\n        throw new TypeError("`eventName` cannot be meta event `listenerAdded` or `listenerRemoved`");\n      }\n      this.logIfDebugEnabled("emit", eventName, eventData);\n      enqueueProducers(this, eventName, eventData);\n      const listeners = getListeners(this, eventName) ?? /* @__PURE__ */ new Set();\n      const anyListeners = anyMap.get(this);\n      const staticListeners = [...listeners];\n      const staticAnyListeners = isMetaEvent(eventName) ? [] : [...anyListeners];\n      await resolvedPromise;\n      await Promise.all([\n        ...staticListeners.map(async (listener) => {\n          if (listeners.has(listener)) {\n            return listener(eventData);\n          }\n        }),\n        ...staticAnyListeners.map(async (listener) => {\n          if (anyListeners.has(listener)) {\n            return listener(eventName, eventData);\n          }\n        })\n      ]);\n    }\n    async emitSerial(eventName, eventData) {\n      assertEventName(eventName);\n      if (isMetaEvent(eventName) && !canEmitMetaEvents) {\n        throw new TypeError("`eventName` cannot be meta event `listenerAdded` or `listenerRemoved`");\n      }\n      this.logIfDebugEnabled("emitSerial", eventName, eventData);\n      const listeners = getListeners(this, eventName) ?? /* @__PURE__ */ new Set();\n      const anyListeners = anyMap.get(this);\n      const staticListeners = [...listeners];\n      const staticAnyListeners = [...anyListeners];\n      await resolvedPromise;\n      for (const listener of staticListeners) {\n        if (listeners.has(listener)) {\n          await listener(eventData);\n        }\n      }\n      for (const listener of staticAnyListeners) {\n        if (anyListeners.has(listener)) {\n          await listener(eventName, eventData);\n        }\n      }\n    }\n    onAny(listener, { signal } = {}) {\n      assertListener(listener);\n      this.logIfDebugEnabled("subscribeAny", void 0, void 0);\n      anyMap.get(this).add(listener);\n      emitMetaEvent(this, listenerAdded, { listener });\n      const offAny = () => {\n        this.offAny(listener);\n        signal?.removeEventListener("abort", offAny);\n      };\n      signal?.addEventListener("abort", offAny, { once: true });\n      if (signal?.aborted) {\n        offAny();\n      }\n      return offAny;\n    }\n    anyEvent() {\n      return iterator(this);\n    }\n    offAny(listener) {\n      assertListener(listener);\n      this.logIfDebugEnabled("unsubscribeAny", void 0, void 0);\n      emitMetaEvent(this, listenerRemoved, { listener });\n      anyMap.get(this).delete(listener);\n    }\n    clearListeners(eventNames) {\n      eventNames = Array.isArray(eventNames) ? eventNames : [eventNames];\n      for (const eventName of eventNames) {\n        this.logIfDebugEnabled("clear", eventName, void 0);\n        if (isEventKeyType(eventName)) {\n          const set2 = getListeners(this, eventName);\n          if (set2) {\n            set2.clear();\n          }\n          const producers = getEventProducers(this, eventName);\n          if (producers) {\n            for (const producer of producers) {\n              producer.finish();\n            }\n            producers.clear();\n          }\n        } else {\n          anyMap.get(this).clear();\n          for (const [eventName2, listeners] of eventsMap.get(this).entries()) {\n            listeners.clear();\n            eventsMap.get(this).delete(eventName2);\n          }\n          for (const [eventName2, producers] of producersMap.get(this).entries()) {\n            for (const producer of producers) {\n              producer.finish();\n            }\n            producers.clear();\n            producersMap.get(this).delete(eventName2);\n          }\n        }\n      }\n    }\n    listenerCount(eventNames) {\n      eventNames = Array.isArray(eventNames) ? eventNames : [eventNames];\n      let count = 0;\n      for (const eventName of eventNames) {\n        if (isEventKeyType(eventName)) {\n          count += anyMap.get(this).size + (getListeners(this, eventName)?.size ?? 0) + (getEventProducers(this, eventName)?.size ?? 0) + (getEventProducers(this)?.size ?? 0);\n          continue;\n        }\n        if (eventName !== void 0) {\n          assertEventName(eventName);\n        }\n        count += anyMap.get(this).size;\n        for (const value of eventsMap.get(this).values()) {\n          count += value.size;\n        }\n        for (const value of producersMap.get(this).values()) {\n          count += value.size;\n        }\n      }\n      return count;\n    }\n    bindMethods(target, methodNames) {\n      if (typeof target !== "object" || target === null) {\n        throw new TypeError("`target` must be an object");\n      }\n      methodNames = defaultMethodNamesOrAssert(methodNames);\n      for (const methodName of methodNames) {\n        if (target[methodName] !== void 0) {\n          throw new Error(`The property \\`${methodName}\\` already exists on \\`target\\``);\n        }\n        Object.defineProperty(target, methodName, {\n          enumerable: false,\n          value: this[methodName].bind(this)\n        });\n      }\n    }\n  }\n  const allEmitteryMethods = Object.getOwnPropertyNames(Emittery.prototype).filter((v) => v !== "constructor");\n  Object.defineProperty(Emittery, "listenerAdded", {\n    value: listenerAdded,\n    writable: false,\n    enumerable: true,\n    configurable: false\n  });\n  Object.defineProperty(Emittery, "listenerRemoved", {\n    value: listenerRemoved,\n    writable: false,\n    enumerable: true,\n    configurable: false\n  });\n  const Logger = {\n    log(...args) {\n      console.log(...args);\n    },\n    info(...args) {\n      console.info(...args);\n    },\n    warn(...args) {\n      console.warn(...args);\n    },\n    error(...args) {\n      console.error(...args);\n    },\n    debug(...args) {\n      console.debug(...args);\n    },\n    trace(...args) {\n      console.trace(...args);\n    },\n    assert(condition, ...args) {\n      console.assert(condition, ...args);\n    }\n  };\n  class TaskDatabase extends Emittery {\n    db;\n    isInitialized = false;\n    /**\n     * Create a new database service instance\n     */\n    constructor(appId) {\n      super();\n      this.db = new Dexie("TaskTrackDB:" + appId, {});\n      this.db.version(1).stores({\n        tasks: "&id,path,status,priority,createdAt,updatedAt,dueDate"\n      });\n      this.initialize().catch((err) => {\n        Logger.error("Error initializing database:", err);\n      });\n    }\n    /**\n     * Initialize the database and set up observers\n     */\n    async initialize() {\n      try {\n        await this.db.open();\n        this.isInitialized = true;\n        Logger.log(`TaskDatabase ${this.db.name} initialized successfully`);\n      } catch (error) {\n        Logger.error("Failed to initialize DexieTaskDatabase:", error);\n        this.isInitialized = false;\n      }\n    }\n    /**\n     * Clear database\n     */\n    async clearDatabase() {\n      await this.db.delete();\n      await this.db.open();\n    }\n    /**\n     * Get task count from the database\n     */\n    async getAllTaskCount() {\n      if (!this.isInitialized) {\n        await this.initialize();\n      }\n      try {\n        return await this.db.table("tasks").count();\n      } catch (error) {\n        Logger.error("Error getting all tasks:", error);\n        return 0;\n      }\n    }\n    /**\n     * Get all tasks from the database\n     */\n    async getAllTasks(filters = { statuses: [], keywords: [], files: [] }) {\n      if (!this.isInitialized) {\n        await this.initialize();\n      }\n      try {\n        let query = this.db.table("tasks");\n        if (filters.statuses?.length) {\n          query = query.where("status").anyOf(filters.statuses);\n        }\n        let results = await query.toArray();\n        if (filters.keywords?.length) {\n          const matchers = filters.keywords.map(\n            (kw) => new RegExp(kw.replace(/[.*+?^${}()|[\\]\\\\]/g, "\\\\$&"), "i")\n          );\n          results = results.filter(\n            (row) => matchers.every((regex) => regex.test(row.title))\n          );\n        }\n        if (filters.files?.length) {\n          const matchers = filters.files.map(\n            (kw) => new RegExp(kw.replace(/[.*+?^${}()|[\\]\\\\]/g, "\\\\$&"), "i")\n          );\n          results = results.filter(\n            (row) => matchers.every((regex) => regex.test(row.path))\n          );\n        }\n        return results;\n      } catch (error) {\n        Logger.error("Error getting all tasks:", error);\n        return [];\n      }\n    }\n    /**\n     * Add a new task to the database\n     */\n    async addTask(task) {\n      if (!this.isInitialized) {\n        await this.initialize();\n      }\n      try {\n        await this.db.table("tasks").put(task);\n        await this.emit("task-created", task);\n        return task;\n      } catch (error) {\n        Logger.error("Error adding task:", error);\n        throw error;\n      }\n    }\n    /**\n     * Add multiple tasks to the database\n     */\n    async addTasks(tasks) {\n      if (!this.isInitialized) {\n        await this.initialize();\n      }\n      try {\n        await this.db.table("tasks").bulkPut(tasks);\n        for (const task of tasks) {\n          await this.emit("task-created", task);\n        }\n        return tasks;\n      } catch (error) {\n        Logger.error("Error adding task:", error);\n        throw error;\n      }\n    }\n    /**\n     * Add multiple tasks to the database\n     */\n    async clearTasksByPath(path) {\n      if (!this.isInitialized) {\n        await this.initialize();\n      }\n      try {\n        await this.db.table("tasks").where("path").equals(path).delete();\n      } catch (error) {\n        Logger.error("Error adding task:", error);\n        throw error;\n      }\n    }\n    /**\n     * Update an existing task\n     */\n    async updateTask(task) {\n      if (!this.isInitialized) {\n        await this.initialize();\n      }\n      try {\n        await this.db.table("tasks").put(task);\n        await this.emit("task-updated", task);\n        return task;\n      } catch (error) {\n        Logger.error("Error updating task:", error);\n        throw error;\n      }\n    }\n    /**\n     * Delete a task from the database\n     */\n    async deleteTask(taskId) {\n      if (!this.isInitialized) {\n        await this.initialize();\n      }\n      try {\n        const task = await this.db.table("tasks").get(taskId);\n        if (!task) return false;\n        await this.db.table("tasks").delete(taskId);\n        await this.emit("task-deleted", taskId);\n        return true;\n      } catch (error) {\n        Logger.error("Error deleting task:", error);\n        return false;\n      }\n    }\n    /**\n     * Close the database connection\n     */\n    close() {\n      if (this.db.isOpen()) {\n        this.db.close();\n      }\n    }\n  }\n  function parseTaskPriority(input) {\n    return /^(wish|low|none|medium|high|critical)$/.test(input) ? input : null;\n  }\n  const taskStatusFormat = {\n    none: [" "],\n    planned: ["?"],\n    "in-progress": [">", "/"],\n    review: ["="],\n    abandoned: ["-"],\n    closed: ["x", "X"]\n  };\n  function parseTaskStatusMarker(input) {\n    return Object.entries(taskStatusFormat).map(([key, values]) => {\n      return values.find((value) => value === input) ? key : null;\n    }).find((key) => key != null) ?? null;\n  }\n  const emptyOptions = {};\n  function toString(value, options2) {\n    const settings = emptyOptions;\n    const includeImageAlt = typeof settings.includeImageAlt === "boolean" ? settings.includeImageAlt : true;\n    const includeHtml = typeof settings.includeHtml === "boolean" ? settings.includeHtml : true;\n    return one(value, includeImageAlt, includeHtml);\n  }\n  function one(value, includeImageAlt, includeHtml) {\n    if (node(value)) {\n      if ("value" in value) {\n        return value.type === "html" && !includeHtml ? "" : value.value;\n      }\n      if (includeImageAlt && "alt" in value && value.alt) {\n        return value.alt;\n      }\n      if ("children" in value) {\n        return all(value.children, includeImageAlt, includeHtml);\n      }\n    }\n    if (Array.isArray(value)) {\n      return all(value, includeImageAlt, includeHtml);\n    }\n    return "";\n  }\n  function all(values, includeImageAlt, includeHtml) {\n    const result = [];\n    let index2 = -1;\n    while (++index2 < values.length) {\n      result[index2] = one(values[index2], includeImageAlt, includeHtml);\n    }\n    return result.join("");\n  }\n  function node(value) {\n    return Boolean(value && typeof value === "object");\n  }\n  const characterEntities = {\n    AElig: "Ã†",\n    AMP: "&",\n    Aacute: "Ã",\n    Abreve: "Ä‚",\n    Acirc: "Ã‚",\n    Acy: "Ð",\n    Afr: "ð”„",\n    Agrave: "Ã€",\n    Alpha: "Î‘",\n    Amacr: "Ä€",\n    And: "â©“",\n    Aogon: "Ä„",\n    Aopf: "ð”¸",\n    ApplyFunction: "â¡",\n    Aring: "Ã…",\n    Ascr: "ð’œ",\n    Assign: "â‰”",\n    Atilde: "Ãƒ",\n    Auml: "Ã„",\n    Backslash: "âˆ–",\n    Barv: "â«§",\n    Barwed: "âŒ†",\n    Bcy: "Ð‘",\n    Because: "âˆµ",\n    Bernoullis: "â„¬",\n    Beta: "Î’",\n    Bfr: "ð”…",\n    Bopf: "ð”¹",\n    Breve: "Ë˜",\n    Bscr: "â„¬",\n    Bumpeq: "â‰Ž",\n    CHcy: "Ð§",\n    COPY: "Â©",\n    Cacute: "Ä†",\n    Cap: "â‹’",\n    CapitalDifferentialD: "â……",\n    Cayleys: "â„­",\n    Ccaron: "ÄŒ",\n    Ccedil: "Ã‡",\n    Ccirc: "Äˆ",\n    Cconint: "âˆ°",\n    Cdot: "ÄŠ",\n    Cedilla: "Â¸",\n    CenterDot: "Â·",\n    Cfr: "â„­",\n    Chi: "Î§",\n    CircleDot: "âŠ™",\n    CircleMinus: "âŠ–",\n    CirclePlus: "âŠ•",\n    CircleTimes: "âŠ—",\n    ClockwiseContourIntegral: "âˆ²",\n    CloseCurlyDoubleQuote: "â€",\n    CloseCurlyQuote: "â€™",\n    Colon: "âˆ·",\n    Colone: "â©´",\n    Congruent: "â‰¡",\n    Conint: "âˆ¯",\n    ContourIntegral: "âˆ®",\n    Copf: "â„‚",\n    Coproduct: "âˆ",\n    CounterClockwiseContourIntegral: "âˆ³",\n    Cross: "â¨¯",\n    Cscr: "ð’ž",\n    Cup: "â‹“",\n    CupCap: "â‰",\n    DD: "â……",\n    DDotrahd: "â¤‘",\n    DJcy: "Ð‚",\n    DScy: "Ð…",\n    DZcy: "Ð",\n    Dagger: "â€¡",\n    Darr: "â†¡",\n    Dashv: "â«¤",\n    Dcaron: "ÄŽ",\n    Dcy: "Ð”",\n    Del: "âˆ‡",\n    Delta: "Î”",\n    Dfr: "ð”‡",\n    DiacriticalAcute: "Â´",\n    DiacriticalDot: "Ë™",\n    DiacriticalDoubleAcute: "Ë",\n    DiacriticalGrave: "`",\n    DiacriticalTilde: "Ëœ",\n    Diamond: "â‹„",\n    DifferentialD: "â…†",\n    Dopf: "ð”»",\n    Dot: "Â¨",\n    DotDot: "âƒœ",\n    DotEqual: "â‰",\n    DoubleContourIntegral: "âˆ¯",\n    DoubleDot: "Â¨",\n    DoubleDownArrow: "â‡“",\n    DoubleLeftArrow: "â‡",\n    DoubleLeftRightArrow: "â‡”",\n    DoubleLeftTee: "â«¤",\n    DoubleLongLeftArrow: "âŸ¸",\n    DoubleLongLeftRightArrow: "âŸº",\n    DoubleLongRightArrow: "âŸ¹",\n    DoubleRightArrow: "â‡’",\n    DoubleRightTee: "âŠ¨",\n    DoubleUpArrow: "â‡‘",\n    DoubleUpDownArrow: "â‡•",\n    DoubleVerticalBar: "âˆ¥",\n    DownArrow: "â†“",\n    DownArrowBar: "â¤“",\n    DownArrowUpArrow: "â‡µ",\n    DownBreve: "Ì‘",\n    DownLeftRightVector: "â¥",\n    DownLeftTeeVector: "â¥ž",\n    DownLeftVector: "â†½",\n    DownLeftVectorBar: "â¥–",\n    DownRightTeeVector: "â¥Ÿ",\n    DownRightVector: "â‡",\n    DownRightVectorBar: "â¥—",\n    DownTee: "âŠ¤",\n    DownTeeArrow: "â†§",\n    Downarrow: "â‡“",\n    Dscr: "ð’Ÿ",\n    Dstrok: "Ä",\n    ENG: "ÅŠ",\n    ETH: "Ã",\n    Eacute: "Ã‰",\n    Ecaron: "Äš",\n    Ecirc: "ÃŠ",\n    Ecy: "Ð­",\n    Edot: "Ä–",\n    Efr: "ð”ˆ",\n    Egrave: "Ãˆ",\n    Element: "âˆˆ",\n    Emacr: "Ä’",\n    EmptySmallSquare: "â—»",\n    EmptyVerySmallSquare: "â–«",\n    Eogon: "Ä˜",\n    Eopf: "ð”¼",\n    Epsilon: "Î•",\n    Equal: "â©µ",\n    EqualTilde: "â‰‚",\n    Equilibrium: "â‡Œ",\n    Escr: "â„°",\n    Esim: "â©³",\n    Eta: "Î—",\n    Euml: "Ã‹",\n    Exists: "âˆƒ",\n    ExponentialE: "â…‡",\n    Fcy: "Ð¤",\n    Ffr: "ð”‰",\n    FilledSmallSquare: "â—¼",\n    FilledVerySmallSquare: "â–ª",\n    Fopf: "ð”½",\n    ForAll: "âˆ€",\n    Fouriertrf: "â„±",\n    Fscr: "â„±",\n    GJcy: "Ðƒ",\n    GT: ">",\n    Gamma: "Î“",\n    Gammad: "Ïœ",\n    Gbreve: "Äž",\n    Gcedil: "Ä¢",\n    Gcirc: "Äœ",\n    Gcy: "Ð“",\n    Gdot: "Ä ",\n    Gfr: "ð”Š",\n    Gg: "â‹™",\n    Gopf: "ð”¾",\n    GreaterEqual: "â‰¥",\n    GreaterEqualLess: "â‹›",\n    GreaterFullEqual: "â‰§",\n    GreaterGreater: "âª¢",\n    GreaterLess: "â‰·",\n    GreaterSlantEqual: "â©¾",\n    GreaterTilde: "â‰³",\n    Gscr: "ð’¢",\n    Gt: "â‰«",\n    HARDcy: "Ðª",\n    Hacek: "Ë‡",\n    Hat: "^",\n    Hcirc: "Ä¤",\n    Hfr: "â„Œ",\n    HilbertSpace: "â„‹",\n    Hopf: "â„",\n    HorizontalLine: "â”€",\n    Hscr: "â„‹",\n    Hstrok: "Ä¦",\n    HumpDownHump: "â‰Ž",\n    HumpEqual: "â‰",\n    IEcy: "Ð•",\n    IJlig: "Ä²",\n    IOcy: "Ð",\n    Iacute: "Ã",\n    Icirc: "ÃŽ",\n    Icy: "Ð˜",\n    Idot: "Ä°",\n    Ifr: "â„‘",\n    Igrave: "ÃŒ",\n    Im: "â„‘",\n    Imacr: "Äª",\n    ImaginaryI: "â…ˆ",\n    Implies: "â‡’",\n    Int: "âˆ¬",\n    Integral: "âˆ«",\n    Intersection: "â‹‚",\n    InvisibleComma: "â£",\n    InvisibleTimes: "â¢",\n    Iogon: "Ä®",\n    Iopf: "ð•€",\n    Iota: "Î™",\n    Iscr: "â„",\n    Itilde: "Ä¨",\n    Iukcy: "Ð†",\n    Iuml: "Ã",\n    Jcirc: "Ä´",\n    Jcy: "Ð™",\n    Jfr: "ð”",\n    Jopf: "ð•",\n    Jscr: "ð’¥",\n    Jsercy: "Ðˆ",\n    Jukcy: "Ð„",\n    KHcy: "Ð¥",\n    KJcy: "ÐŒ",\n    Kappa: "Îš",\n    Kcedil: "Ä¶",\n    Kcy: "Ðš",\n    Kfr: "ð”Ž",\n    Kopf: "ð•‚",\n    Kscr: "ð’¦",\n    LJcy: "Ð‰",\n    LT: "<",\n    Lacute: "Ä¹",\n    Lambda: "Î›",\n    Lang: "âŸª",\n    Laplacetrf: "â„’",\n    Larr: "â†ž",\n    Lcaron: "Ä½",\n    Lcedil: "Ä»",\n    Lcy: "Ð›",\n    LeftAngleBracket: "âŸ¨",\n    LeftArrow: "â†",\n    LeftArrowBar: "â‡¤",\n    LeftArrowRightArrow: "â‡†",\n    LeftCeiling: "âŒˆ",\n    LeftDoubleBracket: "âŸ¦",\n    LeftDownTeeVector: "â¥¡",\n    LeftDownVector: "â‡ƒ",\n    LeftDownVectorBar: "â¥™",\n    LeftFloor: "âŒŠ",\n    LeftRightArrow: "â†”",\n    LeftRightVector: "â¥Ž",\n    LeftTee: "âŠ£",\n    LeftTeeArrow: "â†¤",\n    LeftTeeVector: "â¥š",\n    LeftTriangle: "âŠ²",\n    LeftTriangleBar: "â§",\n    LeftTriangleEqual: "âŠ´",\n    LeftUpDownVector: "â¥‘",\n    LeftUpTeeVector: "â¥ ",\n    LeftUpVector: "â†¿",\n    LeftUpVectorBar: "â¥˜",\n    LeftVector: "â†¼",\n    LeftVectorBar: "â¥’",\n    Leftarrow: "â‡",\n    Leftrightarrow: "â‡”",\n    LessEqualGreater: "â‹š",\n    LessFullEqual: "â‰¦",\n    LessGreater: "â‰¶",\n    LessLess: "âª¡",\n    LessSlantEqual: "â©½",\n    LessTilde: "â‰²",\n    Lfr: "ð”",\n    Ll: "â‹˜",\n    Lleftarrow: "â‡š",\n    Lmidot: "Ä¿",\n    LongLeftArrow: "âŸµ",\n    LongLeftRightArrow: "âŸ·",\n    LongRightArrow: "âŸ¶",\n    Longleftarrow: "âŸ¸",\n    Longleftrightarrow: "âŸº",\n    Longrightarrow: "âŸ¹",\n    Lopf: "ð•ƒ",\n    LowerLeftArrow: "â†™",\n    LowerRightArrow: "â†˜",\n    Lscr: "â„’",\n    Lsh: "â†°",\n    Lstrok: "Å",\n    Lt: "â‰ª",\n    Map: "â¤…",\n    Mcy: "Ðœ",\n    MediumSpace: "âŸ",\n    Mellintrf: "â„³",\n    Mfr: "ð”",\n    MinusPlus: "âˆ“",\n    Mopf: "ð•„",\n    Mscr: "â„³",\n    Mu: "Îœ",\n    NJcy: "ÐŠ",\n    Nacute: "Åƒ",\n    Ncaron: "Å‡",\n    Ncedil: "Å…",\n    Ncy: "Ð",\n    NegativeMediumSpace: "â€‹",\n    NegativeThickSpace: "â€‹",\n    NegativeThinSpace: "â€‹",\n    NegativeVeryThinSpace: "â€‹",\n    NestedGreaterGreater: "â‰«",\n    NestedLessLess: "â‰ª",\n    NewLine: "\\n",\n    Nfr: "ð”‘",\n    NoBreak: "â ",\n    NonBreakingSpace: "Â ",\n    Nopf: "â„•",\n    Not: "â«¬",\n    NotCongruent: "â‰¢",\n    NotCupCap: "â‰­",\n    NotDoubleVerticalBar: "âˆ¦",\n    NotElement: "âˆ‰",\n    NotEqual: "â‰ ",\n    NotEqualTilde: "â‰‚Ì¸",\n    NotExists: "âˆ„",\n    NotGreater: "â‰¯",\n    NotGreaterEqual: "â‰±",\n    NotGreaterFullEqual: "â‰§Ì¸",\n    NotGreaterGreater: "â‰«Ì¸",\n    NotGreaterLess: "â‰¹",\n    NotGreaterSlantEqual: "â©¾Ì¸",\n    NotGreaterTilde: "â‰µ",\n    NotHumpDownHump: "â‰ŽÌ¸",\n    NotHumpEqual: "â‰Ì¸",\n    NotLeftTriangle: "â‹ª",\n    NotLeftTriangleBar: "â§Ì¸",\n    NotLeftTriangleEqual: "â‹¬",\n    NotLess: "â‰®",\n    NotLessEqual: "â‰°",\n    NotLessGreater: "â‰¸",\n    NotLessLess: "â‰ªÌ¸",\n    NotLessSlantEqual: "â©½Ì¸",\n    NotLessTilde: "â‰´",\n    NotNestedGreaterGreater: "âª¢Ì¸",\n    NotNestedLessLess: "âª¡Ì¸",\n    NotPrecedes: "âŠ€",\n    NotPrecedesEqual: "âª¯Ì¸",\n    NotPrecedesSlantEqual: "â‹ ",\n    NotReverseElement: "âˆŒ",\n    NotRightTriangle: "â‹«",\n    NotRightTriangleBar: "â§Ì¸",\n    NotRightTriangleEqual: "â‹­",\n    NotSquareSubset: "âŠÌ¸",\n    NotSquareSubsetEqual: "â‹¢",\n    NotSquareSuperset: "âŠÌ¸",\n    NotSquareSupersetEqual: "â‹£",\n    NotSubset: "âŠ‚âƒ’",\n    NotSubsetEqual: "âŠˆ",\n    NotSucceeds: "âŠ",\n    NotSucceedsEqual: "âª°Ì¸",\n    NotSucceedsSlantEqual: "â‹¡",\n    NotSucceedsTilde: "â‰¿Ì¸",\n    NotSuperset: "âŠƒâƒ’",\n    NotSupersetEqual: "âŠ‰",\n    NotTilde: "â‰",\n    NotTildeEqual: "â‰„",\n    NotTildeFullEqual: "â‰‡",\n    NotTildeTilde: "â‰‰",\n    NotVerticalBar: "âˆ¤",\n    Nscr: "ð’©",\n    Ntilde: "Ã‘",\n    Nu: "Î",\n    OElig: "Å’",\n    Oacute: "Ã“",\n    Ocirc: "Ã”",\n    Ocy: "Ðž",\n    Odblac: "Å",\n    Ofr: "ð”’",\n    Ograve: "Ã’",\n    Omacr: "ÅŒ",\n    Omega: "Î©",\n    Omicron: "ÎŸ",\n    Oopf: "ð•†",\n    OpenCurlyDoubleQuote: "â€œ",\n    OpenCurlyQuote: "â€˜",\n    Or: "â©”",\n    Oscr: "ð’ª",\n    Oslash: "Ã˜",\n    Otilde: "Ã•",\n    Otimes: "â¨·",\n    Ouml: "Ã–",\n    OverBar: "â€¾",\n    OverBrace: "âž",\n    OverBracket: "âŽ´",\n    OverParenthesis: "âœ",\n    PartialD: "âˆ‚",\n    Pcy: "ÐŸ",\n    Pfr: "ð”“",\n    Phi: "Î¦",\n    Pi: "Î ",\n    PlusMinus: "Â±",\n    Poincareplane: "â„Œ",\n    Popf: "â„™",\n    Pr: "âª»",\n    Precedes: "â‰º",\n    PrecedesEqual: "âª¯",\n    PrecedesSlantEqual: "â‰¼",\n    PrecedesTilde: "â‰¾",\n    Prime: "â€³",\n    Product: "âˆ",\n    Proportion: "âˆ·",\n    Proportional: "âˆ",\n    Pscr: "ð’«",\n    Psi: "Î¨",\n    QUOT: \'"\',\n    Qfr: "ð””",\n    Qopf: "â„š",\n    Qscr: "ð’¬",\n    RBarr: "â¤",\n    REG: "Â®",\n    Racute: "Å”",\n    Rang: "âŸ«",\n    Rarr: "â† ",\n    Rarrtl: "â¤–",\n    Rcaron: "Å˜",\n    Rcedil: "Å–",\n    Rcy: "Ð ",\n    Re: "â„œ",\n    ReverseElement: "âˆ‹",\n    ReverseEquilibrium: "â‡‹",\n    ReverseUpEquilibrium: "â¥¯",\n    Rfr: "â„œ",\n    Rho: "Î¡",\n    RightAngleBracket: "âŸ©",\n    RightArrow: "â†’",\n    RightArrowBar: "â‡¥",\n    RightArrowLeftArrow: "â‡„",\n    RightCeiling: "âŒ‰",\n    RightDoubleBracket: "âŸ§",\n    RightDownTeeVector: "â¥",\n    RightDownVector: "â‡‚",\n    RightDownVectorBar: "â¥•",\n    RightFloor: "âŒ‹",\n    RightTee: "âŠ¢",\n    RightTeeArrow: "â†¦",\n    RightTeeVector: "â¥›",\n    RightTriangle: "âŠ³",\n    RightTriangleBar: "â§",\n    RightTriangleEqual: "âŠµ",\n    RightUpDownVector: "â¥",\n    RightUpTeeVector: "â¥œ",\n    RightUpVector: "â†¾",\n    RightUpVectorBar: "â¥”",\n    RightVector: "â‡€",\n    RightVectorBar: "â¥“",\n    Rightarrow: "â‡’",\n    Ropf: "â„",\n    RoundImplies: "â¥°",\n    Rrightarrow: "â‡›",\n    Rscr: "â„›",\n    Rsh: "â†±",\n    RuleDelayed: "â§´",\n    SHCHcy: "Ð©",\n    SHcy: "Ð¨",\n    SOFTcy: "Ð¬",\n    Sacute: "Åš",\n    Sc: "âª¼",\n    Scaron: "Å ",\n    Scedil: "Åž",\n    Scirc: "Åœ",\n    Scy: "Ð¡",\n    Sfr: "ð”–",\n    ShortDownArrow: "â†“",\n    ShortLeftArrow: "â†",\n    ShortRightArrow: "â†’",\n    ShortUpArrow: "â†‘",\n    Sigma: "Î£",\n    SmallCircle: "âˆ˜",\n    Sopf: "ð•Š",\n    Sqrt: "âˆš",\n    Square: "â–¡",\n    SquareIntersection: "âŠ“",\n    SquareSubset: "âŠ",\n    SquareSubsetEqual: "âŠ‘",\n    SquareSuperset: "âŠ",\n    SquareSupersetEqual: "âŠ’",\n    SquareUnion: "âŠ”",\n    Sscr: "ð’®",\n    Star: "â‹†",\n    Sub: "â‹",\n    Subset: "â‹",\n    SubsetEqual: "âŠ†",\n    Succeeds: "â‰»",\n    SucceedsEqual: "âª°",\n    SucceedsSlantEqual: "â‰½",\n    SucceedsTilde: "â‰¿",\n    SuchThat: "âˆ‹",\n    Sum: "âˆ‘",\n    Sup: "â‹‘",\n    Superset: "âŠƒ",\n    SupersetEqual: "âŠ‡",\n    Supset: "â‹‘",\n    THORN: "Ãž",\n    TRADE: "â„¢",\n    TSHcy: "Ð‹",\n    TScy: "Ð¦",\n    Tab: "	",\n    Tau: "Î¤",\n    Tcaron: "Å¤",\n    Tcedil: "Å¢",\n    Tcy: "Ð¢",\n    Tfr: "ð”—",\n    Therefore: "âˆ´",\n    Theta: "Î˜",\n    ThickSpace: "âŸâ€Š",\n    ThinSpace: "â€‰",\n    Tilde: "âˆ¼",\n    TildeEqual: "â‰ƒ",\n    TildeFullEqual: "â‰…",\n    TildeTilde: "â‰ˆ",\n    Topf: "ð•‹",\n    TripleDot: "âƒ›",\n    Tscr: "ð’¯",\n    Tstrok: "Å¦",\n    Uacute: "Ãš",\n    Uarr: "â†Ÿ",\n    Uarrocir: "â¥‰",\n    Ubrcy: "ÐŽ",\n    Ubreve: "Å¬",\n    Ucirc: "Ã›",\n    Ucy: "Ð£",\n    Udblac: "Å°",\n    Ufr: "ð”˜",\n    Ugrave: "Ã™",\n    Umacr: "Åª",\n    UnderBar: "_",\n    UnderBrace: "âŸ",\n    UnderBracket: "âŽµ",\n    UnderParenthesis: "â",\n    Union: "â‹ƒ",\n    UnionPlus: "âŠŽ",\n    Uogon: "Å²",\n    Uopf: "ð•Œ",\n    UpArrow: "â†‘",\n    UpArrowBar: "â¤’",\n    UpArrowDownArrow: "â‡…",\n    UpDownArrow: "â†•",\n    UpEquilibrium: "â¥®",\n    UpTee: "âŠ¥",\n    UpTeeArrow: "â†¥",\n    Uparrow: "â‡‘",\n    Updownarrow: "â‡•",\n    UpperLeftArrow: "â†–",\n    UpperRightArrow: "â†—",\n    Upsi: "Ï’",\n    Upsilon: "Î¥",\n    Uring: "Å®",\n    Uscr: "ð’°",\n    Utilde: "Å¨",\n    Uuml: "Ãœ",\n    VDash: "âŠ«",\n    Vbar: "â««",\n    Vcy: "Ð’",\n    Vdash: "âŠ©",\n    Vdashl: "â«¦",\n    Vee: "â‹",\n    Verbar: "â€–",\n    Vert: "â€–",\n    VerticalBar: "âˆ£",\n    VerticalLine: "|",\n    VerticalSeparator: "â˜",\n    VerticalTilde: "â‰€",\n    VeryThinSpace: "â€Š",\n    Vfr: "ð”™",\n    Vopf: "ð•",\n    Vscr: "ð’±",\n    Vvdash: "âŠª",\n    Wcirc: "Å´",\n    Wedge: "â‹€",\n    Wfr: "ð”š",\n    Wopf: "ð•Ž",\n    Wscr: "ð’²",\n    Xfr: "ð”›",\n    Xi: "Îž",\n    Xopf: "ð•",\n    Xscr: "ð’³",\n    YAcy: "Ð¯",\n    YIcy: "Ð‡",\n    YUcy: "Ð®",\n    Yacute: "Ã",\n    Ycirc: "Å¶",\n    Ycy: "Ð«",\n    Yfr: "ð”œ",\n    Yopf: "ð•",\n    Yscr: "ð’´",\n    Yuml: "Å¸",\n    ZHcy: "Ð–",\n    Zacute: "Å¹",\n    Zcaron: "Å½",\n    Zcy: "Ð—",\n    Zdot: "Å»",\n    ZeroWidthSpace: "â€‹",\n    Zeta: "Î–",\n    Zfr: "â„¨",\n    Zopf: "â„¤",\n    Zscr: "ð’µ",\n    aacute: "Ã¡",\n    abreve: "Äƒ",\n    ac: "âˆ¾",\n    acE: "âˆ¾Ì³",\n    acd: "âˆ¿",\n    acirc: "Ã¢",\n    acute: "Â´",\n    acy: "Ð°",\n    aelig: "Ã¦",\n    af: "â¡",\n    afr: "ð”ž",\n    agrave: "Ã ",\n    alefsym: "â„µ",\n    aleph: "â„µ",\n    alpha: "Î±",\n    amacr: "Ä",\n    amalg: "â¨¿",\n    amp: "&",\n    and: "âˆ§",\n    andand: "â©•",\n    andd: "â©œ",\n    andslope: "â©˜",\n    andv: "â©š",\n    ang: "âˆ ",\n    ange: "â¦¤",\n    angle: "âˆ ",\n    angmsd: "âˆ¡",\n    angmsdaa: "â¦¨",\n    angmsdab: "â¦©",\n    angmsdac: "â¦ª",\n    angmsdad: "â¦«",\n    angmsdae: "â¦¬",\n    angmsdaf: "â¦­",\n    angmsdag: "â¦®",\n    angmsdah: "â¦¯",\n    angrt: "âˆŸ",\n    angrtvb: "âŠ¾",\n    angrtvbd: "â¦",\n    angsph: "âˆ¢",\n    angst: "Ã…",\n    angzarr: "â¼",\n    aogon: "Ä…",\n    aopf: "ð•’",\n    ap: "â‰ˆ",\n    apE: "â©°",\n    apacir: "â©¯",\n    ape: "â‰Š",\n    apid: "â‰‹",\n    apos: "\'",\n    approx: "â‰ˆ",\n    approxeq: "â‰Š",\n    aring: "Ã¥",\n    ascr: "ð’¶",\n    ast: "*",\n    asymp: "â‰ˆ",\n    asympeq: "â‰",\n    atilde: "Ã£",\n    auml: "Ã¤",\n    awconint: "âˆ³",\n    awint: "â¨‘",\n    bNot: "â«­",\n    backcong: "â‰Œ",\n    backepsilon: "Ï¶",\n    backprime: "â€µ",\n    backsim: "âˆ½",\n    backsimeq: "â‹",\n    barvee: "âŠ½",\n    barwed: "âŒ…",\n    barwedge: "âŒ…",\n    bbrk: "âŽµ",\n    bbrktbrk: "âŽ¶",\n    bcong: "â‰Œ",\n    bcy: "Ð±",\n    bdquo: "â€ž",\n    becaus: "âˆµ",\n    because: "âˆµ",\n    bemptyv: "â¦°",\n    bepsi: "Ï¶",\n    bernou: "â„¬",\n    beta: "Î²",\n    beth: "â„¶",\n    between: "â‰¬",\n    bfr: "ð”Ÿ",\n    bigcap: "â‹‚",\n    bigcirc: "â—¯",\n    bigcup: "â‹ƒ",\n    bigodot: "â¨€",\n    bigoplus: "â¨",\n    bigotimes: "â¨‚",\n    bigsqcup: "â¨†",\n    bigstar: "â˜…",\n    bigtriangledown: "â–½",\n    bigtriangleup: "â–³",\n    biguplus: "â¨„",\n    bigvee: "â‹",\n    bigwedge: "â‹€",\n    bkarow: "â¤",\n    blacklozenge: "â§«",\n    blacksquare: "â–ª",\n    blacktriangle: "â–´",\n    blacktriangledown: "â–¾",\n    blacktriangleleft: "â—‚",\n    blacktriangleright: "â–¸",\n    blank: "â£",\n    blk12: "â–’",\n    blk14: "â–‘",\n    blk34: "â–“",\n    block: "â–ˆ",\n    bne: "=âƒ¥",\n    bnequiv: "â‰¡âƒ¥",\n    bnot: "âŒ",\n    bopf: "ð•“",\n    bot: "âŠ¥",\n    bottom: "âŠ¥",\n    bowtie: "â‹ˆ",\n    boxDL: "â•—",\n    boxDR: "â•”",\n    boxDl: "â•–",\n    boxDr: "â•“",\n    boxH: "â•",\n    boxHD: "â•¦",\n    boxHU: "â•©",\n    boxHd: "â•¤",\n    boxHu: "â•§",\n    boxUL: "â•",\n    boxUR: "â•š",\n    boxUl: "â•œ",\n    boxUr: "â•™",\n    boxV: "â•‘",\n    boxVH: "â•¬",\n    boxVL: "â•£",\n    boxVR: "â• ",\n    boxVh: "â•«",\n    boxVl: "â•¢",\n    boxVr: "â•Ÿ",\n    boxbox: "â§‰",\n    boxdL: "â••",\n    boxdR: "â•’",\n    boxdl: "â”",\n    boxdr: "â”Œ",\n    boxh: "â”€",\n    boxhD: "â•¥",\n    boxhU: "â•¨",\n    boxhd: "â”¬",\n    boxhu: "â”´",\n    boxminus: "âŠŸ",\n    boxplus: "âŠž",\n    boxtimes: "âŠ ",\n    boxuL: "â•›",\n    boxuR: "â•˜",\n    boxul: "â”˜",\n    boxur: "â””",\n    boxv: "â”‚",\n    boxvH: "â•ª",\n    boxvL: "â•¡",\n    boxvR: "â•ž",\n    boxvh: "â”¼",\n    boxvl: "â”¤",\n    boxvr: "â”œ",\n    bprime: "â€µ",\n    breve: "Ë˜",\n    brvbar: "Â¦",\n    bscr: "ð’·",\n    bsemi: "â",\n    bsim: "âˆ½",\n    bsime: "â‹",\n    bsol: "\\\\",\n    bsolb: "â§…",\n    bsolhsub: "âŸˆ",\n    bull: "â€¢",\n    bullet: "â€¢",\n    bump: "â‰Ž",\n    bumpE: "âª®",\n    bumpe: "â‰",\n    bumpeq: "â‰",\n    cacute: "Ä‡",\n    cap: "âˆ©",\n    capand: "â©„",\n    capbrcup: "â©‰",\n    capcap: "â©‹",\n    capcup: "â©‡",\n    capdot: "â©€",\n    caps: "âˆ©ï¸€",\n    caret: "â",\n    caron: "Ë‡",\n    ccaps: "â©",\n    ccaron: "Ä",\n    ccedil: "Ã§",\n    ccirc: "Ä‰",\n    ccups: "â©Œ",\n    ccupssm: "â©",\n    cdot: "Ä‹",\n    cedil: "Â¸",\n    cemptyv: "â¦²",\n    cent: "Â¢",\n    centerdot: "Â·",\n    cfr: "ð” ",\n    chcy: "Ñ‡",\n    check: "âœ“",\n    checkmark: "âœ“",\n    chi: "Ï‡",\n    cir: "â—‹",\n    cirE: "â§ƒ",\n    circ: "Ë†",\n    circeq: "â‰—",\n    circlearrowleft: "â†º",\n    circlearrowright: "â†»",\n    circledR: "Â®",\n    circledS: "â“ˆ",\n    circledast: "âŠ›",\n    circledcirc: "âŠš",\n    circleddash: "âŠ",\n    cire: "â‰—",\n    cirfnint: "â¨",\n    cirmid: "â«¯",\n    cirscir: "â§‚",\n    clubs: "â™£",\n    clubsuit: "â™£",\n    colon: ":",\n    colone: "â‰”",\n    coloneq: "â‰”",\n    comma: ",",\n    commat: "@",\n    comp: "âˆ",\n    compfn: "âˆ˜",\n    complement: "âˆ",\n    complexes: "â„‚",\n    cong: "â‰…",\n    congdot: "â©­",\n    conint: "âˆ®",\n    copf: "ð•”",\n    coprod: "âˆ",\n    copy: "Â©",\n    copysr: "â„—",\n    crarr: "â†µ",\n    cross: "âœ—",\n    cscr: "ð’¸",\n    csub: "â«",\n    csube: "â«‘",\n    csup: "â«",\n    csupe: "â«’",\n    ctdot: "â‹¯",\n    cudarrl: "â¤¸",\n    cudarrr: "â¤µ",\n    cuepr: "â‹ž",\n    cuesc: "â‹Ÿ",\n    cularr: "â†¶",\n    cularrp: "â¤½",\n    cup: "âˆª",\n    cupbrcap: "â©ˆ",\n    cupcap: "â©†",\n    cupcup: "â©Š",\n    cupdot: "âŠ",\n    cupor: "â©…",\n    cups: "âˆªï¸€",\n    curarr: "â†·",\n    curarrm: "â¤¼",\n    curlyeqprec: "â‹ž",\n    curlyeqsucc: "â‹Ÿ",\n    curlyvee: "â‹Ž",\n    curlywedge: "â‹",\n    curren: "Â¤",\n    curvearrowleft: "â†¶",\n    curvearrowright: "â†·",\n    cuvee: "â‹Ž",\n    cuwed: "â‹",\n    cwconint: "âˆ²",\n    cwint: "âˆ±",\n    cylcty: "âŒ­",\n    dArr: "â‡“",\n    dHar: "â¥¥",\n    dagger: "â€ ",\n    daleth: "â„¸",\n    darr: "â†“",\n    dash: "â€",\n    dashv: "âŠ£",\n    dbkarow: "â¤",\n    dblac: "Ë",\n    dcaron: "Ä",\n    dcy: "Ð´",\n    dd: "â…†",\n    ddagger: "â€¡",\n    ddarr: "â‡Š",\n    ddotseq: "â©·",\n    deg: "Â°",\n    delta: "Î´",\n    demptyv: "â¦±",\n    dfisht: "â¥¿",\n    dfr: "ð”¡",\n    dharl: "â‡ƒ",\n    dharr: "â‡‚",\n    diam: "â‹„",\n    diamond: "â‹„",\n    diamondsuit: "â™¦",\n    diams: "â™¦",\n    die: "Â¨",\n    digamma: "Ï",\n    disin: "â‹²",\n    div: "Ã·",\n    divide: "Ã·",\n    divideontimes: "â‹‡",\n    divonx: "â‹‡",\n    djcy: "Ñ’",\n    dlcorn: "âŒž",\n    dlcrop: "âŒ",\n    dollar: "$",\n    dopf: "ð••",\n    dot: "Ë™",\n    doteq: "â‰",\n    doteqdot: "â‰‘",\n    dotminus: "âˆ¸",\n    dotplus: "âˆ”",\n    dotsquare: "âŠ¡",\n    doublebarwedge: "âŒ†",\n    downarrow: "â†“",\n    downdownarrows: "â‡Š",\n    downharpoonleft: "â‡ƒ",\n    downharpoonright: "â‡‚",\n    drbkarow: "â¤",\n    drcorn: "âŒŸ",\n    drcrop: "âŒŒ",\n    dscr: "ð’¹",\n    dscy: "Ñ•",\n    dsol: "â§¶",\n    dstrok: "Ä‘",\n    dtdot: "â‹±",\n    dtri: "â–¿",\n    dtrif: "â–¾",\n    duarr: "â‡µ",\n    duhar: "â¥¯",\n    dwangle: "â¦¦",\n    dzcy: "ÑŸ",\n    dzigrarr: "âŸ¿",\n    eDDot: "â©·",\n    eDot: "â‰‘",\n    eacute: "Ã©",\n    easter: "â©®",\n    ecaron: "Ä›",\n    ecir: "â‰–",\n    ecirc: "Ãª",\n    ecolon: "â‰•",\n    ecy: "Ñ",\n    edot: "Ä—",\n    ee: "â…‡",\n    efDot: "â‰’",\n    efr: "ð”¢",\n    eg: "âªš",\n    egrave: "Ã¨",\n    egs: "âª–",\n    egsdot: "âª˜",\n    el: "âª™",\n    elinters: "â§",\n    ell: "â„“",\n    els: "âª•",\n    elsdot: "âª—",\n    emacr: "Ä“",\n    empty: "âˆ…",\n    emptyset: "âˆ…",\n    emptyv: "âˆ…",\n    emsp13: "â€„",\n    emsp14: "â€…",\n    emsp: "â€ƒ",\n    eng: "Å‹",\n    ensp: "â€‚",\n    eogon: "Ä™",\n    eopf: "ð•–",\n    epar: "â‹•",\n    eparsl: "â§£",\n    eplus: "â©±",\n    epsi: "Îµ",\n    epsilon: "Îµ",\n    epsiv: "Ïµ",\n    eqcirc: "â‰–",\n    eqcolon: "â‰•",\n    eqsim: "â‰‚",\n    eqslantgtr: "âª–",\n    eqslantless: "âª•",\n    equals: "=",\n    equest: "â‰Ÿ",\n    equiv: "â‰¡",\n    equivDD: "â©¸",\n    eqvparsl: "â§¥",\n    erDot: "â‰“",\n    erarr: "â¥±",\n    escr: "â„¯",\n    esdot: "â‰",\n    esim: "â‰‚",\n    eta: "Î·",\n    eth: "Ã°",\n    euml: "Ã«",\n    euro: "â‚¬",\n    excl: "!",\n    exist: "âˆƒ",\n    expectation: "â„°",\n    exponentiale: "â…‡",\n    fallingdotseq: "â‰’",\n    fcy: "Ñ„",\n    female: "â™€",\n    ffilig: "ï¬ƒ",\n    fflig: "ï¬€",\n    ffllig: "ï¬„",\n    ffr: "ð”£",\n    filig: "ï¬",\n    fjlig: "fj",\n    flat: "â™­",\n    fllig: "ï¬‚",\n    fltns: "â–±",\n    fnof: "Æ’",\n    fopf: "ð•—",\n    forall: "âˆ€",\n    fork: "â‹”",\n    forkv: "â«™",\n    fpartint: "â¨",\n    frac12: "Â½",\n    frac13: "â…“",\n    frac14: "Â¼",\n    frac15: "â…•",\n    frac16: "â…™",\n    frac18: "â…›",\n    frac23: "â…”",\n    frac25: "â…–",\n    frac34: "Â¾",\n    frac35: "â…—",\n    frac38: "â…œ",\n    frac45: "â…˜",\n    frac56: "â…š",\n    frac58: "â…",\n    frac78: "â…ž",\n    frasl: "â„",\n    frown: "âŒ¢",\n    fscr: "ð’»",\n    gE: "â‰§",\n    gEl: "âªŒ",\n    gacute: "Çµ",\n    gamma: "Î³",\n    gammad: "Ï",\n    gap: "âª†",\n    gbreve: "ÄŸ",\n    gcirc: "Ä",\n    gcy: "Ð³",\n    gdot: "Ä¡",\n    ge: "â‰¥",\n    gel: "â‹›",\n    geq: "â‰¥",\n    geqq: "â‰§",\n    geqslant: "â©¾",\n    ges: "â©¾",\n    gescc: "âª©",\n    gesdot: "âª€",\n    gesdoto: "âª‚",\n    gesdotol: "âª„",\n    gesl: "â‹›ï¸€",\n    gesles: "âª”",\n    gfr: "ð”¤",\n    gg: "â‰«",\n    ggg: "â‹™",\n    gimel: "â„·",\n    gjcy: "Ñ“",\n    gl: "â‰·",\n    glE: "âª’",\n    gla: "âª¥",\n    glj: "âª¤",\n    gnE: "â‰©",\n    gnap: "âªŠ",\n    gnapprox: "âªŠ",\n    gne: "âªˆ",\n    gneq: "âªˆ",\n    gneqq: "â‰©",\n    gnsim: "â‹§",\n    gopf: "ð•˜",\n    grave: "`",\n    gscr: "â„Š",\n    gsim: "â‰³",\n    gsime: "âªŽ",\n    gsiml: "âª",\n    gt: ">",\n    gtcc: "âª§",\n    gtcir: "â©º",\n    gtdot: "â‹—",\n    gtlPar: "â¦•",\n    gtquest: "â©¼",\n    gtrapprox: "âª†",\n    gtrarr: "â¥¸",\n    gtrdot: "â‹—",\n    gtreqless: "â‹›",\n    gtreqqless: "âªŒ",\n    gtrless: "â‰·",\n    gtrsim: "â‰³",\n    gvertneqq: "â‰©ï¸€",\n    gvnE: "â‰©ï¸€",\n    hArr: "â‡”",\n    hairsp: "â€Š",\n    half: "Â½",\n    hamilt: "â„‹",\n    hardcy: "ÑŠ",\n    harr: "â†”",\n    harrcir: "â¥ˆ",\n    harrw: "â†­",\n    hbar: "â„",\n    hcirc: "Ä¥",\n    hearts: "â™¥",\n    heartsuit: "â™¥",\n    hellip: "â€¦",\n    hercon: "âŠ¹",\n    hfr: "ð”¥",\n    hksearow: "â¤¥",\n    hkswarow: "â¤¦",\n    hoarr: "â‡¿",\n    homtht: "âˆ»",\n    hookleftarrow: "â†©",\n    hookrightarrow: "â†ª",\n    hopf: "ð•™",\n    horbar: "â€•",\n    hscr: "ð’½",\n    hslash: "â„",\n    hstrok: "Ä§",\n    hybull: "âƒ",\n    hyphen: "â€",\n    iacute: "Ã­",\n    ic: "â£",\n    icirc: "Ã®",\n    icy: "Ð¸",\n    iecy: "Ðµ",\n    iexcl: "Â¡",\n    iff: "â‡”",\n    ifr: "ð”¦",\n    igrave: "Ã¬",\n    ii: "â…ˆ",\n    iiiint: "â¨Œ",\n    iiint: "âˆ­",\n    iinfin: "â§œ",\n    iiota: "â„©",\n    ijlig: "Ä³",\n    imacr: "Ä«",\n    image: "â„‘",\n    imagline: "â„",\n    imagpart: "â„‘",\n    imath: "Ä±",\n    imof: "âŠ·",\n    imped: "Æµ",\n    in: "âˆˆ",\n    incare: "â„…",\n    infin: "âˆž",\n    infintie: "â§",\n    inodot: "Ä±",\n    int: "âˆ«",\n    intcal: "âŠº",\n    integers: "â„¤",\n    intercal: "âŠº",\n    intlarhk: "â¨—",\n    intprod: "â¨¼",\n    iocy: "Ñ‘",\n    iogon: "Ä¯",\n    iopf: "ð•š",\n    iota: "Î¹",\n    iprod: "â¨¼",\n    iquest: "Â¿",\n    iscr: "ð’¾",\n    isin: "âˆˆ",\n    isinE: "â‹¹",\n    isindot: "â‹µ",\n    isins: "â‹´",\n    isinsv: "â‹³",\n    isinv: "âˆˆ",\n    it: "â¢",\n    itilde: "Ä©",\n    iukcy: "Ñ–",\n    iuml: "Ã¯",\n    jcirc: "Äµ",\n    jcy: "Ð¹",\n    jfr: "ð”§",\n    jmath: "È·",\n    jopf: "ð•›",\n    jscr: "ð’¿",\n    jsercy: "Ñ˜",\n    jukcy: "Ñ”",\n    kappa: "Îº",\n    kappav: "Ï°",\n    kcedil: "Ä·",\n    kcy: "Ðº",\n    kfr: "ð”¨",\n    kgreen: "Ä¸",\n    khcy: "Ñ…",\n    kjcy: "Ñœ",\n    kopf: "ð•œ",\n    kscr: "ð“€",\n    lAarr: "â‡š",\n    lArr: "â‡",\n    lAtail: "â¤›",\n    lBarr: "â¤Ž",\n    lE: "â‰¦",\n    lEg: "âª‹",\n    lHar: "â¥¢",\n    lacute: "Äº",\n    laemptyv: "â¦´",\n    lagran: "â„’",\n    lambda: "Î»",\n    lang: "âŸ¨",\n    langd: "â¦‘",\n    langle: "âŸ¨",\n    lap: "âª…",\n    laquo: "Â«",\n    larr: "â†",\n    larrb: "â‡¤",\n    larrbfs: "â¤Ÿ",\n    larrfs: "â¤",\n    larrhk: "â†©",\n    larrlp: "â†«",\n    larrpl: "â¤¹",\n    larrsim: "â¥³",\n    larrtl: "â†¢",\n    lat: "âª«",\n    latail: "â¤™",\n    late: "âª­",\n    lates: "âª­ï¸€",\n    lbarr: "â¤Œ",\n    lbbrk: "â²",\n    lbrace: "{",\n    lbrack: "[",\n    lbrke: "â¦‹",\n    lbrksld: "â¦",\n    lbrkslu: "â¦",\n    lcaron: "Ä¾",\n    lcedil: "Ä¼",\n    lceil: "âŒˆ",\n    lcub: "{",\n    lcy: "Ð»",\n    ldca: "â¤¶",\n    ldquo: "â€œ",\n    ldquor: "â€ž",\n    ldrdhar: "â¥§",\n    ldrushar: "â¥‹",\n    ldsh: "â†²",\n    le: "â‰¤",\n    leftarrow: "â†",\n    leftarrowtail: "â†¢",\n    leftharpoondown: "â†½",\n    leftharpoonup: "â†¼",\n    leftleftarrows: "â‡‡",\n    leftrightarrow: "â†”",\n    leftrightarrows: "â‡†",\n    leftrightharpoons: "â‡‹",\n    leftrightsquigarrow: "â†­",\n    leftthreetimes: "â‹‹",\n    leg: "â‹š",\n    leq: "â‰¤",\n    leqq: "â‰¦",\n    leqslant: "â©½",\n    les: "â©½",\n    lescc: "âª¨",\n    lesdot: "â©¿",\n    lesdoto: "âª",\n    lesdotor: "âªƒ",\n    lesg: "â‹šï¸€",\n    lesges: "âª“",\n    lessapprox: "âª…",\n    lessdot: "â‹–",\n    lesseqgtr: "â‹š",\n    lesseqqgtr: "âª‹",\n    lessgtr: "â‰¶",\n    lesssim: "â‰²",\n    lfisht: "â¥¼",\n    lfloor: "âŒŠ",\n    lfr: "ð”©",\n    lg: "â‰¶",\n    lgE: "âª‘",\n    lhard: "â†½",\n    lharu: "â†¼",\n    lharul: "â¥ª",\n    lhblk: "â–„",\n    ljcy: "Ñ™",\n    ll: "â‰ª",\n    llarr: "â‡‡",\n    llcorner: "âŒž",\n    llhard: "â¥«",\n    lltri: "â—º",\n    lmidot: "Å€",\n    lmoust: "âŽ°",\n    lmoustache: "âŽ°",\n    lnE: "â‰¨",\n    lnap: "âª‰",\n    lnapprox: "âª‰",\n    lne: "âª‡",\n    lneq: "âª‡",\n    lneqq: "â‰¨",\n    lnsim: "â‹¦",\n    loang: "âŸ¬",\n    loarr: "â‡½",\n    lobrk: "âŸ¦",\n    longleftarrow: "âŸµ",\n    longleftrightarrow: "âŸ·",\n    longmapsto: "âŸ¼",\n    longrightarrow: "âŸ¶",\n    looparrowleft: "â†«",\n    looparrowright: "â†¬",\n    lopar: "â¦…",\n    lopf: "ð•",\n    loplus: "â¨­",\n    lotimes: "â¨´",\n    lowast: "âˆ—",\n    lowbar: "_",\n    loz: "â—Š",\n    lozenge: "â—Š",\n    lozf: "â§«",\n    lpar: "(",\n    lparlt: "â¦“",\n    lrarr: "â‡†",\n    lrcorner: "âŒŸ",\n    lrhar: "â‡‹",\n    lrhard: "â¥­",\n    lrm: "â€Ž",\n    lrtri: "âŠ¿",\n    lsaquo: "â€¹",\n    lscr: "ð“",\n    lsh: "â†°",\n    lsim: "â‰²",\n    lsime: "âª",\n    lsimg: "âª",\n    lsqb: "[",\n    lsquo: "â€˜",\n    lsquor: "â€š",\n    lstrok: "Å‚",\n    lt: "<",\n    ltcc: "âª¦",\n    ltcir: "â©¹",\n    ltdot: "â‹–",\n    lthree: "â‹‹",\n    ltimes: "â‹‰",\n    ltlarr: "â¥¶",\n    ltquest: "â©»",\n    ltrPar: "â¦–",\n    ltri: "â—ƒ",\n    ltrie: "âŠ´",\n    ltrif: "â—‚",\n    lurdshar: "â¥Š",\n    luruhar: "â¥¦",\n    lvertneqq: "â‰¨ï¸€",\n    lvnE: "â‰¨ï¸€",\n    mDDot: "âˆº",\n    macr: "Â¯",\n    male: "â™‚",\n    malt: "âœ ",\n    maltese: "âœ ",\n    map: "â†¦",\n    mapsto: "â†¦",\n    mapstodown: "â†§",\n    mapstoleft: "â†¤",\n    mapstoup: "â†¥",\n    marker: "â–®",\n    mcomma: "â¨©",\n    mcy: "Ð¼",\n    mdash: "â€”",\n    measuredangle: "âˆ¡",\n    mfr: "ð”ª",\n    mho: "â„§",\n    micro: "Âµ",\n    mid: "âˆ£",\n    midast: "*",\n    midcir: "â«°",\n    middot: "Â·",\n    minus: "âˆ’",\n    minusb: "âŠŸ",\n    minusd: "âˆ¸",\n    minusdu: "â¨ª",\n    mlcp: "â«›",\n    mldr: "â€¦",\n    mnplus: "âˆ“",\n    models: "âŠ§",\n    mopf: "ð•ž",\n    mp: "âˆ“",\n    mscr: "ð“‚",\n    mstpos: "âˆ¾",\n    mu: "Î¼",\n    multimap: "âŠ¸",\n    mumap: "âŠ¸",\n    nGg: "â‹™Ì¸",\n    nGt: "â‰«âƒ’",\n    nGtv: "â‰«Ì¸",\n    nLeftarrow: "â‡",\n    nLeftrightarrow: "â‡Ž",\n    nLl: "â‹˜Ì¸",\n    nLt: "â‰ªâƒ’",\n    nLtv: "â‰ªÌ¸",\n    nRightarrow: "â‡",\n    nVDash: "âŠ¯",\n    nVdash: "âŠ®",\n    nabla: "âˆ‡",\n    nacute: "Å„",\n    nang: "âˆ âƒ’",\n    nap: "â‰‰",\n    napE: "â©°Ì¸",\n    napid: "â‰‹Ì¸",\n    napos: "Å‰",\n    napprox: "â‰‰",\n    natur: "â™®",\n    natural: "â™®",\n    naturals: "â„•",\n    nbsp: "Â ",\n    nbump: "â‰ŽÌ¸",\n    nbumpe: "â‰Ì¸",\n    ncap: "â©ƒ",\n    ncaron: "Åˆ",\n    ncedil: "Å†",\n    ncong: "â‰‡",\n    ncongdot: "â©­Ì¸",\n    ncup: "â©‚",\n    ncy: "Ð½",\n    ndash: "â€“",\n    ne: "â‰ ",\n    neArr: "â‡—",\n    nearhk: "â¤¤",\n    nearr: "â†—",\n    nearrow: "â†—",\n    nedot: "â‰Ì¸",\n    nequiv: "â‰¢",\n    nesear: "â¤¨",\n    nesim: "â‰‚Ì¸",\n    nexist: "âˆ„",\n    nexists: "âˆ„",\n    nfr: "ð”«",\n    ngE: "â‰§Ì¸",\n    nge: "â‰±",\n    ngeq: "â‰±",\n    ngeqq: "â‰§Ì¸",\n    ngeqslant: "â©¾Ì¸",\n    nges: "â©¾Ì¸",\n    ngsim: "â‰µ",\n    ngt: "â‰¯",\n    ngtr: "â‰¯",\n    nhArr: "â‡Ž",\n    nharr: "â†®",\n    nhpar: "â«²",\n    ni: "âˆ‹",\n    nis: "â‹¼",\n    nisd: "â‹º",\n    niv: "âˆ‹",\n    njcy: "Ñš",\n    nlArr: "â‡",\n    nlE: "â‰¦Ì¸",\n    nlarr: "â†š",\n    nldr: "â€¥",\n    nle: "â‰°",\n    nleftarrow: "â†š",\n    nleftrightarrow: "â†®",\n    nleq: "â‰°",\n    nleqq: "â‰¦Ì¸",\n    nleqslant: "â©½Ì¸",\n    nles: "â©½Ì¸",\n    nless: "â‰®",\n    nlsim: "â‰´",\n    nlt: "â‰®",\n    nltri: "â‹ª",\n    nltrie: "â‹¬",\n    nmid: "âˆ¤",\n    nopf: "ð•Ÿ",\n    not: "Â¬",\n    notin: "âˆ‰",\n    notinE: "â‹¹Ì¸",\n    notindot: "â‹µÌ¸",\n    notinva: "âˆ‰",\n    notinvb: "â‹·",\n    notinvc: "â‹¶",\n    notni: "âˆŒ",\n    notniva: "âˆŒ",\n    notnivb: "â‹¾",\n    notnivc: "â‹½",\n    npar: "âˆ¦",\n    nparallel: "âˆ¦",\n    nparsl: "â«½âƒ¥",\n    npart: "âˆ‚Ì¸",\n    npolint: "â¨”",\n    npr: "âŠ€",\n    nprcue: "â‹ ",\n    npre: "âª¯Ì¸",\n    nprec: "âŠ€",\n    npreceq: "âª¯Ì¸",\n    nrArr: "â‡",\n    nrarr: "â†›",\n    nrarrc: "â¤³Ì¸",\n    nrarrw: "â†Ì¸",\n    nrightarrow: "â†›",\n    nrtri: "â‹«",\n    nrtrie: "â‹­",\n    nsc: "âŠ",\n    nsccue: "â‹¡",\n    nsce: "âª°Ì¸",\n    nscr: "ð“ƒ",\n    nshortmid: "âˆ¤",\n    nshortparallel: "âˆ¦",\n    nsim: "â‰",\n    nsime: "â‰„",\n    nsimeq: "â‰„",\n    nsmid: "âˆ¤",\n    nspar: "âˆ¦",\n    nsqsube: "â‹¢",\n    nsqsupe: "â‹£",\n    nsub: "âŠ„",\n    nsubE: "â«…Ì¸",\n    nsube: "âŠˆ",\n    nsubset: "âŠ‚âƒ’",\n    nsubseteq: "âŠˆ",\n    nsubseteqq: "â«…Ì¸",\n    nsucc: "âŠ",\n    nsucceq: "âª°Ì¸",\n    nsup: "âŠ…",\n    nsupE: "â«†Ì¸",\n    nsupe: "âŠ‰",\n    nsupset: "âŠƒâƒ’",\n    nsupseteq: "âŠ‰",\n    nsupseteqq: "â«†Ì¸",\n    ntgl: "â‰¹",\n    ntilde: "Ã±",\n    ntlg: "â‰¸",\n    ntriangleleft: "â‹ª",\n    ntrianglelefteq: "â‹¬",\n    ntriangleright: "â‹«",\n    ntrianglerighteq: "â‹­",\n    nu: "Î½",\n    num: "#",\n    numero: "â„–",\n    numsp: "â€‡",\n    nvDash: "âŠ­",\n    nvHarr: "â¤„",\n    nvap: "â‰âƒ’",\n    nvdash: "âŠ¬",\n    nvge: "â‰¥âƒ’",\n    nvgt: ">âƒ’",\n    nvinfin: "â§ž",\n    nvlArr: "â¤‚",\n    nvle: "â‰¤âƒ’",\n    nvlt: "<âƒ’",\n    nvltrie: "âŠ´âƒ’",\n    nvrArr: "â¤ƒ",\n    nvrtrie: "âŠµâƒ’",\n    nvsim: "âˆ¼âƒ’",\n    nwArr: "â‡–",\n    nwarhk: "â¤£",\n    nwarr: "â†–",\n    nwarrow: "â†–",\n    nwnear: "â¤§",\n    oS: "â“ˆ",\n    oacute: "Ã³",\n    oast: "âŠ›",\n    ocir: "âŠš",\n    ocirc: "Ã´",\n    ocy: "Ð¾",\n    odash: "âŠ",\n    odblac: "Å‘",\n    odiv: "â¨¸",\n    odot: "âŠ™",\n    odsold: "â¦¼",\n    oelig: "Å“",\n    ofcir: "â¦¿",\n    ofr: "ð”¬",\n    ogon: "Ë›",\n    ograve: "Ã²",\n    ogt: "â§",\n    ohbar: "â¦µ",\n    ohm: "Î©",\n    oint: "âˆ®",\n    olarr: "â†º",\n    olcir: "â¦¾",\n    olcross: "â¦»",\n    oline: "â€¾",\n    olt: "â§€",\n    omacr: "Å",\n    omega: "Ï‰",\n    omicron: "Î¿",\n    omid: "â¦¶",\n    ominus: "âŠ–",\n    oopf: "ð• ",\n    opar: "â¦·",\n    operp: "â¦¹",\n    oplus: "âŠ•",\n    or: "âˆ¨",\n    orarr: "â†»",\n    ord: "â©",\n    order: "â„´",\n    orderof: "â„´",\n    ordf: "Âª",\n    ordm: "Âº",\n    origof: "âŠ¶",\n    oror: "â©–",\n    orslope: "â©—",\n    orv: "â©›",\n    oscr: "â„´",\n    oslash: "Ã¸",\n    osol: "âŠ˜",\n    otilde: "Ãµ",\n    otimes: "âŠ—",\n    otimesas: "â¨¶",\n    ouml: "Ã¶",\n    ovbar: "âŒ½",\n    par: "âˆ¥",\n    para: "Â¶",\n    parallel: "âˆ¥",\n    parsim: "â«³",\n    parsl: "â«½",\n    part: "âˆ‚",\n    pcy: "Ð¿",\n    percnt: "%",\n    period: ".",\n    permil: "â€°",\n    perp: "âŠ¥",\n    pertenk: "â€±",\n    pfr: "ð”­",\n    phi: "Ï†",\n    phiv: "Ï•",\n    phmmat: "â„³",\n    phone: "â˜Ž",\n    pi: "Ï€",\n    pitchfork: "â‹”",\n    piv: "Ï–",\n    planck: "â„",\n    planckh: "â„Ž",\n    plankv: "â„",\n    plus: "+",\n    plusacir: "â¨£",\n    plusb: "âŠž",\n    pluscir: "â¨¢",\n    plusdo: "âˆ”",\n    plusdu: "â¨¥",\n    pluse: "â©²",\n    plusmn: "Â±",\n    plussim: "â¨¦",\n    plustwo: "â¨§",\n    pm: "Â±",\n    pointint: "â¨•",\n    popf: "ð•¡",\n    pound: "Â£",\n    pr: "â‰º",\n    prE: "âª³",\n    prap: "âª·",\n    prcue: "â‰¼",\n    pre: "âª¯",\n    prec: "â‰º",\n    precapprox: "âª·",\n    preccurlyeq: "â‰¼",\n    preceq: "âª¯",\n    precnapprox: "âª¹",\n    precneqq: "âªµ",\n    precnsim: "â‹¨",\n    precsim: "â‰¾",\n    prime: "â€²",\n    primes: "â„™",\n    prnE: "âªµ",\n    prnap: "âª¹",\n    prnsim: "â‹¨",\n    prod: "âˆ",\n    profalar: "âŒ®",\n    profline: "âŒ’",\n    profsurf: "âŒ“",\n    prop: "âˆ",\n    propto: "âˆ",\n    prsim: "â‰¾",\n    prurel: "âŠ°",\n    pscr: "ð“…",\n    psi: "Ïˆ",\n    puncsp: "â€ˆ",\n    qfr: "ð”®",\n    qint: "â¨Œ",\n    qopf: "ð•¢",\n    qprime: "â—",\n    qscr: "ð“†",\n    quaternions: "â„",\n    quatint: "â¨–",\n    quest: "?",\n    questeq: "â‰Ÿ",\n    quot: \'"\',\n    rAarr: "â‡›",\n    rArr: "â‡’",\n    rAtail: "â¤œ",\n    rBarr: "â¤",\n    rHar: "â¥¤",\n    race: "âˆ½Ì±",\n    racute: "Å•",\n    radic: "âˆš",\n    raemptyv: "â¦³",\n    rang: "âŸ©",\n    rangd: "â¦’",\n    range: "â¦¥",\n    rangle: "âŸ©",\n    raquo: "Â»",\n    rarr: "â†’",\n    rarrap: "â¥µ",\n    rarrb: "â‡¥",\n    rarrbfs: "â¤ ",\n    rarrc: "â¤³",\n    rarrfs: "â¤ž",\n    rarrhk: "â†ª",\n    rarrlp: "â†¬",\n    rarrpl: "â¥…",\n    rarrsim: "â¥´",\n    rarrtl: "â†£",\n    rarrw: "â†",\n    ratail: "â¤š",\n    ratio: "âˆ¶",\n    rationals: "â„š",\n    rbarr: "â¤",\n    rbbrk: "â³",\n    rbrace: "}",\n    rbrack: "]",\n    rbrke: "â¦Œ",\n    rbrksld: "â¦Ž",\n    rbrkslu: "â¦",\n    rcaron: "Å™",\n    rcedil: "Å—",\n    rceil: "âŒ‰",\n    rcub: "}",\n    rcy: "Ñ€",\n    rdca: "â¤·",\n    rdldhar: "â¥©",\n    rdquo: "â€",\n    rdquor: "â€",\n    rdsh: "â†³",\n    real: "â„œ",\n    realine: "â„›",\n    realpart: "â„œ",\n    reals: "â„",\n    rect: "â–­",\n    reg: "Â®",\n    rfisht: "â¥½",\n    rfloor: "âŒ‹",\n    rfr: "ð”¯",\n    rhard: "â‡",\n    rharu: "â‡€",\n    rharul: "â¥¬",\n    rho: "Ï",\n    rhov: "Ï±",\n    rightarrow: "â†’",\n    rightarrowtail: "â†£",\n    rightharpoondown: "â‡",\n    rightharpoonup: "â‡€",\n    rightleftarrows: "â‡„",\n    rightleftharpoons: "â‡Œ",\n    rightrightarrows: "â‡‰",\n    rightsquigarrow: "â†",\n    rightthreetimes: "â‹Œ",\n    ring: "Ëš",\n    risingdotseq: "â‰“",\n    rlarr: "â‡„",\n    rlhar: "â‡Œ",\n    rlm: "â€",\n    rmoust: "âŽ±",\n    rmoustache: "âŽ±",\n    rnmid: "â«®",\n    roang: "âŸ­",\n    roarr: "â‡¾",\n    robrk: "âŸ§",\n    ropar: "â¦†",\n    ropf: "ð•£",\n    roplus: "â¨®",\n    rotimes: "â¨µ",\n    rpar: ")",\n    rpargt: "â¦”",\n    rppolint: "â¨’",\n    rrarr: "â‡‰",\n    rsaquo: "â€º",\n    rscr: "ð“‡",\n    rsh: "â†±",\n    rsqb: "]",\n    rsquo: "â€™",\n    rsquor: "â€™",\n    rthree: "â‹Œ",\n    rtimes: "â‹Š",\n    rtri: "â–¹",\n    rtrie: "âŠµ",\n    rtrif: "â–¸",\n    rtriltri: "â§Ž",\n    ruluhar: "â¥¨",\n    rx: "â„ž",\n    sacute: "Å›",\n    sbquo: "â€š",\n    sc: "â‰»",\n    scE: "âª´",\n    scap: "âª¸",\n    scaron: "Å¡",\n    sccue: "â‰½",\n    sce: "âª°",\n    scedil: "ÅŸ",\n    scirc: "Å",\n    scnE: "âª¶",\n    scnap: "âªº",\n    scnsim: "â‹©",\n    scpolint: "â¨“",\n    scsim: "â‰¿",\n    scy: "Ñ",\n    sdot: "â‹…",\n    sdotb: "âŠ¡",\n    sdote: "â©¦",\n    seArr: "â‡˜",\n    searhk: "â¤¥",\n    searr: "â†˜",\n    searrow: "â†˜",\n    sect: "Â§",\n    semi: ";",\n    seswar: "â¤©",\n    setminus: "âˆ–",\n    setmn: "âˆ–",\n    sext: "âœ¶",\n    sfr: "ð”°",\n    sfrown: "âŒ¢",\n    sharp: "â™¯",\n    shchcy: "Ñ‰",\n    shcy: "Ñˆ",\n    shortmid: "âˆ£",\n    shortparallel: "âˆ¥",\n    shy: "Â­",\n    sigma: "Ïƒ",\n    sigmaf: "Ï‚",\n    sigmav: "Ï‚",\n    sim: "âˆ¼",\n    simdot: "â©ª",\n    sime: "â‰ƒ",\n    simeq: "â‰ƒ",\n    simg: "âªž",\n    simgE: "âª ",\n    siml: "âª",\n    simlE: "âªŸ",\n    simne: "â‰†",\n    simplus: "â¨¤",\n    simrarr: "â¥²",\n    slarr: "â†",\n    smallsetminus: "âˆ–",\n    smashp: "â¨³",\n    smeparsl: "â§¤",\n    smid: "âˆ£",\n    smile: "âŒ£",\n    smt: "âªª",\n    smte: "âª¬",\n    smtes: "âª¬ï¸€",\n    softcy: "ÑŒ",\n    sol: "/",\n    solb: "â§„",\n    solbar: "âŒ¿",\n    sopf: "ð•¤",\n    spades: "â™ ",\n    spadesuit: "â™ ",\n    spar: "âˆ¥",\n    sqcap: "âŠ“",\n    sqcaps: "âŠ“ï¸€",\n    sqcup: "âŠ”",\n    sqcups: "âŠ”ï¸€",\n    sqsub: "âŠ",\n    sqsube: "âŠ‘",\n    sqsubset: "âŠ",\n    sqsubseteq: "âŠ‘",\n    sqsup: "âŠ",\n    sqsupe: "âŠ’",\n    sqsupset: "âŠ",\n    sqsupseteq: "âŠ’",\n    squ: "â–¡",\n    square: "â–¡",\n    squarf: "â–ª",\n    squf: "â–ª",\n    srarr: "â†’",\n    sscr: "ð“ˆ",\n    ssetmn: "âˆ–",\n    ssmile: "âŒ£",\n    sstarf: "â‹†",\n    star: "â˜†",\n    starf: "â˜…",\n    straightepsilon: "Ïµ",\n    straightphi: "Ï•",\n    strns: "Â¯",\n    sub: "âŠ‚",\n    subE: "â«…",\n    subdot: "âª½",\n    sube: "âŠ†",\n    subedot: "â«ƒ",\n    submult: "â«",\n    subnE: "â«‹",\n    subne: "âŠŠ",\n    subplus: "âª¿",\n    subrarr: "â¥¹",\n    subset: "âŠ‚",\n    subseteq: "âŠ†",\n    subseteqq: "â«…",\n    subsetneq: "âŠŠ",\n    subsetneqq: "â«‹",\n    subsim: "â«‡",\n    subsub: "â«•",\n    subsup: "â«“",\n    succ: "â‰»",\n    succapprox: "âª¸",\n    succcurlyeq: "â‰½",\n    succeq: "âª°",\n    succnapprox: "âªº",\n    succneqq: "âª¶",\n    succnsim: "â‹©",\n    succsim: "â‰¿",\n    sum: "âˆ‘",\n    sung: "â™ª",\n    sup1: "Â¹",\n    sup2: "Â²",\n    sup3: "Â³",\n    sup: "âŠƒ",\n    supE: "â«†",\n    supdot: "âª¾",\n    supdsub: "â«˜",\n    supe: "âŠ‡",\n    supedot: "â«„",\n    suphsol: "âŸ‰",\n    suphsub: "â«—",\n    suplarr: "â¥»",\n    supmult: "â«‚",\n    supnE: "â«Œ",\n    supne: "âŠ‹",\n    supplus: "â«€",\n    supset: "âŠƒ",\n    supseteq: "âŠ‡",\n    supseteqq: "â«†",\n    supsetneq: "âŠ‹",\n    supsetneqq: "â«Œ",\n    supsim: "â«ˆ",\n    supsub: "â«”",\n    supsup: "â«–",\n    swArr: "â‡™",\n    swarhk: "â¤¦",\n    swarr: "â†™",\n    swarrow: "â†™",\n    swnwar: "â¤ª",\n    szlig: "ÃŸ",\n    target: "âŒ–",\n    tau: "Ï„",\n    tbrk: "âŽ´",\n    tcaron: "Å¥",\n    tcedil: "Å£",\n    tcy: "Ñ‚",\n    tdot: "âƒ›",\n    telrec: "âŒ•",\n    tfr: "ð”±",\n    there4: "âˆ´",\n    therefore: "âˆ´",\n    theta: "Î¸",\n    thetasym: "Ï‘",\n    thetav: "Ï‘",\n    thickapprox: "â‰ˆ",\n    thicksim: "âˆ¼",\n    thinsp: "â€‰",\n    thkap: "â‰ˆ",\n    thksim: "âˆ¼",\n    thorn: "Ã¾",\n    tilde: "Ëœ",\n    times: "Ã—",\n    timesb: "âŠ ",\n    timesbar: "â¨±",\n    timesd: "â¨°",\n    tint: "âˆ­",\n    toea: "â¤¨",\n    top: "âŠ¤",\n    topbot: "âŒ¶",\n    topcir: "â«±",\n    topf: "ð•¥",\n    topfork: "â«š",\n    tosa: "â¤©",\n    tprime: "â€´",\n    trade: "â„¢",\n    triangle: "â–µ",\n    triangledown: "â–¿",\n    triangleleft: "â—ƒ",\n    trianglelefteq: "âŠ´",\n    triangleq: "â‰œ",\n    triangleright: "â–¹",\n    trianglerighteq: "âŠµ",\n    tridot: "â—¬",\n    trie: "â‰œ",\n    triminus: "â¨º",\n    triplus: "â¨¹",\n    trisb: "â§",\n    tritime: "â¨»",\n    trpezium: "â¢",\n    tscr: "ð“‰",\n    tscy: "Ñ†",\n    tshcy: "Ñ›",\n    tstrok: "Å§",\n    twixt: "â‰¬",\n    twoheadleftarrow: "â†ž",\n    twoheadrightarrow: "â† ",\n    uArr: "â‡‘",\n    uHar: "â¥£",\n    uacute: "Ãº",\n    uarr: "â†‘",\n    ubrcy: "Ñž",\n    ubreve: "Å­",\n    ucirc: "Ã»",\n    ucy: "Ñƒ",\n    udarr: "â‡…",\n    udblac: "Å±",\n    udhar: "â¥®",\n    ufisht: "â¥¾",\n    ufr: "ð”²",\n    ugrave: "Ã¹",\n    uharl: "â†¿",\n    uharr: "â†¾",\n    uhblk: "â–€",\n    ulcorn: "âŒœ",\n    ulcorner: "âŒœ",\n    ulcrop: "âŒ",\n    ultri: "â—¸",\n    umacr: "Å«",\n    uml: "Â¨",\n    uogon: "Å³",\n    uopf: "ð•¦",\n    uparrow: "â†‘",\n    updownarrow: "â†•",\n    upharpoonleft: "â†¿",\n    upharpoonright: "â†¾",\n    uplus: "âŠŽ",\n    upsi: "Ï…",\n    upsih: "Ï’",\n    upsilon: "Ï…",\n    upuparrows: "â‡ˆ",\n    urcorn: "âŒ",\n    urcorner: "âŒ",\n    urcrop: "âŒŽ",\n    uring: "Å¯",\n    urtri: "â—¹",\n    uscr: "ð“Š",\n    utdot: "â‹°",\n    utilde: "Å©",\n    utri: "â–µ",\n    utrif: "â–´",\n    uuarr: "â‡ˆ",\n    uuml: "Ã¼",\n    uwangle: "â¦§",\n    vArr: "â‡•",\n    vBar: "â«¨",\n    vBarv: "â«©",\n    vDash: "âŠ¨",\n    vangrt: "â¦œ",\n    varepsilon: "Ïµ",\n    varkappa: "Ï°",\n    varnothing: "âˆ…",\n    varphi: "Ï•",\n    varpi: "Ï–",\n    varpropto: "âˆ",\n    varr: "â†•",\n    varrho: "Ï±",\n    varsigma: "Ï‚",\n    varsubsetneq: "âŠŠï¸€",\n    varsubsetneqq: "â«‹ï¸€",\n    varsupsetneq: "âŠ‹ï¸€",\n    varsupsetneqq: "â«Œï¸€",\n    vartheta: "Ï‘",\n    vartriangleleft: "âŠ²",\n    vartriangleright: "âŠ³",\n    vcy: "Ð²",\n    vdash: "âŠ¢",\n    vee: "âˆ¨",\n    veebar: "âŠ»",\n    veeeq: "â‰š",\n    vellip: "â‹®",\n    verbar: "|",\n    vert: "|",\n    vfr: "ð”³",\n    vltri: "âŠ²",\n    vnsub: "âŠ‚âƒ’",\n    vnsup: "âŠƒâƒ’",\n    vopf: "ð•§",\n    vprop: "âˆ",\n    vrtri: "âŠ³",\n    vscr: "ð“‹",\n    vsubnE: "â«‹ï¸€",\n    vsubne: "âŠŠï¸€",\n    vsupnE: "â«Œï¸€",\n    vsupne: "âŠ‹ï¸€",\n    vzigzag: "â¦š",\n    wcirc: "Åµ",\n    wedbar: "â©Ÿ",\n    wedge: "âˆ§",\n    wedgeq: "â‰™",\n    weierp: "â„˜",\n    wfr: "ð”´",\n    wopf: "ð•¨",\n    wp: "â„˜",\n    wr: "â‰€",\n    wreath: "â‰€",\n    wscr: "ð“Œ",\n    xcap: "â‹‚",\n    xcirc: "â—¯",\n    xcup: "â‹ƒ",\n    xdtri: "â–½",\n    xfr: "ð”µ",\n    xhArr: "âŸº",\n    xharr: "âŸ·",\n    xi: "Î¾",\n    xlArr: "âŸ¸",\n    xlarr: "âŸµ",\n    xmap: "âŸ¼",\n    xnis: "â‹»",\n    xodot: "â¨€",\n    xopf: "ð•©",\n    xoplus: "â¨",\n    xotime: "â¨‚",\n    xrArr: "âŸ¹",\n    xrarr: "âŸ¶",\n    xscr: "ð“",\n    xsqcup: "â¨†",\n    xuplus: "â¨„",\n    xutri: "â–³",\n    xvee: "â‹",\n    xwedge: "â‹€",\n    yacute: "Ã½",\n    yacy: "Ñ",\n    ycirc: "Å·",\n    ycy: "Ñ‹",\n    yen: "Â¥",\n    yfr: "ð”¶",\n    yicy: "Ñ—",\n    yopf: "ð•ª",\n    yscr: "ð“Ž",\n    yucy: "ÑŽ",\n    yuml: "Ã¿",\n    zacute: "Åº",\n    zcaron: "Å¾",\n    zcy: "Ð·",\n    zdot: "Å¼",\n    zeetrf: "â„¨",\n    zeta: "Î¶",\n    zfr: "ð”·",\n    zhcy: "Ð¶",\n    zigrarr: "â‡",\n    zopf: "ð•«",\n    zscr: "ð“",\n    zwj: "â€",\n    zwnj: "â€Œ"\n  };\n  const own$1 = {}.hasOwnProperty;\n  function decodeNamedCharacterReference(value) {\n    return own$1.call(characterEntities, value) ? characterEntities[value] : false;\n  }\n  function splice(list2, start, remove2, items) {\n    const end = list2.length;\n    let chunkStart = 0;\n    let parameters;\n    if (start < 0) {\n      start = -start > end ? 0 : end + start;\n    } else {\n      start = start > end ? end : start;\n    }\n    remove2 = remove2 > 0 ? remove2 : 0;\n    if (items.length < 1e4) {\n      parameters = Array.from(items);\n      parameters.unshift(start, remove2);\n      list2.splice(...parameters);\n    } else {\n      if (remove2) list2.splice(start, remove2);\n      while (chunkStart < items.length) {\n        parameters = items.slice(chunkStart, chunkStart + 1e4);\n        parameters.unshift(start, 0);\n        list2.splice(...parameters);\n        chunkStart += 1e4;\n        start += 1e4;\n      }\n    }\n  }\n  function push(list2, items) {\n    if (list2.length > 0) {\n      splice(list2, list2.length, 0, items);\n      return list2;\n    }\n    return items;\n  }\n  const hasOwnProperty = {}.hasOwnProperty;\n  function combineExtensions(extensions) {\n    const all2 = {};\n    let index2 = -1;\n    while (++index2 < extensions.length) {\n      syntaxExtension(all2, extensions[index2]);\n    }\n    return all2;\n  }\n  function syntaxExtension(all2, extension2) {\n    let hook;\n    for (hook in extension2) {\n      const maybe = hasOwnProperty.call(all2, hook) ? all2[hook] : void 0;\n      const left = maybe || (all2[hook] = {});\n      const right = extension2[hook];\n      let code;\n      if (right) {\n        for (code in right) {\n          if (!hasOwnProperty.call(left, code)) left[code] = [];\n          const value = right[code];\n          constructs(\n            // @ts-expect-error Looks like a list.\n            left[code],\n            Array.isArray(value) ? value : value ? [value] : []\n          );\n        }\n      }\n    }\n  }\n  function constructs(existing, list2) {\n    let index2 = -1;\n    const before = [];\n    while (++index2 < list2.length) {\n      (list2[index2].add === "after" ? existing : before).push(list2[index2]);\n    }\n    splice(existing, 0, 0, before);\n  }\n  function decodeNumericCharacterReference(value, base) {\n    const code = Number.parseInt(value, base);\n    if (\n      // C0 except for HT, LF, FF, CR, space.\n      code < 9 || code === 11 || code > 13 && code < 32 || // Control character (DEL) of C0, and C1 controls.\n      code > 126 && code < 160 || // Lone high surrogates and low surrogates.\n      code > 55295 && code < 57344 || // Noncharacters.\n      code > 64975 && code < 65008 || /* eslint-disable no-bitwise */\n      (code & 65535) === 65535 || (code & 65535) === 65534 || /* eslint-enable no-bitwise */\n      // Out of range\n      code > 1114111\n    ) {\n      return "ï¿½";\n    }\n    return String.fromCodePoint(code);\n  }\n  function normalizeIdentifier(value) {\n    return value.replace(/[\\t\\n\\r ]+/g, " ").replace(/^ | $/g, "").toLowerCase().toUpperCase();\n  }\n  const asciiAlpha = regexCheck(/[A-Za-z]/);\n  const asciiAlphanumeric = regexCheck(/[\\dA-Za-z]/);\n  const asciiAtext = regexCheck(/[#-\'*+\\--9=?A-Z^-~]/);\n  function asciiControl(code) {\n    return (\n      // Special whitespace codes (which have negative values), C0 and Control\n      // character DEL\n      code !== null && (code < 32 || code === 127)\n    );\n  }\n  const asciiDigit = regexCheck(/\\d/);\n  const asciiHexDigit = regexCheck(/[\\dA-Fa-f]/);\n  const asciiPunctuation = regexCheck(/[!-/:-@[-`{-~]/);\n  function markdownLineEnding(code) {\n    return code !== null && code < -2;\n  }\n  function markdownLineEndingOrSpace(code) {\n    return code !== null && (code < 0 || code === 32);\n  }\n  function markdownSpace(code) {\n    return code === -2 || code === -1 || code === 32;\n  }\n  const unicodePunctuation = regexCheck(/\\p{P}|\\p{S}/u);\n  const unicodeWhitespace = regexCheck(/\\s/);\n  function regexCheck(regex) {\n    return check;\n    function check(code) {\n      return code !== null && code > -1 && regex.test(String.fromCharCode(code));\n    }\n  }\n  function factorySpace(effects, ok, type2, max) {\n    const limit = max ? max - 1 : Number.POSITIVE_INFINITY;\n    let size = 0;\n    return start;\n    function start(code) {\n      if (markdownSpace(code)) {\n        effects.enter(type2);\n        return prefix(code);\n      }\n      return ok(code);\n    }\n    function prefix(code) {\n      if (markdownSpace(code) && size++ < limit) {\n        effects.consume(code);\n        return prefix;\n      }\n      effects.exit(type2);\n      return ok(code);\n    }\n  }\n  const content$1 = {\n    tokenize: initializeContent\n  };\n  function initializeContent(effects) {\n    const contentStart = effects.attempt(this.parser.constructs.contentInitial, afterContentStartConstruct, paragraphInitial);\n    let previous2;\n    return contentStart;\n    function afterContentStartConstruct(code) {\n      if (code === null) {\n        effects.consume(code);\n        return;\n      }\n      effects.enter("lineEnding");\n      effects.consume(code);\n      effects.exit("lineEnding");\n      return factorySpace(effects, contentStart, "linePrefix");\n    }\n    function paragraphInitial(code) {\n      effects.enter("paragraph");\n      return lineStart(code);\n    }\n    function lineStart(code) {\n      const token = effects.enter("chunkText", {\n        contentType: "text",\n        previous: previous2\n      });\n      if (previous2) {\n        previous2.next = token;\n      }\n      previous2 = token;\n      return data(code);\n    }\n    function data(code) {\n      if (code === null) {\n        effects.exit("chunkText");\n        effects.exit("paragraph");\n        effects.consume(code);\n        return;\n      }\n      if (markdownLineEnding(code)) {\n        effects.consume(code);\n        effects.exit("chunkText");\n        return lineStart;\n      }\n      effects.consume(code);\n      return data;\n    }\n  }\n  const document$1 = {\n    tokenize: initializeDocument\n  };\n  const containerConstruct = {\n    tokenize: tokenizeContainer\n  };\n  function initializeDocument(effects) {\n    const self2 = this;\n    const stack = [];\n    let continued = 0;\n    let childFlow;\n    let childToken;\n    let lineStartOffset;\n    return start;\n    function start(code) {\n      if (continued < stack.length) {\n        const item = stack[continued];\n        self2.containerState = item[1];\n        return effects.attempt(item[0].continuation, documentContinue, checkNewContainers)(code);\n      }\n      return checkNewContainers(code);\n    }\n    function documentContinue(code) {\n      continued++;\n      if (self2.containerState._closeFlow) {\n        self2.containerState._closeFlow = void 0;\n        if (childFlow) {\n          closeFlow();\n        }\n        const indexBeforeExits = self2.events.length;\n        let indexBeforeFlow = indexBeforeExits;\n        let point2;\n        while (indexBeforeFlow--) {\n          if (self2.events[indexBeforeFlow][0] === "exit" && self2.events[indexBeforeFlow][1].type === "chunkFlow") {\n            point2 = self2.events[indexBeforeFlow][1].end;\n            break;\n          }\n        }\n        exitContainers(continued);\n        let index2 = indexBeforeExits;\n        while (index2 < self2.events.length) {\n          self2.events[index2][1].end = {\n            ...point2\n          };\n          index2++;\n        }\n        splice(self2.events, indexBeforeFlow + 1, 0, self2.events.slice(indexBeforeExits));\n        self2.events.length = index2;\n        return checkNewContainers(code);\n      }\n      return start(code);\n    }\n    function checkNewContainers(code) {\n      if (continued === stack.length) {\n        if (!childFlow) {\n          return documentContinued(code);\n        }\n        if (childFlow.currentConstruct && childFlow.currentConstruct.concrete) {\n          return flowStart(code);\n        }\n        self2.interrupt = Boolean(childFlow.currentConstruct && !childFlow._gfmTableDynamicInterruptHack);\n      }\n      self2.containerState = {};\n      return effects.check(containerConstruct, thereIsANewContainer, thereIsNoNewContainer)(code);\n    }\n    function thereIsANewContainer(code) {\n      if (childFlow) closeFlow();\n      exitContainers(continued);\n      return documentContinued(code);\n    }\n    function thereIsNoNewContainer(code) {\n      self2.parser.lazy[self2.now().line] = continued !== stack.length;\n      lineStartOffset = self2.now().offset;\n      return flowStart(code);\n    }\n    function documentContinued(code) {\n      self2.containerState = {};\n      return effects.attempt(containerConstruct, containerContinue, flowStart)(code);\n    }\n    function containerContinue(code) {\n      continued++;\n      stack.push([self2.currentConstruct, self2.containerState]);\n      return documentContinued(code);\n    }\n    function flowStart(code) {\n      if (code === null) {\n        if (childFlow) closeFlow();\n        exitContainers(0);\n        effects.consume(code);\n        return;\n      }\n      childFlow = childFlow || self2.parser.flow(self2.now());\n      effects.enter("chunkFlow", {\n        _tokenizer: childFlow,\n        contentType: "flow",\n        previous: childToken\n      });\n      return flowContinue(code);\n    }\n    function flowContinue(code) {\n      if (code === null) {\n        writeToChild(effects.exit("chunkFlow"), true);\n        exitContainers(0);\n        effects.consume(code);\n        return;\n      }\n      if (markdownLineEnding(code)) {\n        effects.consume(code);\n        writeToChild(effects.exit("chunkFlow"));\n        continued = 0;\n        self2.interrupt = void 0;\n        return start;\n      }\n      effects.consume(code);\n      return flowContinue;\n    }\n    function writeToChild(token, endOfFile) {\n      const stream = self2.sliceStream(token);\n      if (endOfFile) stream.push(null);\n      token.previous = childToken;\n      if (childToken) childToken.next = token;\n      childToken = token;\n      childFlow.defineSkip(token.start);\n      childFlow.write(stream);\n      if (self2.parser.lazy[token.start.line]) {\n        let index2 = childFlow.events.length;\n        while (index2--) {\n          if (\n            // The token starts before the line endingâ€¦\n            childFlow.events[index2][1].start.offset < lineStartOffset && // â€¦and either is not ended yetâ€¦\n            (!childFlow.events[index2][1].end || // â€¦or ends after it.\n            childFlow.events[index2][1].end.offset > lineStartOffset)\n          ) {\n            return;\n          }\n        }\n        const indexBeforeExits = self2.events.length;\n        let indexBeforeFlow = indexBeforeExits;\n        let seen;\n        let point2;\n        while (indexBeforeFlow--) {\n          if (self2.events[indexBeforeFlow][0] === "exit" && self2.events[indexBeforeFlow][1].type === "chunkFlow") {\n            if (seen) {\n              point2 = self2.events[indexBeforeFlow][1].end;\n              break;\n            }\n            seen = true;\n          }\n        }\n        exitContainers(continued);\n        index2 = indexBeforeExits;\n        while (index2 < self2.events.length) {\n          self2.events[index2][1].end = {\n            ...point2\n          };\n          index2++;\n        }\n        splice(self2.events, indexBeforeFlow + 1, 0, self2.events.slice(indexBeforeExits));\n        self2.events.length = index2;\n      }\n    }\n    function exitContainers(size) {\n      let index2 = stack.length;\n      while (index2-- > size) {\n        const entry = stack[index2];\n        self2.containerState = entry[1];\n        entry[0].exit.call(self2, effects);\n      }\n      stack.length = size;\n    }\n    function closeFlow() {\n      childFlow.write([null]);\n      childToken = void 0;\n      childFlow = void 0;\n      self2.containerState._closeFlow = void 0;\n    }\n  }\n  function tokenizeContainer(effects, ok, nok) {\n    return factorySpace(effects, effects.attempt(this.parser.constructs.document, ok, nok), "linePrefix", this.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4);\n  }\n  function classifyCharacter(code) {\n    if (code === null || markdownLineEndingOrSpace(code) || unicodeWhitespace(code)) {\n      return 1;\n    }\n    if (unicodePunctuation(code)) {\n      return 2;\n    }\n  }\n  function resolveAll(constructs2, events, context) {\n    const called = [];\n    let index2 = -1;\n    while (++index2 < constructs2.length) {\n      const resolve = constructs2[index2].resolveAll;\n      if (resolve && !called.includes(resolve)) {\n        events = resolve(events, context);\n        called.push(resolve);\n      }\n    }\n    return events;\n  }\n  const attention = {\n    name: "attention",\n    resolveAll: resolveAllAttention,\n    tokenize: tokenizeAttention\n  };\n  function resolveAllAttention(events, context) {\n    let index2 = -1;\n    let open;\n    let group;\n    let text2;\n    let openingSequence;\n    let closingSequence;\n    let use;\n    let nextEvents;\n    let offset;\n    while (++index2 < events.length) {\n      if (events[index2][0] === "enter" && events[index2][1].type === "attentionSequence" && events[index2][1]._close) {\n        open = index2;\n        while (open--) {\n          if (events[open][0] === "exit" && events[open][1].type === "attentionSequence" && events[open][1]._open && // If the markers are the same:\n          context.sliceSerialize(events[open][1]).charCodeAt(0) === context.sliceSerialize(events[index2][1]).charCodeAt(0)) {\n            if ((events[open][1]._close || events[index2][1]._open) && (events[index2][1].end.offset - events[index2][1].start.offset) % 3 && !((events[open][1].end.offset - events[open][1].start.offset + events[index2][1].end.offset - events[index2][1].start.offset) % 3)) {\n              continue;\n            }\n            use = events[open][1].end.offset - events[open][1].start.offset > 1 && events[index2][1].end.offset - events[index2][1].start.offset > 1 ? 2 : 1;\n            const start = {\n              ...events[open][1].end\n            };\n            const end = {\n              ...events[index2][1].start\n            };\n            movePoint(start, -use);\n            movePoint(end, use);\n            openingSequence = {\n              type: use > 1 ? "strongSequence" : "emphasisSequence",\n              start,\n              end: {\n                ...events[open][1].end\n              }\n            };\n            closingSequence = {\n              type: use > 1 ? "strongSequence" : "emphasisSequence",\n              start: {\n                ...events[index2][1].start\n              },\n              end\n            };\n            text2 = {\n              type: use > 1 ? "strongText" : "emphasisText",\n              start: {\n                ...events[open][1].end\n              },\n              end: {\n                ...events[index2][1].start\n              }\n            };\n            group = {\n              type: use > 1 ? "strong" : "emphasis",\n              start: {\n                ...openingSequence.start\n              },\n              end: {\n                ...closingSequence.end\n              }\n            };\n            events[open][1].end = {\n              ...openingSequence.start\n            };\n            events[index2][1].start = {\n              ...closingSequence.end\n            };\n            nextEvents = [];\n            if (events[open][1].end.offset - events[open][1].start.offset) {\n              nextEvents = push(nextEvents, [["enter", events[open][1], context], ["exit", events[open][1], context]]);\n            }\n            nextEvents = push(nextEvents, [["enter", group, context], ["enter", openingSequence, context], ["exit", openingSequence, context], ["enter", text2, context]]);\n            nextEvents = push(nextEvents, resolveAll(context.parser.constructs.insideSpan.null, events.slice(open + 1, index2), context));\n            nextEvents = push(nextEvents, [["exit", text2, context], ["enter", closingSequence, context], ["exit", closingSequence, context], ["exit", group, context]]);\n            if (events[index2][1].end.offset - events[index2][1].start.offset) {\n              offset = 2;\n              nextEvents = push(nextEvents, [["enter", events[index2][1], context], ["exit", events[index2][1], context]]);\n            } else {\n              offset = 0;\n            }\n            splice(events, open - 1, index2 - open + 3, nextEvents);\n            index2 = open + nextEvents.length - offset - 2;\n            break;\n          }\n        }\n      }\n    }\n    index2 = -1;\n    while (++index2 < events.length) {\n      if (events[index2][1].type === "attentionSequence") {\n        events[index2][1].type = "data";\n      }\n    }\n    return events;\n  }\n  function tokenizeAttention(effects, ok) {\n    const attentionMarkers2 = this.parser.constructs.attentionMarkers.null;\n    const previous2 = this.previous;\n    const before = classifyCharacter(previous2);\n    let marker;\n    return start;\n    function start(code) {\n      marker = code;\n      effects.enter("attentionSequence");\n      return inside(code);\n    }\n    function inside(code) {\n      if (code === marker) {\n        effects.consume(code);\n        return inside;\n      }\n      const token = effects.exit("attentionSequence");\n      const after = classifyCharacter(code);\n      const open = !after || after === 2 && before || attentionMarkers2.includes(code);\n      const close = !before || before === 2 && after || attentionMarkers2.includes(previous2);\n      token._open = Boolean(marker === 42 ? open : open && (before || !close));\n      token._close = Boolean(marker === 42 ? close : close && (after || !open));\n      return ok(code);\n    }\n  }\n  function movePoint(point2, offset) {\n    point2.column += offset;\n    point2.offset += offset;\n    point2._bufferIndex += offset;\n  }\n  const autolink = {\n    name: "autolink",\n    tokenize: tokenizeAutolink\n  };\n  function tokenizeAutolink(effects, ok, nok) {\n    let size = 0;\n    return start;\n    function start(code) {\n      effects.enter("autolink");\n      effects.enter("autolinkMarker");\n      effects.consume(code);\n      effects.exit("autolinkMarker");\n      effects.enter("autolinkProtocol");\n      return open;\n    }\n    function open(code) {\n      if (asciiAlpha(code)) {\n        effects.consume(code);\n        return schemeOrEmailAtext;\n      }\n      if (code === 64) {\n        return nok(code);\n      }\n      return emailAtext(code);\n    }\n    function schemeOrEmailAtext(code) {\n      if (code === 43 || code === 45 || code === 46 || asciiAlphanumeric(code)) {\n        size = 1;\n        return schemeInsideOrEmailAtext(code);\n      }\n      return emailAtext(code);\n    }\n    function schemeInsideOrEmailAtext(code) {\n      if (code === 58) {\n        effects.consume(code);\n        size = 0;\n        return urlInside;\n      }\n      if ((code === 43 || code === 45 || code === 46 || asciiAlphanumeric(code)) && size++ < 32) {\n        effects.consume(code);\n        return schemeInsideOrEmailAtext;\n      }\n      size = 0;\n      return emailAtext(code);\n    }\n    function urlInside(code) {\n      if (code === 62) {\n        effects.exit("autolinkProtocol");\n        effects.enter("autolinkMarker");\n        effects.consume(code);\n        effects.exit("autolinkMarker");\n        effects.exit("autolink");\n        return ok;\n      }\n      if (code === null || code === 32 || code === 60 || asciiControl(code)) {\n        return nok(code);\n      }\n      effects.consume(code);\n      return urlInside;\n    }\n    function emailAtext(code) {\n      if (code === 64) {\n        effects.consume(code);\n        return emailAtSignOrDot;\n      }\n      if (asciiAtext(code)) {\n        effects.consume(code);\n        return emailAtext;\n      }\n      return nok(code);\n    }\n    function emailAtSignOrDot(code) {\n      return asciiAlphanumeric(code) ? emailLabel(code) : nok(code);\n    }\n    function emailLabel(code) {\n      if (code === 46) {\n        effects.consume(code);\n        size = 0;\n        return emailAtSignOrDot;\n      }\n      if (code === 62) {\n        effects.exit("autolinkProtocol").type = "autolinkEmail";\n        effects.enter("autolinkMarker");\n        effects.consume(code);\n        effects.exit("autolinkMarker");\n        effects.exit("autolink");\n        return ok;\n      }\n      return emailValue(code);\n    }\n    function emailValue(code) {\n      if ((code === 45 || asciiAlphanumeric(code)) && size++ < 63) {\n        const next = code === 45 ? emailValue : emailLabel;\n        effects.consume(code);\n        return next;\n      }\n      return nok(code);\n    }\n  }\n  const blankLine = {\n    partial: true,\n    tokenize: tokenizeBlankLine\n  };\n  function tokenizeBlankLine(effects, ok, nok) {\n    return start;\n    function start(code) {\n      return markdownSpace(code) ? factorySpace(effects, after, "linePrefix")(code) : after(code);\n    }\n    function after(code) {\n      return code === null || markdownLineEnding(code) ? ok(code) : nok(code);\n    }\n  }\n  const blockQuote = {\n    continuation: {\n      tokenize: tokenizeBlockQuoteContinuation\n    },\n    exit,\n    name: "blockQuote",\n    tokenize: tokenizeBlockQuoteStart\n  };\n  function tokenizeBlockQuoteStart(effects, ok, nok) {\n    const self2 = this;\n    return start;\n    function start(code) {\n      if (code === 62) {\n        const state = self2.containerState;\n        if (!state.open) {\n          effects.enter("blockQuote", {\n            _container: true\n          });\n          state.open = true;\n        }\n        effects.enter("blockQuotePrefix");\n        effects.enter("blockQuoteMarker");\n        effects.consume(code);\n        effects.exit("blockQuoteMarker");\n        return after;\n      }\n      return nok(code);\n    }\n    function after(code) {\n      if (markdownSpace(code)) {\n        effects.enter("blockQuotePrefixWhitespace");\n        effects.consume(code);\n        effects.exit("blockQuotePrefixWhitespace");\n        effects.exit("blockQuotePrefix");\n        return ok;\n      }\n      effects.exit("blockQuotePrefix");\n      return ok(code);\n    }\n  }\n  function tokenizeBlockQuoteContinuation(effects, ok, nok) {\n    const self2 = this;\n    return contStart;\n    function contStart(code) {\n      if (markdownSpace(code)) {\n        return factorySpace(effects, contBefore, "linePrefix", self2.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(code);\n      }\n      return contBefore(code);\n    }\n    function contBefore(code) {\n      return effects.attempt(blockQuote, ok, nok)(code);\n    }\n  }\n  function exit(effects) {\n    effects.exit("blockQuote");\n  }\n  const characterEscape = {\n    name: "characterEscape",\n    tokenize: tokenizeCharacterEscape\n  };\n  function tokenizeCharacterEscape(effects, ok, nok) {\n    return start;\n    function start(code) {\n      effects.enter("characterEscape");\n      effects.enter("escapeMarker");\n      effects.consume(code);\n      effects.exit("escapeMarker");\n      return inside;\n    }\n    function inside(code) {\n      if (asciiPunctuation(code)) {\n        effects.enter("characterEscapeValue");\n        effects.consume(code);\n        effects.exit("characterEscapeValue");\n        effects.exit("characterEscape");\n        return ok;\n      }\n      return nok(code);\n    }\n  }\n  const characterReference = {\n    name: "characterReference",\n    tokenize: tokenizeCharacterReference\n  };\n  function tokenizeCharacterReference(effects, ok, nok) {\n    const self2 = this;\n    let size = 0;\n    let max;\n    let test;\n    return start;\n    function start(code) {\n      effects.enter("characterReference");\n      effects.enter("characterReferenceMarker");\n      effects.consume(code);\n      effects.exit("characterReferenceMarker");\n      return open;\n    }\n    function open(code) {\n      if (code === 35) {\n        effects.enter("characterReferenceMarkerNumeric");\n        effects.consume(code);\n        effects.exit("characterReferenceMarkerNumeric");\n        return numeric;\n      }\n      effects.enter("characterReferenceValue");\n      max = 31;\n      test = asciiAlphanumeric;\n      return value(code);\n    }\n    function numeric(code) {\n      if (code === 88 || code === 120) {\n        effects.enter("characterReferenceMarkerHexadecimal");\n        effects.consume(code);\n        effects.exit("characterReferenceMarkerHexadecimal");\n        effects.enter("characterReferenceValue");\n        max = 6;\n        test = asciiHexDigit;\n        return value;\n      }\n      effects.enter("characterReferenceValue");\n      max = 7;\n      test = asciiDigit;\n      return value(code);\n    }\n    function value(code) {\n      if (code === 59 && size) {\n        const token = effects.exit("characterReferenceValue");\n        if (test === asciiAlphanumeric && !decodeNamedCharacterReference(self2.sliceSerialize(token))) {\n          return nok(code);\n        }\n        effects.enter("characterReferenceMarker");\n        effects.consume(code);\n        effects.exit("characterReferenceMarker");\n        effects.exit("characterReference");\n        return ok;\n      }\n      if (test(code) && size++ < max) {\n        effects.consume(code);\n        return value;\n      }\n      return nok(code);\n    }\n  }\n  const nonLazyContinuation = {\n    partial: true,\n    tokenize: tokenizeNonLazyContinuation\n  };\n  const codeFenced = {\n    concrete: true,\n    name: "codeFenced",\n    tokenize: tokenizeCodeFenced\n  };\n  function tokenizeCodeFenced(effects, ok, nok) {\n    const self2 = this;\n    const closeStart = {\n      partial: true,\n      tokenize: tokenizeCloseStart\n    };\n    let initialPrefix = 0;\n    let sizeOpen = 0;\n    let marker;\n    return start;\n    function start(code) {\n      return beforeSequenceOpen(code);\n    }\n    function beforeSequenceOpen(code) {\n      const tail = self2.events[self2.events.length - 1];\n      initialPrefix = tail && tail[1].type === "linePrefix" ? tail[2].sliceSerialize(tail[1], true).length : 0;\n      marker = code;\n      effects.enter("codeFenced");\n      effects.enter("codeFencedFence");\n      effects.enter("codeFencedFenceSequence");\n      return sequenceOpen(code);\n    }\n    function sequenceOpen(code) {\n      if (code === marker) {\n        sizeOpen++;\n        effects.consume(code);\n        return sequenceOpen;\n      }\n      if (sizeOpen < 3) {\n        return nok(code);\n      }\n      effects.exit("codeFencedFenceSequence");\n      return markdownSpace(code) ? factorySpace(effects, infoBefore, "whitespace")(code) : infoBefore(code);\n    }\n    function infoBefore(code) {\n      if (code === null || markdownLineEnding(code)) {\n        effects.exit("codeFencedFence");\n        return self2.interrupt ? ok(code) : effects.check(nonLazyContinuation, atNonLazyBreak, after)(code);\n      }\n      effects.enter("codeFencedFenceInfo");\n      effects.enter("chunkString", {\n        contentType: "string"\n      });\n      return info(code);\n    }\n    function info(code) {\n      if (code === null || markdownLineEnding(code)) {\n        effects.exit("chunkString");\n        effects.exit("codeFencedFenceInfo");\n        return infoBefore(code);\n      }\n      if (markdownSpace(code)) {\n        effects.exit("chunkString");\n        effects.exit("codeFencedFenceInfo");\n        return factorySpace(effects, metaBefore, "whitespace")(code);\n      }\n      if (code === 96 && code === marker) {\n        return nok(code);\n      }\n      effects.consume(code);\n      return info;\n    }\n    function metaBefore(code) {\n      if (code === null || markdownLineEnding(code)) {\n        return infoBefore(code);\n      }\n      effects.enter("codeFencedFenceMeta");\n      effects.enter("chunkString", {\n        contentType: "string"\n      });\n      return meta(code);\n    }\n    function meta(code) {\n      if (code === null || markdownLineEnding(code)) {\n        effects.exit("chunkString");\n        effects.exit("codeFencedFenceMeta");\n        return infoBefore(code);\n      }\n      if (code === 96 && code === marker) {\n        return nok(code);\n      }\n      effects.consume(code);\n      return meta;\n    }\n    function atNonLazyBreak(code) {\n      return effects.attempt(closeStart, after, contentBefore)(code);\n    }\n    function contentBefore(code) {\n      effects.enter("lineEnding");\n      effects.consume(code);\n      effects.exit("lineEnding");\n      return contentStart;\n    }\n    function contentStart(code) {\n      return initialPrefix > 0 && markdownSpace(code) ? factorySpace(effects, beforeContentChunk, "linePrefix", initialPrefix + 1)(code) : beforeContentChunk(code);\n    }\n    function beforeContentChunk(code) {\n      if (code === null || markdownLineEnding(code)) {\n        return effects.check(nonLazyContinuation, atNonLazyBreak, after)(code);\n      }\n      effects.enter("codeFlowValue");\n      return contentChunk(code);\n    }\n    function contentChunk(code) {\n      if (code === null || markdownLineEnding(code)) {\n        effects.exit("codeFlowValue");\n        return beforeContentChunk(code);\n      }\n      effects.consume(code);\n      return contentChunk;\n    }\n    function after(code) {\n      effects.exit("codeFenced");\n      return ok(code);\n    }\n    function tokenizeCloseStart(effects2, ok2, nok2) {\n      let size = 0;\n      return startBefore;\n      function startBefore(code) {\n        effects2.enter("lineEnding");\n        effects2.consume(code);\n        effects2.exit("lineEnding");\n        return start2;\n      }\n      function start2(code) {\n        effects2.enter("codeFencedFence");\n        return markdownSpace(code) ? factorySpace(effects2, beforeSequenceClose, "linePrefix", self2.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(code) : beforeSequenceClose(code);\n      }\n      function beforeSequenceClose(code) {\n        if (code === marker) {\n          effects2.enter("codeFencedFenceSequence");\n          return sequenceClose(code);\n        }\n        return nok2(code);\n      }\n      function sequenceClose(code) {\n        if (code === marker) {\n          size++;\n          effects2.consume(code);\n          return sequenceClose;\n        }\n        if (size >= sizeOpen) {\n          effects2.exit("codeFencedFenceSequence");\n          return markdownSpace(code) ? factorySpace(effects2, sequenceCloseAfter, "whitespace")(code) : sequenceCloseAfter(code);\n        }\n        return nok2(code);\n      }\n      function sequenceCloseAfter(code) {\n        if (code === null || markdownLineEnding(code)) {\n          effects2.exit("codeFencedFence");\n          return ok2(code);\n        }\n        return nok2(code);\n      }\n    }\n  }\n  function tokenizeNonLazyContinuation(effects, ok, nok) {\n    const self2 = this;\n    return start;\n    function start(code) {\n      if (code === null) {\n        return nok(code);\n      }\n      effects.enter("lineEnding");\n      effects.consume(code);\n      effects.exit("lineEnding");\n      return lineStart;\n    }\n    function lineStart(code) {\n      return self2.parser.lazy[self2.now().line] ? nok(code) : ok(code);\n    }\n  }\n  const codeIndented = {\n    name: "codeIndented",\n    tokenize: tokenizeCodeIndented\n  };\n  const furtherStart = {\n    partial: true,\n    tokenize: tokenizeFurtherStart\n  };\n  function tokenizeCodeIndented(effects, ok, nok) {\n    const self2 = this;\n    return start;\n    function start(code) {\n      effects.enter("codeIndented");\n      return factorySpace(effects, afterPrefix, "linePrefix", 4 + 1)(code);\n    }\n    function afterPrefix(code) {\n      const tail = self2.events[self2.events.length - 1];\n      return tail && tail[1].type === "linePrefix" && tail[2].sliceSerialize(tail[1], true).length >= 4 ? atBreak(code) : nok(code);\n    }\n    function atBreak(code) {\n      if (code === null) {\n        return after(code);\n      }\n      if (markdownLineEnding(code)) {\n        return effects.attempt(furtherStart, atBreak, after)(code);\n      }\n      effects.enter("codeFlowValue");\n      return inside(code);\n    }\n    function inside(code) {\n      if (code === null || markdownLineEnding(code)) {\n        effects.exit("codeFlowValue");\n        return atBreak(code);\n      }\n      effects.consume(code);\n      return inside;\n    }\n    function after(code) {\n      effects.exit("codeIndented");\n      return ok(code);\n    }\n  }\n  function tokenizeFurtherStart(effects, ok, nok) {\n    const self2 = this;\n    return furtherStart2;\n    function furtherStart2(code) {\n      if (self2.parser.lazy[self2.now().line]) {\n        return nok(code);\n      }\n      if (markdownLineEnding(code)) {\n        effects.enter("lineEnding");\n        effects.consume(code);\n        effects.exit("lineEnding");\n        return furtherStart2;\n      }\n      return factorySpace(effects, afterPrefix, "linePrefix", 4 + 1)(code);\n    }\n    function afterPrefix(code) {\n      const tail = self2.events[self2.events.length - 1];\n      return tail && tail[1].type === "linePrefix" && tail[2].sliceSerialize(tail[1], true).length >= 4 ? ok(code) : markdownLineEnding(code) ? furtherStart2(code) : nok(code);\n    }\n  }\n  const codeText = {\n    name: "codeText",\n    previous,\n    resolve: resolveCodeText,\n    tokenize: tokenizeCodeText\n  };\n  function resolveCodeText(events) {\n    let tailExitIndex = events.length - 4;\n    let headEnterIndex = 3;\n    let index2;\n    let enter;\n    if ((events[headEnterIndex][1].type === "lineEnding" || events[headEnterIndex][1].type === "space") && (events[tailExitIndex][1].type === "lineEnding" || events[tailExitIndex][1].type === "space")) {\n      index2 = headEnterIndex;\n      while (++index2 < tailExitIndex) {\n        if (events[index2][1].type === "codeTextData") {\n          events[headEnterIndex][1].type = "codeTextPadding";\n          events[tailExitIndex][1].type = "codeTextPadding";\n          headEnterIndex += 2;\n          tailExitIndex -= 2;\n          break;\n        }\n      }\n    }\n    index2 = headEnterIndex - 1;\n    tailExitIndex++;\n    while (++index2 <= tailExitIndex) {\n      if (enter === void 0) {\n        if (index2 !== tailExitIndex && events[index2][1].type !== "lineEnding") {\n          enter = index2;\n        }\n      } else if (index2 === tailExitIndex || events[index2][1].type === "lineEnding") {\n        events[enter][1].type = "codeTextData";\n        if (index2 !== enter + 2) {\n          events[enter][1].end = events[index2 - 1][1].end;\n          events.splice(enter + 2, index2 - enter - 2);\n          tailExitIndex -= index2 - enter - 2;\n          index2 = enter + 2;\n        }\n        enter = void 0;\n      }\n    }\n    return events;\n  }\n  function previous(code) {\n    return code !== 96 || this.events[this.events.length - 1][1].type === "characterEscape";\n  }\n  function tokenizeCodeText(effects, ok, nok) {\n    let sizeOpen = 0;\n    let size;\n    let token;\n    return start;\n    function start(code) {\n      effects.enter("codeText");\n      effects.enter("codeTextSequence");\n      return sequenceOpen(code);\n    }\n    function sequenceOpen(code) {\n      if (code === 96) {\n        effects.consume(code);\n        sizeOpen++;\n        return sequenceOpen;\n      }\n      effects.exit("codeTextSequence");\n      return between(code);\n    }\n    function between(code) {\n      if (code === null) {\n        return nok(code);\n      }\n      if (code === 32) {\n        effects.enter("space");\n        effects.consume(code);\n        effects.exit("space");\n        return between;\n      }\n      if (code === 96) {\n        token = effects.enter("codeTextSequence");\n        size = 0;\n        return sequenceClose(code);\n      }\n      if (markdownLineEnding(code)) {\n        effects.enter("lineEnding");\n        effects.consume(code);\n        effects.exit("lineEnding");\n        return between;\n      }\n      effects.enter("codeTextData");\n      return data(code);\n    }\n    function data(code) {\n      if (code === null || code === 32 || code === 96 || markdownLineEnding(code)) {\n        effects.exit("codeTextData");\n        return between(code);\n      }\n      effects.consume(code);\n      return data;\n    }\n    function sequenceClose(code) {\n      if (code === 96) {\n        effects.consume(code);\n        size++;\n        return sequenceClose;\n      }\n      if (size === sizeOpen) {\n        effects.exit("codeTextSequence");\n        effects.exit("codeText");\n        return ok(code);\n      }\n      token.type = "codeTextData";\n      return data(code);\n    }\n  }\n  class SpliceBuffer {\n    /**\n     * @param {ReadonlyArray<T> | null | undefined} [initial]\n     *   Initial items (optional).\n     * @returns\n     *   Splice buffer.\n     */\n    constructor(initial) {\n      this.left = initial ? [...initial] : [];\n      this.right = [];\n    }\n    /**\n     * Array access;\n     * does not move the cursor.\n     *\n     * @param {number} index\n     *   Index.\n     * @return {T}\n     *   Item.\n     */\n    get(index2) {\n      if (index2 < 0 || index2 >= this.left.length + this.right.length) {\n        throw new RangeError("Cannot access index `" + index2 + "` in a splice buffer of size `" + (this.left.length + this.right.length) + "`");\n      }\n      if (index2 < this.left.length) return this.left[index2];\n      return this.right[this.right.length - index2 + this.left.length - 1];\n    }\n    /**\n     * The length of the splice buffer, one greater than the largest index in the\n     * array.\n     */\n    get length() {\n      return this.left.length + this.right.length;\n    }\n    /**\n     * Remove and return `list[0]`;\n     * moves the cursor to `0`.\n     *\n     * @returns {T | undefined}\n     *   Item, optional.\n     */\n    shift() {\n      this.setCursor(0);\n      return this.right.pop();\n    }\n    /**\n     * Slice the buffer to get an array;\n     * does not move the cursor.\n     *\n     * @param {number} start\n     *   Start.\n     * @param {number | null | undefined} [end]\n     *   End (optional).\n     * @returns {Array<T>}\n     *   Array of items.\n     */\n    slice(start, end) {\n      const stop = end === null || end === void 0 ? Number.POSITIVE_INFINITY : end;\n      if (stop < this.left.length) {\n        return this.left.slice(start, stop);\n      }\n      if (start > this.left.length) {\n        return this.right.slice(this.right.length - stop + this.left.length, this.right.length - start + this.left.length).reverse();\n      }\n      return this.left.slice(start).concat(this.right.slice(this.right.length - stop + this.left.length).reverse());\n    }\n    /**\n     * Mimics the behavior of Array.prototype.splice() except for the change of\n     * interface necessary to avoid segfaults when patching in very large arrays.\n     *\n     * This operation moves cursor is moved to `start` and results in the cursor\n     * placed after any inserted items.\n     *\n     * @param {number} start\n     *   Start;\n     *   zero-based index at which to start changing the array;\n     *   negative numbers count backwards from the end of the array and values\n     *   that are out-of bounds are clamped to the appropriate end of the array.\n     * @param {number | null | undefined} [deleteCount=0]\n     *   Delete count (default: `0`);\n     *   maximum number of elements to delete, starting from start.\n     * @param {Array<T> | null | undefined} [items=[]]\n     *   Items to include in place of the deleted items (default: `[]`).\n     * @return {Array<T>}\n     *   Any removed items.\n     */\n    splice(start, deleteCount, items) {\n      const count = deleteCount || 0;\n      this.setCursor(Math.trunc(start));\n      const removed = this.right.splice(this.right.length - count, Number.POSITIVE_INFINITY);\n      if (items) chunkedPush(this.left, items);\n      return removed.reverse();\n    }\n    /**\n     * Remove and return the highest-numbered item in the array, so\n     * `list[list.length - 1]`;\n     * Moves the cursor to `length`.\n     *\n     * @returns {T | undefined}\n     *   Item, optional.\n     */\n    pop() {\n      this.setCursor(Number.POSITIVE_INFINITY);\n      return this.left.pop();\n    }\n    /**\n     * Inserts a single item to the high-numbered side of the array;\n     * moves the cursor to `length`.\n     *\n     * @param {T} item\n     *   Item.\n     * @returns {undefined}\n     *   Nothing.\n     */\n    push(item) {\n      this.setCursor(Number.POSITIVE_INFINITY);\n      this.left.push(item);\n    }\n    /**\n     * Inserts many items to the high-numbered side of the array.\n     * Moves the cursor to `length`.\n     *\n     * @param {Array<T>} items\n     *   Items.\n     * @returns {undefined}\n     *   Nothing.\n     */\n    pushMany(items) {\n      this.setCursor(Number.POSITIVE_INFINITY);\n      chunkedPush(this.left, items);\n    }\n    /**\n     * Inserts a single item to the low-numbered side of the array;\n     * Moves the cursor to `0`.\n     *\n     * @param {T} item\n     *   Item.\n     * @returns {undefined}\n     *   Nothing.\n     */\n    unshift(item) {\n      this.setCursor(0);\n      this.right.push(item);\n    }\n    /**\n     * Inserts many items to the low-numbered side of the array;\n     * moves the cursor to `0`.\n     *\n     * @param {Array<T>} items\n     *   Items.\n     * @returns {undefined}\n     *   Nothing.\n     */\n    unshiftMany(items) {\n      this.setCursor(0);\n      chunkedPush(this.right, items.reverse());\n    }\n    /**\n     * Move the cursor to a specific position in the array. Requires\n     * time proportional to the distance moved.\n     *\n     * If `n < 0`, the cursor will end up at the beginning.\n     * If `n > length`, the cursor will end up at the end.\n     *\n     * @param {number} n\n     *   Position.\n     * @return {undefined}\n     *   Nothing.\n     */\n    setCursor(n) {\n      if (n === this.left.length || n > this.left.length && this.right.length === 0 || n < 0 && this.left.length === 0) return;\n      if (n < this.left.length) {\n        const removed = this.left.splice(n, Number.POSITIVE_INFINITY);\n        chunkedPush(this.right, removed.reverse());\n      } else {\n        const removed = this.right.splice(this.left.length + this.right.length - n, Number.POSITIVE_INFINITY);\n        chunkedPush(this.left, removed.reverse());\n      }\n    }\n  }\n  function chunkedPush(list2, right) {\n    let chunkStart = 0;\n    if (right.length < 1e4) {\n      list2.push(...right);\n    } else {\n      while (chunkStart < right.length) {\n        list2.push(...right.slice(chunkStart, chunkStart + 1e4));\n        chunkStart += 1e4;\n      }\n    }\n  }\n  function subtokenize(eventsArray) {\n    const jumps = {};\n    let index2 = -1;\n    let event;\n    let lineIndex;\n    let otherIndex;\n    let otherEvent;\n    let parameters;\n    let subevents;\n    let more;\n    const events = new SpliceBuffer(eventsArray);\n    while (++index2 < events.length) {\n      while (index2 in jumps) {\n        index2 = jumps[index2];\n      }\n      event = events.get(index2);\n      if (index2 && event[1].type === "chunkFlow" && events.get(index2 - 1)[1].type === "listItemPrefix") {\n        subevents = event[1]._tokenizer.events;\n        otherIndex = 0;\n        if (otherIndex < subevents.length && subevents[otherIndex][1].type === "lineEndingBlank") {\n          otherIndex += 2;\n        }\n        if (otherIndex < subevents.length && subevents[otherIndex][1].type === "content") {\n          while (++otherIndex < subevents.length) {\n            if (subevents[otherIndex][1].type === "content") {\n              break;\n            }\n            if (subevents[otherIndex][1].type === "chunkText") {\n              subevents[otherIndex][1]._isInFirstContentOfListItem = true;\n              otherIndex++;\n            }\n          }\n        }\n      }\n      if (event[0] === "enter") {\n        if (event[1].contentType) {\n          Object.assign(jumps, subcontent(events, index2));\n          index2 = jumps[index2];\n          more = true;\n        }\n      } else if (event[1]._container) {\n        otherIndex = index2;\n        lineIndex = void 0;\n        while (otherIndex--) {\n          otherEvent = events.get(otherIndex);\n          if (otherEvent[1].type === "lineEnding" || otherEvent[1].type === "lineEndingBlank") {\n            if (otherEvent[0] === "enter") {\n              if (lineIndex) {\n                events.get(lineIndex)[1].type = "lineEndingBlank";\n              }\n              otherEvent[1].type = "lineEnding";\n              lineIndex = otherIndex;\n            }\n          } else if (otherEvent[1].type === "linePrefix" || otherEvent[1].type === "listItemIndent") ;\n          else {\n            break;\n          }\n        }\n        if (lineIndex) {\n          event[1].end = {\n            ...events.get(lineIndex)[1].start\n          };\n          parameters = events.slice(lineIndex, index2);\n          parameters.unshift(event);\n          events.splice(lineIndex, index2 - lineIndex + 1, parameters);\n        }\n      }\n    }\n    splice(eventsArray, 0, Number.POSITIVE_INFINITY, events.slice(0));\n    return !more;\n  }\n  function subcontent(events, eventIndex) {\n    const token = events.get(eventIndex)[1];\n    const context = events.get(eventIndex)[2];\n    let startPosition = eventIndex - 1;\n    const startPositions = [];\n    let tokenizer = token._tokenizer;\n    if (!tokenizer) {\n      tokenizer = context.parser[token.contentType](token.start);\n      if (token._contentTypeTextTrailing) {\n        tokenizer._contentTypeTextTrailing = true;\n      }\n    }\n    const childEvents = tokenizer.events;\n    const jumps = [];\n    const gaps = {};\n    let stream;\n    let previous2;\n    let index2 = -1;\n    let current = token;\n    let adjust = 0;\n    let start = 0;\n    const breaks = [start];\n    while (current) {\n      while (events.get(++startPosition)[1] !== current) {\n      }\n      startPositions.push(startPosition);\n      if (!current._tokenizer) {\n        stream = context.sliceStream(current);\n        if (!current.next) {\n          stream.push(null);\n        }\n        if (previous2) {\n          tokenizer.defineSkip(current.start);\n        }\n        if (current._isInFirstContentOfListItem) {\n          tokenizer._gfmTasklistFirstContentOfListItem = true;\n        }\n        tokenizer.write(stream);\n        if (current._isInFirstContentOfListItem) {\n          tokenizer._gfmTasklistFirstContentOfListItem = void 0;\n        }\n      }\n      previous2 = current;\n      current = current.next;\n    }\n    current = token;\n    while (++index2 < childEvents.length) {\n      if (\n        // Find a void token that includes a break.\n        childEvents[index2][0] === "exit" && childEvents[index2 - 1][0] === "enter" && childEvents[index2][1].type === childEvents[index2 - 1][1].type && childEvents[index2][1].start.line !== childEvents[index2][1].end.line\n      ) {\n        start = index2 + 1;\n        breaks.push(start);\n        current._tokenizer = void 0;\n        current.previous = void 0;\n        current = current.next;\n      }\n    }\n    tokenizer.events = [];\n    if (current) {\n      current._tokenizer = void 0;\n      current.previous = void 0;\n    } else {\n      breaks.pop();\n    }\n    index2 = breaks.length;\n    while (index2--) {\n      const slice = childEvents.slice(breaks[index2], breaks[index2 + 1]);\n      const start2 = startPositions.pop();\n      jumps.push([start2, start2 + slice.length - 1]);\n      events.splice(start2, 2, slice);\n    }\n    jumps.reverse();\n    index2 = -1;\n    while (++index2 < jumps.length) {\n      gaps[adjust + jumps[index2][0]] = adjust + jumps[index2][1];\n      adjust += jumps[index2][1] - jumps[index2][0] - 1;\n    }\n    return gaps;\n  }\n  const content = {\n    resolve: resolveContent,\n    tokenize: tokenizeContent\n  };\n  const continuationConstruct = {\n    partial: true,\n    tokenize: tokenizeContinuation\n  };\n  function resolveContent(events) {\n    subtokenize(events);\n    return events;\n  }\n  function tokenizeContent(effects, ok) {\n    let previous2;\n    return chunkStart;\n    function chunkStart(code) {\n      effects.enter("content");\n      previous2 = effects.enter("chunkContent", {\n        contentType: "content"\n      });\n      return chunkInside(code);\n    }\n    function chunkInside(code) {\n      if (code === null) {\n        return contentEnd(code);\n      }\n      if (markdownLineEnding(code)) {\n        return effects.check(continuationConstruct, contentContinue, contentEnd)(code);\n      }\n      effects.consume(code);\n      return chunkInside;\n    }\n    function contentEnd(code) {\n      effects.exit("chunkContent");\n      effects.exit("content");\n      return ok(code);\n    }\n    function contentContinue(code) {\n      effects.consume(code);\n      effects.exit("chunkContent");\n      previous2.next = effects.enter("chunkContent", {\n        contentType: "content",\n        previous: previous2\n      });\n      previous2 = previous2.next;\n      return chunkInside;\n    }\n  }\n  function tokenizeContinuation(effects, ok, nok) {\n    const self2 = this;\n    return startLookahead;\n    function startLookahead(code) {\n      effects.exit("chunkContent");\n      effects.enter("lineEnding");\n      effects.consume(code);\n      effects.exit("lineEnding");\n      return factorySpace(effects, prefixed, "linePrefix");\n    }\n    function prefixed(code) {\n      if (code === null || markdownLineEnding(code)) {\n        return nok(code);\n      }\n      const tail = self2.events[self2.events.length - 1];\n      if (!self2.parser.constructs.disable.null.includes("codeIndented") && tail && tail[1].type === "linePrefix" && tail[2].sliceSerialize(tail[1], true).length >= 4) {\n        return ok(code);\n      }\n      return effects.interrupt(self2.parser.constructs.flow, nok, ok)(code);\n    }\n  }\n  function factoryDestination(effects, ok, nok, type2, literalType, literalMarkerType, rawType, stringType, max) {\n    const limit = max || Number.POSITIVE_INFINITY;\n    let balance = 0;\n    return start;\n    function start(code) {\n      if (code === 60) {\n        effects.enter(type2);\n        effects.enter(literalType);\n        effects.enter(literalMarkerType);\n        effects.consume(code);\n        effects.exit(literalMarkerType);\n        return enclosedBefore;\n      }\n      if (code === null || code === 32 || code === 41 || asciiControl(code)) {\n        return nok(code);\n      }\n      effects.enter(type2);\n      effects.enter(rawType);\n      effects.enter(stringType);\n      effects.enter("chunkString", {\n        contentType: "string"\n      });\n      return raw(code);\n    }\n    function enclosedBefore(code) {\n      if (code === 62) {\n        effects.enter(literalMarkerType);\n        effects.consume(code);\n        effects.exit(literalMarkerType);\n        effects.exit(literalType);\n        effects.exit(type2);\n        return ok;\n      }\n      effects.enter(stringType);\n      effects.enter("chunkString", {\n        contentType: "string"\n      });\n      return enclosed(code);\n    }\n    function enclosed(code) {\n      if (code === 62) {\n        effects.exit("chunkString");\n        effects.exit(stringType);\n        return enclosedBefore(code);\n      }\n      if (code === null || code === 60 || markdownLineEnding(code)) {\n        return nok(code);\n      }\n      effects.consume(code);\n      return code === 92 ? enclosedEscape : enclosed;\n    }\n    function enclosedEscape(code) {\n      if (code === 60 || code === 62 || code === 92) {\n        effects.consume(code);\n        return enclosed;\n      }\n      return enclosed(code);\n    }\n    function raw(code) {\n      if (!balance && (code === null || code === 41 || markdownLineEndingOrSpace(code))) {\n        effects.exit("chunkString");\n        effects.exit(stringType);\n        effects.exit(rawType);\n        effects.exit(type2);\n        return ok(code);\n      }\n      if (balance < limit && code === 40) {\n        effects.consume(code);\n        balance++;\n        return raw;\n      }\n      if (code === 41) {\n        effects.consume(code);\n        balance--;\n        return raw;\n      }\n      if (code === null || code === 32 || code === 40 || asciiControl(code)) {\n        return nok(code);\n      }\n      effects.consume(code);\n      return code === 92 ? rawEscape : raw;\n    }\n    function rawEscape(code) {\n      if (code === 40 || code === 41 || code === 92) {\n        effects.consume(code);\n        return raw;\n      }\n      return raw(code);\n    }\n  }\n  function factoryLabel(effects, ok, nok, type2, markerType, stringType) {\n    const self2 = this;\n    let size = 0;\n    let seen;\n    return start;\n    function start(code) {\n      effects.enter(type2);\n      effects.enter(markerType);\n      effects.consume(code);\n      effects.exit(markerType);\n      effects.enter(stringType);\n      return atBreak;\n    }\n    function atBreak(code) {\n      if (size > 999 || code === null || code === 91 || code === 93 && !seen || // To do: remove in the future once weâ€™ve switched from\n      // `micromark-extension-footnote` to `micromark-extension-gfm-footnote`,\n      // which doesnâ€™t need this.\n      // Hidden footnotes hook.\n      /* c8 ignore next 3 */\n      code === 94 && !size && "_hiddenFootnoteSupport" in self2.parser.constructs) {\n        return nok(code);\n      }\n      if (code === 93) {\n        effects.exit(stringType);\n        effects.enter(markerType);\n        effects.consume(code);\n        effects.exit(markerType);\n        effects.exit(type2);\n        return ok;\n      }\n      if (markdownLineEnding(code)) {\n        effects.enter("lineEnding");\n        effects.consume(code);\n        effects.exit("lineEnding");\n        return atBreak;\n      }\n      effects.enter("chunkString", {\n        contentType: "string"\n      });\n      return labelInside(code);\n    }\n    function labelInside(code) {\n      if (code === null || code === 91 || code === 93 || markdownLineEnding(code) || size++ > 999) {\n        effects.exit("chunkString");\n        return atBreak(code);\n      }\n      effects.consume(code);\n      if (!seen) seen = !markdownSpace(code);\n      return code === 92 ? labelEscape : labelInside;\n    }\n    function labelEscape(code) {\n      if (code === 91 || code === 92 || code === 93) {\n        effects.consume(code);\n        size++;\n        return labelInside;\n      }\n      return labelInside(code);\n    }\n  }\n  function factoryTitle(effects, ok, nok, type2, markerType, stringType) {\n    let marker;\n    return start;\n    function start(code) {\n      if (code === 34 || code === 39 || code === 40) {\n        effects.enter(type2);\n        effects.enter(markerType);\n        effects.consume(code);\n        effects.exit(markerType);\n        marker = code === 40 ? 41 : code;\n        return begin;\n      }\n      return nok(code);\n    }\n    function begin(code) {\n      if (code === marker) {\n        effects.enter(markerType);\n        effects.consume(code);\n        effects.exit(markerType);\n        effects.exit(type2);\n        return ok;\n      }\n      effects.enter(stringType);\n      return atBreak(code);\n    }\n    function atBreak(code) {\n      if (code === marker) {\n        effects.exit(stringType);\n        return begin(marker);\n      }\n      if (code === null) {\n        return nok(code);\n      }\n      if (markdownLineEnding(code)) {\n        effects.enter("lineEnding");\n        effects.consume(code);\n        effects.exit("lineEnding");\n        return factorySpace(effects, atBreak, "linePrefix");\n      }\n      effects.enter("chunkString", {\n        contentType: "string"\n      });\n      return inside(code);\n    }\n    function inside(code) {\n      if (code === marker || code === null || markdownLineEnding(code)) {\n        effects.exit("chunkString");\n        return atBreak(code);\n      }\n      effects.consume(code);\n      return code === 92 ? escape : inside;\n    }\n    function escape(code) {\n      if (code === marker || code === 92) {\n        effects.consume(code);\n        return inside;\n      }\n      return inside(code);\n    }\n  }\n  function factoryWhitespace(effects, ok) {\n    let seen;\n    return start;\n    function start(code) {\n      if (markdownLineEnding(code)) {\n        effects.enter("lineEnding");\n        effects.consume(code);\n        effects.exit("lineEnding");\n        seen = true;\n        return start;\n      }\n      if (markdownSpace(code)) {\n        return factorySpace(effects, start, seen ? "linePrefix" : "lineSuffix")(code);\n      }\n      return ok(code);\n    }\n  }\n  const definition = {\n    name: "definition",\n    tokenize: tokenizeDefinition\n  };\n  const titleBefore = {\n    partial: true,\n    tokenize: tokenizeTitleBefore\n  };\n  function tokenizeDefinition(effects, ok, nok) {\n    const self2 = this;\n    let identifier;\n    return start;\n    function start(code) {\n      effects.enter("definition");\n      return before(code);\n    }\n    function before(code) {\n      return factoryLabel.call(\n        self2,\n        effects,\n        labelAfter,\n        // Note: we donâ€™t need to reset the way `markdown-rs` does.\n        nok,\n        "definitionLabel",\n        "definitionLabelMarker",\n        "definitionLabelString"\n      )(code);\n    }\n    function labelAfter(code) {\n      identifier = normalizeIdentifier(self2.sliceSerialize(self2.events[self2.events.length - 1][1]).slice(1, -1));\n      if (code === 58) {\n        effects.enter("definitionMarker");\n        effects.consume(code);\n        effects.exit("definitionMarker");\n        return markerAfter;\n      }\n      return nok(code);\n    }\n    function markerAfter(code) {\n      return markdownLineEndingOrSpace(code) ? factoryWhitespace(effects, destinationBefore)(code) : destinationBefore(code);\n    }\n    function destinationBefore(code) {\n      return factoryDestination(\n        effects,\n        destinationAfter,\n        // Note: we donâ€™t need to reset the way `markdown-rs` does.\n        nok,\n        "definitionDestination",\n        "definitionDestinationLiteral",\n        "definitionDestinationLiteralMarker",\n        "definitionDestinationRaw",\n        "definitionDestinationString"\n      )(code);\n    }\n    function destinationAfter(code) {\n      return effects.attempt(titleBefore, after, after)(code);\n    }\n    function after(code) {\n      return markdownSpace(code) ? factorySpace(effects, afterWhitespace, "whitespace")(code) : afterWhitespace(code);\n    }\n    function afterWhitespace(code) {\n      if (code === null || markdownLineEnding(code)) {\n        effects.exit("definition");\n        self2.parser.defined.push(identifier);\n        return ok(code);\n      }\n      return nok(code);\n    }\n  }\n  function tokenizeTitleBefore(effects, ok, nok) {\n    return titleBefore2;\n    function titleBefore2(code) {\n      return markdownLineEndingOrSpace(code) ? factoryWhitespace(effects, beforeMarker)(code) : nok(code);\n    }\n    function beforeMarker(code) {\n      return factoryTitle(effects, titleAfter, nok, "definitionTitle", "definitionTitleMarker", "definitionTitleString")(code);\n    }\n    function titleAfter(code) {\n      return markdownSpace(code) ? factorySpace(effects, titleAfterOptionalWhitespace, "whitespace")(code) : titleAfterOptionalWhitespace(code);\n    }\n    function titleAfterOptionalWhitespace(code) {\n      return code === null || markdownLineEnding(code) ? ok(code) : nok(code);\n    }\n  }\n  const hardBreakEscape = {\n    name: "hardBreakEscape",\n    tokenize: tokenizeHardBreakEscape\n  };\n  function tokenizeHardBreakEscape(effects, ok, nok) {\n    return start;\n    function start(code) {\n      effects.enter("hardBreakEscape");\n      effects.consume(code);\n      return after;\n    }\n    function after(code) {\n      if (markdownLineEnding(code)) {\n        effects.exit("hardBreakEscape");\n        return ok(code);\n      }\n      return nok(code);\n    }\n  }\n  const headingAtx = {\n    name: "headingAtx",\n    resolve: resolveHeadingAtx,\n    tokenize: tokenizeHeadingAtx\n  };\n  function resolveHeadingAtx(events, context) {\n    let contentEnd = events.length - 2;\n    let contentStart = 3;\n    let content2;\n    let text2;\n    if (events[contentStart][1].type === "whitespace") {\n      contentStart += 2;\n    }\n    if (contentEnd - 2 > contentStart && events[contentEnd][1].type === "whitespace") {\n      contentEnd -= 2;\n    }\n    if (events[contentEnd][1].type === "atxHeadingSequence" && (contentStart === contentEnd - 1 || contentEnd - 4 > contentStart && events[contentEnd - 2][1].type === "whitespace")) {\n      contentEnd -= contentStart + 1 === contentEnd ? 2 : 4;\n    }\n    if (contentEnd > contentStart) {\n      content2 = {\n        type: "atxHeadingText",\n        start: events[contentStart][1].start,\n        end: events[contentEnd][1].end\n      };\n      text2 = {\n        type: "chunkText",\n        start: events[contentStart][1].start,\n        end: events[contentEnd][1].end,\n        contentType: "text"\n      };\n      splice(events, contentStart, contentEnd - contentStart + 1, [["enter", content2, context], ["enter", text2, context], ["exit", text2, context], ["exit", content2, context]]);\n    }\n    return events;\n  }\n  function tokenizeHeadingAtx(effects, ok, nok) {\n    let size = 0;\n    return start;\n    function start(code) {\n      effects.enter("atxHeading");\n      return before(code);\n    }\n    function before(code) {\n      effects.enter("atxHeadingSequence");\n      return sequenceOpen(code);\n    }\n    function sequenceOpen(code) {\n      if (code === 35 && size++ < 6) {\n        effects.consume(code);\n        return sequenceOpen;\n      }\n      if (code === null || markdownLineEndingOrSpace(code)) {\n        effects.exit("atxHeadingSequence");\n        return atBreak(code);\n      }\n      return nok(code);\n    }\n    function atBreak(code) {\n      if (code === 35) {\n        effects.enter("atxHeadingSequence");\n        return sequenceFurther(code);\n      }\n      if (code === null || markdownLineEnding(code)) {\n        effects.exit("atxHeading");\n        return ok(code);\n      }\n      if (markdownSpace(code)) {\n        return factorySpace(effects, atBreak, "whitespace")(code);\n      }\n      effects.enter("atxHeadingText");\n      return data(code);\n    }\n    function sequenceFurther(code) {\n      if (code === 35) {\n        effects.consume(code);\n        return sequenceFurther;\n      }\n      effects.exit("atxHeadingSequence");\n      return atBreak(code);\n    }\n    function data(code) {\n      if (code === null || code === 35 || markdownLineEndingOrSpace(code)) {\n        effects.exit("atxHeadingText");\n        return atBreak(code);\n      }\n      effects.consume(code);\n      return data;\n    }\n  }\n  const htmlBlockNames = [\n    "address",\n    "article",\n    "aside",\n    "base",\n    "basefont",\n    "blockquote",\n    "body",\n    "caption",\n    "center",\n    "col",\n    "colgroup",\n    "dd",\n    "details",\n    "dialog",\n    "dir",\n    "div",\n    "dl",\n    "dt",\n    "fieldset",\n    "figcaption",\n    "figure",\n    "footer",\n    "form",\n    "frame",\n    "frameset",\n    "h1",\n    "h2",\n    "h3",\n    "h4",\n    "h5",\n    "h6",\n    "head",\n    "header",\n    "hr",\n    "html",\n    "iframe",\n    "legend",\n    "li",\n    "link",\n    "main",\n    "menu",\n    "menuitem",\n    "nav",\n    "noframes",\n    "ol",\n    "optgroup",\n    "option",\n    "p",\n    "param",\n    "search",\n    "section",\n    "summary",\n    "table",\n    "tbody",\n    "td",\n    "tfoot",\n    "th",\n    "thead",\n    "title",\n    "tr",\n    "track",\n    "ul"\n  ];\n  const htmlRawNames = ["pre", "script", "style", "textarea"];\n  const htmlFlow = {\n    concrete: true,\n    name: "htmlFlow",\n    resolveTo: resolveToHtmlFlow,\n    tokenize: tokenizeHtmlFlow\n  };\n  const blankLineBefore = {\n    partial: true,\n    tokenize: tokenizeBlankLineBefore\n  };\n  const nonLazyContinuationStart = {\n    partial: true,\n    tokenize: tokenizeNonLazyContinuationStart\n  };\n  function resolveToHtmlFlow(events) {\n    let index2 = events.length;\n    while (index2--) {\n      if (events[index2][0] === "enter" && events[index2][1].type === "htmlFlow") {\n        break;\n      }\n    }\n    if (index2 > 1 && events[index2 - 2][1].type === "linePrefix") {\n      events[index2][1].start = events[index2 - 2][1].start;\n      events[index2 + 1][1].start = events[index2 - 2][1].start;\n      events.splice(index2 - 2, 2);\n    }\n    return events;\n  }\n  function tokenizeHtmlFlow(effects, ok, nok) {\n    const self2 = this;\n    let marker;\n    let closingTag;\n    let buffer;\n    let index2;\n    let markerB;\n    return start;\n    function start(code) {\n      return before(code);\n    }\n    function before(code) {\n      effects.enter("htmlFlow");\n      effects.enter("htmlFlowData");\n      effects.consume(code);\n      return open;\n    }\n    function open(code) {\n      if (code === 33) {\n        effects.consume(code);\n        return declarationOpen;\n      }\n      if (code === 47) {\n        effects.consume(code);\n        closingTag = true;\n        return tagCloseStart;\n      }\n      if (code === 63) {\n        effects.consume(code);\n        marker = 3;\n        return self2.interrupt ? ok : continuationDeclarationInside;\n      }\n      if (asciiAlpha(code)) {\n        effects.consume(code);\n        buffer = String.fromCharCode(code);\n        return tagName;\n      }\n      return nok(code);\n    }\n    function declarationOpen(code) {\n      if (code === 45) {\n        effects.consume(code);\n        marker = 2;\n        return commentOpenInside;\n      }\n      if (code === 91) {\n        effects.consume(code);\n        marker = 5;\n        index2 = 0;\n        return cdataOpenInside;\n      }\n      if (asciiAlpha(code)) {\n        effects.consume(code);\n        marker = 4;\n        return self2.interrupt ? ok : continuationDeclarationInside;\n      }\n      return nok(code);\n    }\n    function commentOpenInside(code) {\n      if (code === 45) {\n        effects.consume(code);\n        return self2.interrupt ? ok : continuationDeclarationInside;\n      }\n      return nok(code);\n    }\n    function cdataOpenInside(code) {\n      const value = "CDATA[";\n      if (code === value.charCodeAt(index2++)) {\n        effects.consume(code);\n        if (index2 === value.length) {\n          return self2.interrupt ? ok : continuation;\n        }\n        return cdataOpenInside;\n      }\n      return nok(code);\n    }\n    function tagCloseStart(code) {\n      if (asciiAlpha(code)) {\n        effects.consume(code);\n        buffer = String.fromCharCode(code);\n        return tagName;\n      }\n      return nok(code);\n    }\n    function tagName(code) {\n      if (code === null || code === 47 || code === 62 || markdownLineEndingOrSpace(code)) {\n        const slash = code === 47;\n        const name = buffer.toLowerCase();\n        if (!slash && !closingTag && htmlRawNames.includes(name)) {\n          marker = 1;\n          return self2.interrupt ? ok(code) : continuation(code);\n        }\n        if (htmlBlockNames.includes(buffer.toLowerCase())) {\n          marker = 6;\n          if (slash) {\n            effects.consume(code);\n            return basicSelfClosing;\n          }\n          return self2.interrupt ? ok(code) : continuation(code);\n        }\n        marker = 7;\n        return self2.interrupt && !self2.parser.lazy[self2.now().line] ? nok(code) : closingTag ? completeClosingTagAfter(code) : completeAttributeNameBefore(code);\n      }\n      if (code === 45 || asciiAlphanumeric(code)) {\n        effects.consume(code);\n        buffer += String.fromCharCode(code);\n        return tagName;\n      }\n      return nok(code);\n    }\n    function basicSelfClosing(code) {\n      if (code === 62) {\n        effects.consume(code);\n        return self2.interrupt ? ok : continuation;\n      }\n      return nok(code);\n    }\n    function completeClosingTagAfter(code) {\n      if (markdownSpace(code)) {\n        effects.consume(code);\n        return completeClosingTagAfter;\n      }\n      return completeEnd(code);\n    }\n    function completeAttributeNameBefore(code) {\n      if (code === 47) {\n        effects.consume(code);\n        return completeEnd;\n      }\n      if (code === 58 || code === 95 || asciiAlpha(code)) {\n        effects.consume(code);\n        return completeAttributeName;\n      }\n      if (markdownSpace(code)) {\n        effects.consume(code);\n        return completeAttributeNameBefore;\n      }\n      return completeEnd(code);\n    }\n    function completeAttributeName(code) {\n      if (code === 45 || code === 46 || code === 58 || code === 95 || asciiAlphanumeric(code)) {\n        effects.consume(code);\n        return completeAttributeName;\n      }\n      return completeAttributeNameAfter(code);\n    }\n    function completeAttributeNameAfter(code) {\n      if (code === 61) {\n        effects.consume(code);\n        return completeAttributeValueBefore;\n      }\n      if (markdownSpace(code)) {\n        effects.consume(code);\n        return completeAttributeNameAfter;\n      }\n      return completeAttributeNameBefore(code);\n    }\n    function completeAttributeValueBefore(code) {\n      if (code === null || code === 60 || code === 61 || code === 62 || code === 96) {\n        return nok(code);\n      }\n      if (code === 34 || code === 39) {\n        effects.consume(code);\n        markerB = code;\n        return completeAttributeValueQuoted;\n      }\n      if (markdownSpace(code)) {\n        effects.consume(code);\n        return completeAttributeValueBefore;\n      }\n      return completeAttributeValueUnquoted(code);\n    }\n    function completeAttributeValueQuoted(code) {\n      if (code === markerB) {\n        effects.consume(code);\n        markerB = null;\n        return completeAttributeValueQuotedAfter;\n      }\n      if (code === null || markdownLineEnding(code)) {\n        return nok(code);\n      }\n      effects.consume(code);\n      return completeAttributeValueQuoted;\n    }\n    function completeAttributeValueUnquoted(code) {\n      if (code === null || code === 34 || code === 39 || code === 47 || code === 60 || code === 61 || code === 62 || code === 96 || markdownLineEndingOrSpace(code)) {\n        return completeAttributeNameAfter(code);\n      }\n      effects.consume(code);\n      return completeAttributeValueUnquoted;\n    }\n    function completeAttributeValueQuotedAfter(code) {\n      if (code === 47 || code === 62 || markdownSpace(code)) {\n        return completeAttributeNameBefore(code);\n      }\n      return nok(code);\n    }\n    function completeEnd(code) {\n      if (code === 62) {\n        effects.consume(code);\n        return completeAfter;\n      }\n      return nok(code);\n    }\n    function completeAfter(code) {\n      if (code === null || markdownLineEnding(code)) {\n        return continuation(code);\n      }\n      if (markdownSpace(code)) {\n        effects.consume(code);\n        return completeAfter;\n      }\n      return nok(code);\n    }\n    function continuation(code) {\n      if (code === 45 && marker === 2) {\n        effects.consume(code);\n        return continuationCommentInside;\n      }\n      if (code === 60 && marker === 1) {\n        effects.consume(code);\n        return continuationRawTagOpen;\n      }\n      if (code === 62 && marker === 4) {\n        effects.consume(code);\n        return continuationClose;\n      }\n      if (code === 63 && marker === 3) {\n        effects.consume(code);\n        return continuationDeclarationInside;\n      }\n      if (code === 93 && marker === 5) {\n        effects.consume(code);\n        return continuationCdataInside;\n      }\n      if (markdownLineEnding(code) && (marker === 6 || marker === 7)) {\n        effects.exit("htmlFlowData");\n        return effects.check(blankLineBefore, continuationAfter, continuationStart)(code);\n      }\n      if (code === null || markdownLineEnding(code)) {\n        effects.exit("htmlFlowData");\n        return continuationStart(code);\n      }\n      effects.consume(code);\n      return continuation;\n    }\n    function continuationStart(code) {\n      return effects.check(nonLazyContinuationStart, continuationStartNonLazy, continuationAfter)(code);\n    }\n    function continuationStartNonLazy(code) {\n      effects.enter("lineEnding");\n      effects.consume(code);\n      effects.exit("lineEnding");\n      return continuationBefore;\n    }\n    function continuationBefore(code) {\n      if (code === null || markdownLineEnding(code)) {\n        return continuationStart(code);\n      }\n      effects.enter("htmlFlowData");\n      return continuation(code);\n    }\n    function continuationCommentInside(code) {\n      if (code === 45) {\n        effects.consume(code);\n        return continuationDeclarationInside;\n      }\n      return continuation(code);\n    }\n    function continuationRawTagOpen(code) {\n      if (code === 47) {\n        effects.consume(code);\n        buffer = "";\n        return continuationRawEndTag;\n      }\n      return continuation(code);\n    }\n    function continuationRawEndTag(code) {\n      if (code === 62) {\n        const name = buffer.toLowerCase();\n        if (htmlRawNames.includes(name)) {\n          effects.consume(code);\n          return continuationClose;\n        }\n        return continuation(code);\n      }\n      if (asciiAlpha(code) && buffer.length < 8) {\n        effects.consume(code);\n        buffer += String.fromCharCode(code);\n        return continuationRawEndTag;\n      }\n      return continuation(code);\n    }\n    function continuationCdataInside(code) {\n      if (code === 93) {\n        effects.consume(code);\n        return continuationDeclarationInside;\n      }\n      return continuation(code);\n    }\n    function continuationDeclarationInside(code) {\n      if (code === 62) {\n        effects.consume(code);\n        return continuationClose;\n      }\n      if (code === 45 && marker === 2) {\n        effects.consume(code);\n        return continuationDeclarationInside;\n      }\n      return continuation(code);\n    }\n    function continuationClose(code) {\n      if (code === null || markdownLineEnding(code)) {\n        effects.exit("htmlFlowData");\n        return continuationAfter(code);\n      }\n      effects.consume(code);\n      return continuationClose;\n    }\n    function continuationAfter(code) {\n      effects.exit("htmlFlow");\n      return ok(code);\n    }\n  }\n  function tokenizeNonLazyContinuationStart(effects, ok, nok) {\n    const self2 = this;\n    return start;\n    function start(code) {\n      if (markdownLineEnding(code)) {\n        effects.enter("lineEnding");\n        effects.consume(code);\n        effects.exit("lineEnding");\n        return after;\n      }\n      return nok(code);\n    }\n    function after(code) {\n      return self2.parser.lazy[self2.now().line] ? nok(code) : ok(code);\n    }\n  }\n  function tokenizeBlankLineBefore(effects, ok, nok) {\n    return start;\n    function start(code) {\n      effects.enter("lineEnding");\n      effects.consume(code);\n      effects.exit("lineEnding");\n      return effects.attempt(blankLine, ok, nok);\n    }\n  }\n  const htmlText = {\n    name: "htmlText",\n    tokenize: tokenizeHtmlText\n  };\n  function tokenizeHtmlText(effects, ok, nok) {\n    const self2 = this;\n    let marker;\n    let index2;\n    let returnState;\n    return start;\n    function start(code) {\n      effects.enter("htmlText");\n      effects.enter("htmlTextData");\n      effects.consume(code);\n      return open;\n    }\n    function open(code) {\n      if (code === 33) {\n        effects.consume(code);\n        return declarationOpen;\n      }\n      if (code === 47) {\n        effects.consume(code);\n        return tagCloseStart;\n      }\n      if (code === 63) {\n        effects.consume(code);\n        return instruction;\n      }\n      if (asciiAlpha(code)) {\n        effects.consume(code);\n        return tagOpen;\n      }\n      return nok(code);\n    }\n    function declarationOpen(code) {\n      if (code === 45) {\n        effects.consume(code);\n        return commentOpenInside;\n      }\n      if (code === 91) {\n        effects.consume(code);\n        index2 = 0;\n        return cdataOpenInside;\n      }\n      if (asciiAlpha(code)) {\n        effects.consume(code);\n        return declaration;\n      }\n      return nok(code);\n    }\n    function commentOpenInside(code) {\n      if (code === 45) {\n        effects.consume(code);\n        return commentEnd;\n      }\n      return nok(code);\n    }\n    function comment(code) {\n      if (code === null) {\n        return nok(code);\n      }\n      if (code === 45) {\n        effects.consume(code);\n        return commentClose;\n      }\n      if (markdownLineEnding(code)) {\n        returnState = comment;\n        return lineEndingBefore(code);\n      }\n      effects.consume(code);\n      return comment;\n    }\n    function commentClose(code) {\n      if (code === 45) {\n        effects.consume(code);\n        return commentEnd;\n      }\n      return comment(code);\n    }\n    function commentEnd(code) {\n      return code === 62 ? end(code) : code === 45 ? commentClose(code) : comment(code);\n    }\n    function cdataOpenInside(code) {\n      const value = "CDATA[";\n      if (code === value.charCodeAt(index2++)) {\n        effects.consume(code);\n        return index2 === value.length ? cdata : cdataOpenInside;\n      }\n      return nok(code);\n    }\n    function cdata(code) {\n      if (code === null) {\n        return nok(code);\n      }\n      if (code === 93) {\n        effects.consume(code);\n        return cdataClose;\n      }\n      if (markdownLineEnding(code)) {\n        returnState = cdata;\n        return lineEndingBefore(code);\n      }\n      effects.consume(code);\n      return cdata;\n    }\n    function cdataClose(code) {\n      if (code === 93) {\n        effects.consume(code);\n        return cdataEnd;\n      }\n      return cdata(code);\n    }\n    function cdataEnd(code) {\n      if (code === 62) {\n        return end(code);\n      }\n      if (code === 93) {\n        effects.consume(code);\n        return cdataEnd;\n      }\n      return cdata(code);\n    }\n    function declaration(code) {\n      if (code === null || code === 62) {\n        return end(code);\n      }\n      if (markdownLineEnding(code)) {\n        returnState = declaration;\n        return lineEndingBefore(code);\n      }\n      effects.consume(code);\n      return declaration;\n    }\n    function instruction(code) {\n      if (code === null) {\n        return nok(code);\n      }\n      if (code === 63) {\n        effects.consume(code);\n        return instructionClose;\n      }\n      if (markdownLineEnding(code)) {\n        returnState = instruction;\n        return lineEndingBefore(code);\n      }\n      effects.consume(code);\n      return instruction;\n    }\n    function instructionClose(code) {\n      return code === 62 ? end(code) : instruction(code);\n    }\n    function tagCloseStart(code) {\n      if (asciiAlpha(code)) {\n        effects.consume(code);\n        return tagClose;\n      }\n      return nok(code);\n    }\n    function tagClose(code) {\n      if (code === 45 || asciiAlphanumeric(code)) {\n        effects.consume(code);\n        return tagClose;\n      }\n      return tagCloseBetween(code);\n    }\n    function tagCloseBetween(code) {\n      if (markdownLineEnding(code)) {\n        returnState = tagCloseBetween;\n        return lineEndingBefore(code);\n      }\n      if (markdownSpace(code)) {\n        effects.consume(code);\n        return tagCloseBetween;\n      }\n      return end(code);\n    }\n    function tagOpen(code) {\n      if (code === 45 || asciiAlphanumeric(code)) {\n        effects.consume(code);\n        return tagOpen;\n      }\n      if (code === 47 || code === 62 || markdownLineEndingOrSpace(code)) {\n        return tagOpenBetween(code);\n      }\n      return nok(code);\n    }\n    function tagOpenBetween(code) {\n      if (code === 47) {\n        effects.consume(code);\n        return end;\n      }\n      if (code === 58 || code === 95 || asciiAlpha(code)) {\n        effects.consume(code);\n        return tagOpenAttributeName;\n      }\n      if (markdownLineEnding(code)) {\n        returnState = tagOpenBetween;\n        return lineEndingBefore(code);\n      }\n      if (markdownSpace(code)) {\n        effects.consume(code);\n        return tagOpenBetween;\n      }\n      return end(code);\n    }\n    function tagOpenAttributeName(code) {\n      if (code === 45 || code === 46 || code === 58 || code === 95 || asciiAlphanumeric(code)) {\n        effects.consume(code);\n        return tagOpenAttributeName;\n      }\n      return tagOpenAttributeNameAfter(code);\n    }\n    function tagOpenAttributeNameAfter(code) {\n      if (code === 61) {\n        effects.consume(code);\n        return tagOpenAttributeValueBefore;\n      }\n      if (markdownLineEnding(code)) {\n        returnState = tagOpenAttributeNameAfter;\n        return lineEndingBefore(code);\n      }\n      if (markdownSpace(code)) {\n        effects.consume(code);\n        return tagOpenAttributeNameAfter;\n      }\n      return tagOpenBetween(code);\n    }\n    function tagOpenAttributeValueBefore(code) {\n      if (code === null || code === 60 || code === 61 || code === 62 || code === 96) {\n        return nok(code);\n      }\n      if (code === 34 || code === 39) {\n        effects.consume(code);\n        marker = code;\n        return tagOpenAttributeValueQuoted;\n      }\n      if (markdownLineEnding(code)) {\n        returnState = tagOpenAttributeValueBefore;\n        return lineEndingBefore(code);\n      }\n      if (markdownSpace(code)) {\n        effects.consume(code);\n        return tagOpenAttributeValueBefore;\n      }\n      effects.consume(code);\n      return tagOpenAttributeValueUnquoted;\n    }\n    function tagOpenAttributeValueQuoted(code) {\n      if (code === marker) {\n        effects.consume(code);\n        marker = void 0;\n        return tagOpenAttributeValueQuotedAfter;\n      }\n      if (code === null) {\n        return nok(code);\n      }\n      if (markdownLineEnding(code)) {\n        returnState = tagOpenAttributeValueQuoted;\n        return lineEndingBefore(code);\n      }\n      effects.consume(code);\n      return tagOpenAttributeValueQuoted;\n    }\n    function tagOpenAttributeValueUnquoted(code) {\n      if (code === null || code === 34 || code === 39 || code === 60 || code === 61 || code === 96) {\n        return nok(code);\n      }\n      if (code === 47 || code === 62 || markdownLineEndingOrSpace(code)) {\n        return tagOpenBetween(code);\n      }\n      effects.consume(code);\n      return tagOpenAttributeValueUnquoted;\n    }\n    function tagOpenAttributeValueQuotedAfter(code) {\n      if (code === 47 || code === 62 || markdownLineEndingOrSpace(code)) {\n        return tagOpenBetween(code);\n      }\n      return nok(code);\n    }\n    function end(code) {\n      if (code === 62) {\n        effects.consume(code);\n        effects.exit("htmlTextData");\n        effects.exit("htmlText");\n        return ok;\n      }\n      return nok(code);\n    }\n    function lineEndingBefore(code) {\n      effects.exit("htmlTextData");\n      effects.enter("lineEnding");\n      effects.consume(code);\n      effects.exit("lineEnding");\n      return lineEndingAfter;\n    }\n    function lineEndingAfter(code) {\n      return markdownSpace(code) ? factorySpace(effects, lineEndingAfterPrefix, "linePrefix", self2.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(code) : lineEndingAfterPrefix(code);\n    }\n    function lineEndingAfterPrefix(code) {\n      effects.enter("htmlTextData");\n      return returnState(code);\n    }\n  }\n  const labelEnd = {\n    name: "labelEnd",\n    resolveAll: resolveAllLabelEnd,\n    resolveTo: resolveToLabelEnd,\n    tokenize: tokenizeLabelEnd\n  };\n  const resourceConstruct = {\n    tokenize: tokenizeResource\n  };\n  const referenceFullConstruct = {\n    tokenize: tokenizeReferenceFull\n  };\n  const referenceCollapsedConstruct = {\n    tokenize: tokenizeReferenceCollapsed\n  };\n  function resolveAllLabelEnd(events) {\n    let index2 = -1;\n    const newEvents = [];\n    while (++index2 < events.length) {\n      const token = events[index2][1];\n      newEvents.push(events[index2]);\n      if (token.type === "labelImage" || token.type === "labelLink" || token.type === "labelEnd") {\n        const offset = token.type === "labelImage" ? 4 : 2;\n        token.type = "data";\n        index2 += offset;\n      }\n    }\n    if (events.length !== newEvents.length) {\n      splice(events, 0, events.length, newEvents);\n    }\n    return events;\n  }\n  function resolveToLabelEnd(events, context) {\n    let index2 = events.length;\n    let offset = 0;\n    let token;\n    let open;\n    let close;\n    let media;\n    while (index2--) {\n      token = events[index2][1];\n      if (open) {\n        if (token.type === "link" || token.type === "labelLink" && token._inactive) {\n          break;\n        }\n        if (events[index2][0] === "enter" && token.type === "labelLink") {\n          token._inactive = true;\n        }\n      } else if (close) {\n        if (events[index2][0] === "enter" && (token.type === "labelImage" || token.type === "labelLink") && !token._balanced) {\n          open = index2;\n          if (token.type !== "labelLink") {\n            offset = 2;\n            break;\n          }\n        }\n      } else if (token.type === "labelEnd") {\n        close = index2;\n      }\n    }\n    const group = {\n      type: events[open][1].type === "labelLink" ? "link" : "image",\n      start: {\n        ...events[open][1].start\n      },\n      end: {\n        ...events[events.length - 1][1].end\n      }\n    };\n    const label = {\n      type: "label",\n      start: {\n        ...events[open][1].start\n      },\n      end: {\n        ...events[close][1].end\n      }\n    };\n    const text2 = {\n      type: "labelText",\n      start: {\n        ...events[open + offset + 2][1].end\n      },\n      end: {\n        ...events[close - 2][1].start\n      }\n    };\n    media = [["enter", group, context], ["enter", label, context]];\n    media = push(media, events.slice(open + 1, open + offset + 3));\n    media = push(media, [["enter", text2, context]]);\n    media = push(media, resolveAll(context.parser.constructs.insideSpan.null, events.slice(open + offset + 4, close - 3), context));\n    media = push(media, [["exit", text2, context], events[close - 2], events[close - 1], ["exit", label, context]]);\n    media = push(media, events.slice(close + 1));\n    media = push(media, [["exit", group, context]]);\n    splice(events, open, events.length, media);\n    return events;\n  }\n  function tokenizeLabelEnd(effects, ok, nok) {\n    const self2 = this;\n    let index2 = self2.events.length;\n    let labelStart;\n    let defined;\n    while (index2--) {\n      if ((self2.events[index2][1].type === "labelImage" || self2.events[index2][1].type === "labelLink") && !self2.events[index2][1]._balanced) {\n        labelStart = self2.events[index2][1];\n        break;\n      }\n    }\n    return start;\n    function start(code) {\n      if (!labelStart) {\n        return nok(code);\n      }\n      if (labelStart._inactive) {\n        return labelEndNok(code);\n      }\n      defined = self2.parser.defined.includes(normalizeIdentifier(self2.sliceSerialize({\n        start: labelStart.end,\n        end: self2.now()\n      })));\n      effects.enter("labelEnd");\n      effects.enter("labelMarker");\n      effects.consume(code);\n      effects.exit("labelMarker");\n      effects.exit("labelEnd");\n      return after;\n    }\n    function after(code) {\n      if (code === 40) {\n        return effects.attempt(resourceConstruct, labelEndOk, defined ? labelEndOk : labelEndNok)(code);\n      }\n      if (code === 91) {\n        return effects.attempt(referenceFullConstruct, labelEndOk, defined ? referenceNotFull : labelEndNok)(code);\n      }\n      return defined ? labelEndOk(code) : labelEndNok(code);\n    }\n    function referenceNotFull(code) {\n      return effects.attempt(referenceCollapsedConstruct, labelEndOk, labelEndNok)(code);\n    }\n    function labelEndOk(code) {\n      return ok(code);\n    }\n    function labelEndNok(code) {\n      labelStart._balanced = true;\n      return nok(code);\n    }\n  }\n  function tokenizeResource(effects, ok, nok) {\n    return resourceStart;\n    function resourceStart(code) {\n      effects.enter("resource");\n      effects.enter("resourceMarker");\n      effects.consume(code);\n      effects.exit("resourceMarker");\n      return resourceBefore;\n    }\n    function resourceBefore(code) {\n      return markdownLineEndingOrSpace(code) ? factoryWhitespace(effects, resourceOpen)(code) : resourceOpen(code);\n    }\n    function resourceOpen(code) {\n      if (code === 41) {\n        return resourceEnd(code);\n      }\n      return factoryDestination(effects, resourceDestinationAfter, resourceDestinationMissing, "resourceDestination", "resourceDestinationLiteral", "resourceDestinationLiteralMarker", "resourceDestinationRaw", "resourceDestinationString", 32)(code);\n    }\n    function resourceDestinationAfter(code) {\n      return markdownLineEndingOrSpace(code) ? factoryWhitespace(effects, resourceBetween)(code) : resourceEnd(code);\n    }\n    function resourceDestinationMissing(code) {\n      return nok(code);\n    }\n    function resourceBetween(code) {\n      if (code === 34 || code === 39 || code === 40) {\n        return factoryTitle(effects, resourceTitleAfter, nok, "resourceTitle", "resourceTitleMarker", "resourceTitleString")(code);\n      }\n      return resourceEnd(code);\n    }\n    function resourceTitleAfter(code) {\n      return markdownLineEndingOrSpace(code) ? factoryWhitespace(effects, resourceEnd)(code) : resourceEnd(code);\n    }\n    function resourceEnd(code) {\n      if (code === 41) {\n        effects.enter("resourceMarker");\n        effects.consume(code);\n        effects.exit("resourceMarker");\n        effects.exit("resource");\n        return ok;\n      }\n      return nok(code);\n    }\n  }\n  function tokenizeReferenceFull(effects, ok, nok) {\n    const self2 = this;\n    return referenceFull;\n    function referenceFull(code) {\n      return factoryLabel.call(self2, effects, referenceFullAfter, referenceFullMissing, "reference", "referenceMarker", "referenceString")(code);\n    }\n    function referenceFullAfter(code) {\n      return self2.parser.defined.includes(normalizeIdentifier(self2.sliceSerialize(self2.events[self2.events.length - 1][1]).slice(1, -1))) ? ok(code) : nok(code);\n    }\n    function referenceFullMissing(code) {\n      return nok(code);\n    }\n  }\n  function tokenizeReferenceCollapsed(effects, ok, nok) {\n    return referenceCollapsedStart;\n    function referenceCollapsedStart(code) {\n      effects.enter("reference");\n      effects.enter("referenceMarker");\n      effects.consume(code);\n      effects.exit("referenceMarker");\n      return referenceCollapsedOpen;\n    }\n    function referenceCollapsedOpen(code) {\n      if (code === 93) {\n        effects.enter("referenceMarker");\n        effects.consume(code);\n        effects.exit("referenceMarker");\n        effects.exit("reference");\n        return ok;\n      }\n      return nok(code);\n    }\n  }\n  const labelStartImage = {\n    name: "labelStartImage",\n    resolveAll: labelEnd.resolveAll,\n    tokenize: tokenizeLabelStartImage\n  };\n  function tokenizeLabelStartImage(effects, ok, nok) {\n    const self2 = this;\n    return start;\n    function start(code) {\n      effects.enter("labelImage");\n      effects.enter("labelImageMarker");\n      effects.consume(code);\n      effects.exit("labelImageMarker");\n      return open;\n    }\n    function open(code) {\n      if (code === 91) {\n        effects.enter("labelMarker");\n        effects.consume(code);\n        effects.exit("labelMarker");\n        effects.exit("labelImage");\n        return after;\n      }\n      return nok(code);\n    }\n    function after(code) {\n      return code === 94 && "_hiddenFootnoteSupport" in self2.parser.constructs ? nok(code) : ok(code);\n    }\n  }\n  const labelStartLink = {\n    name: "labelStartLink",\n    resolveAll: labelEnd.resolveAll,\n    tokenize: tokenizeLabelStartLink\n  };\n  function tokenizeLabelStartLink(effects, ok, nok) {\n    const self2 = this;\n    return start;\n    function start(code) {\n      effects.enter("labelLink");\n      effects.enter("labelMarker");\n      effects.consume(code);\n      effects.exit("labelMarker");\n      effects.exit("labelLink");\n      return after;\n    }\n    function after(code) {\n      return code === 94 && "_hiddenFootnoteSupport" in self2.parser.constructs ? nok(code) : ok(code);\n    }\n  }\n  const lineEnding = {\n    name: "lineEnding",\n    tokenize: tokenizeLineEnding\n  };\n  function tokenizeLineEnding(effects, ok) {\n    return start;\n    function start(code) {\n      effects.enter("lineEnding");\n      effects.consume(code);\n      effects.exit("lineEnding");\n      return factorySpace(effects, ok, "linePrefix");\n    }\n  }\n  const thematicBreak = {\n    name: "thematicBreak",\n    tokenize: tokenizeThematicBreak\n  };\n  function tokenizeThematicBreak(effects, ok, nok) {\n    let size = 0;\n    let marker;\n    return start;\n    function start(code) {\n      effects.enter("thematicBreak");\n      return before(code);\n    }\n    function before(code) {\n      marker = code;\n      return atBreak(code);\n    }\n    function atBreak(code) {\n      if (code === marker) {\n        effects.enter("thematicBreakSequence");\n        return sequence(code);\n      }\n      if (size >= 3 && (code === null || markdownLineEnding(code))) {\n        effects.exit("thematicBreak");\n        return ok(code);\n      }\n      return nok(code);\n    }\n    function sequence(code) {\n      if (code === marker) {\n        effects.consume(code);\n        size++;\n        return sequence;\n      }\n      effects.exit("thematicBreakSequence");\n      return markdownSpace(code) ? factorySpace(effects, atBreak, "whitespace")(code) : atBreak(code);\n    }\n  }\n  const list = {\n    continuation: {\n      tokenize: tokenizeListContinuation\n    },\n    exit: tokenizeListEnd,\n    name: "list",\n    tokenize: tokenizeListStart\n  };\n  const listItemPrefixWhitespaceConstruct = {\n    partial: true,\n    tokenize: tokenizeListItemPrefixWhitespace\n  };\n  const indentConstruct = {\n    partial: true,\n    tokenize: tokenizeIndent\n  };\n  function tokenizeListStart(effects, ok, nok) {\n    const self2 = this;\n    const tail = self2.events[self2.events.length - 1];\n    let initialSize = tail && tail[1].type === "linePrefix" ? tail[2].sliceSerialize(tail[1], true).length : 0;\n    let size = 0;\n    return start;\n    function start(code) {\n      const kind = self2.containerState.type || (code === 42 || code === 43 || code === 45 ? "listUnordered" : "listOrdered");\n      if (kind === "listUnordered" ? !self2.containerState.marker || code === self2.containerState.marker : asciiDigit(code)) {\n        if (!self2.containerState.type) {\n          self2.containerState.type = kind;\n          effects.enter(kind, {\n            _container: true\n          });\n        }\n        if (kind === "listUnordered") {\n          effects.enter("listItemPrefix");\n          return code === 42 || code === 45 ? effects.check(thematicBreak, nok, atMarker)(code) : atMarker(code);\n        }\n        if (!self2.interrupt || code === 49) {\n          effects.enter("listItemPrefix");\n          effects.enter("listItemValue");\n          return inside(code);\n        }\n      }\n      return nok(code);\n    }\n    function inside(code) {\n      if (asciiDigit(code) && ++size < 10) {\n        effects.consume(code);\n        return inside;\n      }\n      if ((!self2.interrupt || size < 2) && (self2.containerState.marker ? code === self2.containerState.marker : code === 41 || code === 46)) {\n        effects.exit("listItemValue");\n        return atMarker(code);\n      }\n      return nok(code);\n    }\n    function atMarker(code) {\n      effects.enter("listItemMarker");\n      effects.consume(code);\n      effects.exit("listItemMarker");\n      self2.containerState.marker = self2.containerState.marker || code;\n      return effects.check(\n        blankLine,\n        // Canâ€™t be empty when interrupting.\n        self2.interrupt ? nok : onBlank,\n        effects.attempt(listItemPrefixWhitespaceConstruct, endOfPrefix, otherPrefix)\n      );\n    }\n    function onBlank(code) {\n      self2.containerState.initialBlankLine = true;\n      initialSize++;\n      return endOfPrefix(code);\n    }\n    function otherPrefix(code) {\n      if (markdownSpace(code)) {\n        effects.enter("listItemPrefixWhitespace");\n        effects.consume(code);\n        effects.exit("listItemPrefixWhitespace");\n        return endOfPrefix;\n      }\n      return nok(code);\n    }\n    function endOfPrefix(code) {\n      self2.containerState.size = initialSize + self2.sliceSerialize(effects.exit("listItemPrefix"), true).length;\n      return ok(code);\n    }\n  }\n  function tokenizeListContinuation(effects, ok, nok) {\n    const self2 = this;\n    self2.containerState._closeFlow = void 0;\n    return effects.check(blankLine, onBlank, notBlank);\n    function onBlank(code) {\n      self2.containerState.furtherBlankLines = self2.containerState.furtherBlankLines || self2.containerState.initialBlankLine;\n      return factorySpace(effects, ok, "listItemIndent", self2.containerState.size + 1)(code);\n    }\n    function notBlank(code) {\n      if (self2.containerState.furtherBlankLines || !markdownSpace(code)) {\n        self2.containerState.furtherBlankLines = void 0;\n        self2.containerState.initialBlankLine = void 0;\n        return notInCurrentItem(code);\n      }\n      self2.containerState.furtherBlankLines = void 0;\n      self2.containerState.initialBlankLine = void 0;\n      return effects.attempt(indentConstruct, ok, notInCurrentItem)(code);\n    }\n    function notInCurrentItem(code) {\n      self2.containerState._closeFlow = true;\n      self2.interrupt = void 0;\n      return factorySpace(effects, effects.attempt(list, ok, nok), "linePrefix", self2.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(code);\n    }\n  }\n  function tokenizeIndent(effects, ok, nok) {\n    const self2 = this;\n    return factorySpace(effects, afterPrefix, "listItemIndent", self2.containerState.size + 1);\n    function afterPrefix(code) {\n      const tail = self2.events[self2.events.length - 1];\n      return tail && tail[1].type === "listItemIndent" && tail[2].sliceSerialize(tail[1], true).length === self2.containerState.size ? ok(code) : nok(code);\n    }\n  }\n  function tokenizeListEnd(effects) {\n    effects.exit(this.containerState.type);\n  }\n  function tokenizeListItemPrefixWhitespace(effects, ok, nok) {\n    const self2 = this;\n    return factorySpace(effects, afterPrefix, "listItemPrefixWhitespace", self2.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4 + 1);\n    function afterPrefix(code) {\n      const tail = self2.events[self2.events.length - 1];\n      return !markdownSpace(code) && tail && tail[1].type === "listItemPrefixWhitespace" ? ok(code) : nok(code);\n    }\n  }\n  const setextUnderline = {\n    name: "setextUnderline",\n    resolveTo: resolveToSetextUnderline,\n    tokenize: tokenizeSetextUnderline\n  };\n  function resolveToSetextUnderline(events, context) {\n    let index2 = events.length;\n    let content2;\n    let text2;\n    let definition2;\n    while (index2--) {\n      if (events[index2][0] === "enter") {\n        if (events[index2][1].type === "content") {\n          content2 = index2;\n          break;\n        }\n        if (events[index2][1].type === "paragraph") {\n          text2 = index2;\n        }\n      } else {\n        if (events[index2][1].type === "content") {\n          events.splice(index2, 1);\n        }\n        if (!definition2 && events[index2][1].type === "definition") {\n          definition2 = index2;\n        }\n      }\n    }\n    const heading = {\n      type: "setextHeading",\n      start: {\n        ...events[content2][1].start\n      },\n      end: {\n        ...events[events.length - 1][1].end\n      }\n    };\n    events[text2][1].type = "setextHeadingText";\n    if (definition2) {\n      events.splice(text2, 0, ["enter", heading, context]);\n      events.splice(definition2 + 1, 0, ["exit", events[content2][1], context]);\n      events[content2][1].end = {\n        ...events[definition2][1].end\n      };\n    } else {\n      events[content2][1] = heading;\n    }\n    events.push(["exit", heading, context]);\n    return events;\n  }\n  function tokenizeSetextUnderline(effects, ok, nok) {\n    const self2 = this;\n    let marker;\n    return start;\n    function start(code) {\n      let index2 = self2.events.length;\n      let paragraph;\n      while (index2--) {\n        if (self2.events[index2][1].type !== "lineEnding" && self2.events[index2][1].type !== "linePrefix" && self2.events[index2][1].type !== "content") {\n          paragraph = self2.events[index2][1].type === "paragraph";\n          break;\n        }\n      }\n      if (!self2.parser.lazy[self2.now().line] && (self2.interrupt || paragraph)) {\n        effects.enter("setextHeadingLine");\n        marker = code;\n        return before(code);\n      }\n      return nok(code);\n    }\n    function before(code) {\n      effects.enter("setextHeadingLineSequence");\n      return inside(code);\n    }\n    function inside(code) {\n      if (code === marker) {\n        effects.consume(code);\n        return inside;\n      }\n      effects.exit("setextHeadingLineSequence");\n      return markdownSpace(code) ? factorySpace(effects, after, "lineSuffix")(code) : after(code);\n    }\n    function after(code) {\n      if (code === null || markdownLineEnding(code)) {\n        effects.exit("setextHeadingLine");\n        return ok(code);\n      }\n      return nok(code);\n    }\n  }\n  const flow$1 = {\n    tokenize: initializeFlow\n  };\n  function initializeFlow(effects) {\n    const self2 = this;\n    const initial = effects.attempt(\n      // Try to parse a blank line.\n      blankLine,\n      atBlankEnding,\n      // Try to parse initial flow (essentially, only code).\n      effects.attempt(this.parser.constructs.flowInitial, afterConstruct, factorySpace(effects, effects.attempt(this.parser.constructs.flow, afterConstruct, effects.attempt(content, afterConstruct)), "linePrefix"))\n    );\n    return initial;\n    function atBlankEnding(code) {\n      if (code === null) {\n        effects.consume(code);\n        return;\n      }\n      effects.enter("lineEndingBlank");\n      effects.consume(code);\n      effects.exit("lineEndingBlank");\n      self2.currentConstruct = void 0;\n      return initial;\n    }\n    function afterConstruct(code) {\n      if (code === null) {\n        effects.consume(code);\n        return;\n      }\n      effects.enter("lineEnding");\n      effects.consume(code);\n      effects.exit("lineEnding");\n      self2.currentConstruct = void 0;\n      return initial;\n    }\n  }\n  const resolver = {\n    resolveAll: createResolver()\n  };\n  const string$1 = initializeFactory("string");\n  const text$1 = initializeFactory("text");\n  function initializeFactory(field) {\n    return {\n      resolveAll: createResolver(field === "text" ? resolveAllLineSuffixes : void 0),\n      tokenize: initializeText\n    };\n    function initializeText(effects) {\n      const self2 = this;\n      const constructs2 = this.parser.constructs[field];\n      const text2 = effects.attempt(constructs2, start, notText);\n      return start;\n      function start(code) {\n        return atBreak(code) ? text2(code) : notText(code);\n      }\n      function notText(code) {\n        if (code === null) {\n          effects.consume(code);\n          return;\n        }\n        effects.enter("data");\n        effects.consume(code);\n        return data;\n      }\n      function data(code) {\n        if (atBreak(code)) {\n          effects.exit("data");\n          return text2(code);\n        }\n        effects.consume(code);\n        return data;\n      }\n      function atBreak(code) {\n        if (code === null) {\n          return true;\n        }\n        const list2 = constructs2[code];\n        let index2 = -1;\n        if (list2) {\n          while (++index2 < list2.length) {\n            const item = list2[index2];\n            if (!item.previous || item.previous.call(self2, self2.previous)) {\n              return true;\n            }\n          }\n        }\n        return false;\n      }\n    }\n  }\n  function createResolver(extraResolver) {\n    return resolveAllText;\n    function resolveAllText(events, context) {\n      let index2 = -1;\n      let enter;\n      while (++index2 <= events.length) {\n        if (enter === void 0) {\n          if (events[index2] && events[index2][1].type === "data") {\n            enter = index2;\n            index2++;\n          }\n        } else if (!events[index2] || events[index2][1].type !== "data") {\n          if (index2 !== enter + 2) {\n            events[enter][1].end = events[index2 - 1][1].end;\n            events.splice(enter + 2, index2 - enter - 2);\n            index2 = enter + 2;\n          }\n          enter = void 0;\n        }\n      }\n      return extraResolver ? extraResolver(events, context) : events;\n    }\n  }\n  function resolveAllLineSuffixes(events, context) {\n    let eventIndex = 0;\n    while (++eventIndex <= events.length) {\n      if ((eventIndex === events.length || events[eventIndex][1].type === "lineEnding") && events[eventIndex - 1][1].type === "data") {\n        const data = events[eventIndex - 1][1];\n        const chunks = context.sliceStream(data);\n        let index2 = chunks.length;\n        let bufferIndex = -1;\n        let size = 0;\n        let tabs;\n        while (index2--) {\n          const chunk = chunks[index2];\n          if (typeof chunk === "string") {\n            bufferIndex = chunk.length;\n            while (chunk.charCodeAt(bufferIndex - 1) === 32) {\n              size++;\n              bufferIndex--;\n            }\n            if (bufferIndex) break;\n            bufferIndex = -1;\n          } else if (chunk === -2) {\n            tabs = true;\n            size++;\n          } else if (chunk === -1) ;\n          else {\n            index2++;\n            break;\n          }\n        }\n        if (context._contentTypeTextTrailing && eventIndex === events.length) {\n          size = 0;\n        }\n        if (size) {\n          const token = {\n            type: eventIndex === events.length || tabs || size < 2 ? "lineSuffix" : "hardBreakTrailing",\n            start: {\n              _bufferIndex: index2 ? bufferIndex : data.start._bufferIndex + bufferIndex,\n              _index: data.start._index + index2,\n              line: data.end.line,\n              column: data.end.column - size,\n              offset: data.end.offset - size\n            },\n            end: {\n              ...data.end\n            }\n          };\n          data.end = {\n            ...token.start\n          };\n          if (data.start.offset === data.end.offset) {\n            Object.assign(data, token);\n          } else {\n            events.splice(eventIndex, 0, ["enter", token, context], ["exit", token, context]);\n            eventIndex += 2;\n          }\n        }\n        eventIndex++;\n      }\n    }\n    return events;\n  }\n  const document = {\n    [42]: list,\n    [43]: list,\n    [45]: list,\n    [48]: list,\n    [49]: list,\n    [50]: list,\n    [51]: list,\n    [52]: list,\n    [53]: list,\n    [54]: list,\n    [55]: list,\n    [56]: list,\n    [57]: list,\n    [62]: blockQuote\n  };\n  const contentInitial = {\n    [91]: definition\n  };\n  const flowInitial = {\n    [-2]: codeIndented,\n    [-1]: codeIndented,\n    [32]: codeIndented\n  };\n  const flow = {\n    [35]: headingAtx,\n    [42]: thematicBreak,\n    [45]: [setextUnderline, thematicBreak],\n    [60]: htmlFlow,\n    [61]: setextUnderline,\n    [95]: thematicBreak,\n    [96]: codeFenced,\n    [126]: codeFenced\n  };\n  const string = {\n    [38]: characterReference,\n    [92]: characterEscape\n  };\n  const text = {\n    [-5]: lineEnding,\n    [-4]: lineEnding,\n    [-3]: lineEnding,\n    [33]: labelStartImage,\n    [38]: characterReference,\n    [42]: attention,\n    [60]: [autolink, htmlText],\n    [91]: labelStartLink,\n    [92]: [hardBreakEscape, characterEscape],\n    [93]: labelEnd,\n    [95]: attention,\n    [96]: codeText\n  };\n  const insideSpan = {\n    null: [attention, resolver]\n  };\n  const attentionMarkers = {\n    null: [42, 95]\n  };\n  const disable = {\n    null: []\n  };\n  var defaultConstructs = /* @__PURE__ */ Object.freeze({\n    __proto__: null,\n    attentionMarkers,\n    contentInitial,\n    disable,\n    document,\n    flow,\n    flowInitial,\n    insideSpan,\n    string,\n    text\n  });\n  function createTokenizer(parser, initialize, from) {\n    let point2 = {\n      _bufferIndex: -1,\n      _index: 0,\n      line: from && from.line || 1,\n      column: from && from.column || 1,\n      offset: from && from.offset || 0\n    };\n    const columnStart = {};\n    const resolveAllConstructs = [];\n    let chunks = [];\n    let stack = [];\n    const effects = {\n      attempt: constructFactory(onsuccessfulconstruct),\n      check: constructFactory(onsuccessfulcheck),\n      consume,\n      enter,\n      exit: exit2,\n      interrupt: constructFactory(onsuccessfulcheck, {\n        interrupt: true\n      })\n    };\n    const context = {\n      code: null,\n      containerState: {},\n      defineSkip,\n      events: [],\n      now,\n      parser,\n      previous: null,\n      sliceSerialize,\n      sliceStream,\n      write\n    };\n    let state = initialize.tokenize.call(context, effects);\n    if (initialize.resolveAll) {\n      resolveAllConstructs.push(initialize);\n    }\n    return context;\n    function write(slice) {\n      chunks = push(chunks, slice);\n      main();\n      if (chunks[chunks.length - 1] !== null) {\n        return [];\n      }\n      addResult(initialize, 0);\n      context.events = resolveAll(resolveAllConstructs, context.events, context);\n      return context.events;\n    }\n    function sliceSerialize(token, expandTabs) {\n      return serializeChunks(sliceStream(token), expandTabs);\n    }\n    function sliceStream(token) {\n      return sliceChunks(chunks, token);\n    }\n    function now() {\n      const {\n        _bufferIndex,\n        _index,\n        line,\n        column,\n        offset\n      } = point2;\n      return {\n        _bufferIndex,\n        _index,\n        line,\n        column,\n        offset\n      };\n    }\n    function defineSkip(value) {\n      columnStart[value.line] = value.column;\n      accountForPotentialSkip();\n    }\n    function main() {\n      let chunkIndex;\n      while (point2._index < chunks.length) {\n        const chunk = chunks[point2._index];\n        if (typeof chunk === "string") {\n          chunkIndex = point2._index;\n          if (point2._bufferIndex < 0) {\n            point2._bufferIndex = 0;\n          }\n          while (point2._index === chunkIndex && point2._bufferIndex < chunk.length) {\n            go(chunk.charCodeAt(point2._bufferIndex));\n          }\n        } else {\n          go(chunk);\n        }\n      }\n    }\n    function go(code) {\n      state = state(code);\n    }\n    function consume(code) {\n      if (markdownLineEnding(code)) {\n        point2.line++;\n        point2.column = 1;\n        point2.offset += code === -3 ? 2 : 1;\n        accountForPotentialSkip();\n      } else if (code !== -1) {\n        point2.column++;\n        point2.offset++;\n      }\n      if (point2._bufferIndex < 0) {\n        point2._index++;\n      } else {\n        point2._bufferIndex++;\n        if (point2._bufferIndex === // Points w/ non-negative `_bufferIndex` reference\n        // strings.\n        /** @type {string} */\n        chunks[point2._index].length) {\n          point2._bufferIndex = -1;\n          point2._index++;\n        }\n      }\n      context.previous = code;\n    }\n    function enter(type2, fields) {\n      const token = fields || {};\n      token.type = type2;\n      token.start = now();\n      context.events.push(["enter", token, context]);\n      stack.push(token);\n      return token;\n    }\n    function exit2(type2) {\n      const token = stack.pop();\n      token.end = now();\n      context.events.push(["exit", token, context]);\n      return token;\n    }\n    function onsuccessfulconstruct(construct, info) {\n      addResult(construct, info.from);\n    }\n    function onsuccessfulcheck(_, info) {\n      info.restore();\n    }\n    function constructFactory(onreturn, fields) {\n      return hook;\n      function hook(constructs2, returnState, bogusState) {\n        let listOfConstructs;\n        let constructIndex;\n        let currentConstruct;\n        let info;\n        return Array.isArray(constructs2) ? (\n          /* c8 ignore next 1 */\n          handleListOfConstructs(constructs2)\n        ) : "tokenize" in constructs2 ? (\n          // Looks like a construct.\n          handleListOfConstructs([\n            /** @type {Construct} */\n            constructs2\n          ])\n        ) : handleMapOfConstructs(constructs2);\n        function handleMapOfConstructs(map2) {\n          return start;\n          function start(code) {\n            const left = code !== null && map2[code];\n            const all2 = code !== null && map2.null;\n            const list2 = [\n              // To do: add more extension tests.\n              /* c8 ignore next 2 */\n              ...Array.isArray(left) ? left : left ? [left] : [],\n              ...Array.isArray(all2) ? all2 : all2 ? [all2] : []\n            ];\n            return handleListOfConstructs(list2)(code);\n          }\n        }\n        function handleListOfConstructs(list2) {\n          listOfConstructs = list2;\n          constructIndex = 0;\n          if (list2.length === 0) {\n            return bogusState;\n          }\n          return handleConstruct(list2[constructIndex]);\n        }\n        function handleConstruct(construct) {\n          return start;\n          function start(code) {\n            info = store();\n            currentConstruct = construct;\n            if (!construct.partial) {\n              context.currentConstruct = construct;\n            }\n            if (construct.name && context.parser.constructs.disable.null.includes(construct.name)) {\n              return nok();\n            }\n            return construct.tokenize.call(\n              // If we do have fields, create an object w/ `context` as its\n              // prototype.\n              // This allows a â€œlive bindingâ€, which is needed for `interrupt`.\n              fields ? Object.assign(Object.create(context), fields) : context,\n              effects,\n              ok,\n              nok\n            )(code);\n          }\n        }\n        function ok(code) {\n          onreturn(currentConstruct, info);\n          return returnState;\n        }\n        function nok(code) {\n          info.restore();\n          if (++constructIndex < listOfConstructs.length) {\n            return handleConstruct(listOfConstructs[constructIndex]);\n          }\n          return bogusState;\n        }\n      }\n    }\n    function addResult(construct, from2) {\n      if (construct.resolveAll && !resolveAllConstructs.includes(construct)) {\n        resolveAllConstructs.push(construct);\n      }\n      if (construct.resolve) {\n        splice(context.events, from2, context.events.length - from2, construct.resolve(context.events.slice(from2), context));\n      }\n      if (construct.resolveTo) {\n        context.events = construct.resolveTo(context.events, context);\n      }\n    }\n    function store() {\n      const startPoint = now();\n      const startPrevious = context.previous;\n      const startCurrentConstruct = context.currentConstruct;\n      const startEventsIndex = context.events.length;\n      const startStack = Array.from(stack);\n      return {\n        from: startEventsIndex,\n        restore\n      };\n      function restore() {\n        point2 = startPoint;\n        context.previous = startPrevious;\n        context.currentConstruct = startCurrentConstruct;\n        context.events.length = startEventsIndex;\n        stack = startStack;\n        accountForPotentialSkip();\n      }\n    }\n    function accountForPotentialSkip() {\n      if (point2.line in columnStart && point2.column < 2) {\n        point2.column = columnStart[point2.line];\n        point2.offset += columnStart[point2.line] - 1;\n      }\n    }\n  }\n  function sliceChunks(chunks, token) {\n    const startIndex = token.start._index;\n    const startBufferIndex = token.start._bufferIndex;\n    const endIndex = token.end._index;\n    const endBufferIndex = token.end._bufferIndex;\n    let view;\n    if (startIndex === endIndex) {\n      view = [chunks[startIndex].slice(startBufferIndex, endBufferIndex)];\n    } else {\n      view = chunks.slice(startIndex, endIndex);\n      if (startBufferIndex > -1) {\n        const head = view[0];\n        if (typeof head === "string") {\n          view[0] = head.slice(startBufferIndex);\n        } else {\n          view.shift();\n        }\n      }\n      if (endBufferIndex > 0) {\n        view.push(chunks[endIndex].slice(0, endBufferIndex));\n      }\n    }\n    return view;\n  }\n  function serializeChunks(chunks, expandTabs) {\n    let index2 = -1;\n    const result = [];\n    let atTab;\n    while (++index2 < chunks.length) {\n      const chunk = chunks[index2];\n      let value;\n      if (typeof chunk === "string") {\n        value = chunk;\n      } else switch (chunk) {\n        case -5: {\n          value = "\\r";\n          break;\n        }\n        case -4: {\n          value = "\\n";\n          break;\n        }\n        case -3: {\n          value = "\\r\\n";\n          break;\n        }\n        case -2: {\n          value = expandTabs ? " " : "	";\n          break;\n        }\n        case -1: {\n          if (!expandTabs && atTab) continue;\n          value = " ";\n          break;\n        }\n        default: {\n          value = String.fromCharCode(chunk);\n        }\n      }\n      atTab = chunk === -2;\n      result.push(value);\n    }\n    return result.join("");\n  }\n  function parse$1(options2) {\n    const settings = options2 || {};\n    const constructs2 = (\n      /** @type {FullNormalizedExtension} */\n      combineExtensions([defaultConstructs, ...settings.extensions || []])\n    );\n    const parser = {\n      constructs: constructs2,\n      content: create(content$1),\n      defined: [],\n      document: create(document$1),\n      flow: create(flow$1),\n      lazy: {},\n      string: create(string$1),\n      text: create(text$1)\n    };\n    return parser;\n    function create(initial) {\n      return creator;\n      function creator(from) {\n        return createTokenizer(parser, initial, from);\n      }\n    }\n  }\n  function postprocess(events) {\n    while (!subtokenize(events)) {\n    }\n    return events;\n  }\n  const search = /[\\0\\t\\n\\r]/g;\n  function preprocess() {\n    let column = 1;\n    let buffer = "";\n    let start = true;\n    let atCarriageReturn;\n    return preprocessor;\n    function preprocessor(value, encoding, end) {\n      const chunks = [];\n      let match;\n      let next;\n      let startPosition;\n      let endPosition;\n      let code;\n      value = buffer + (typeof value === "string" ? value.toString() : new TextDecoder(encoding || void 0).decode(value));\n      startPosition = 0;\n      buffer = "";\n      if (start) {\n        if (value.charCodeAt(0) === 65279) {\n          startPosition++;\n        }\n        start = void 0;\n      }\n      while (startPosition < value.length) {\n        search.lastIndex = startPosition;\n        match = search.exec(value);\n        endPosition = match && match.index !== void 0 ? match.index : value.length;\n        code = value.charCodeAt(endPosition);\n        if (!match) {\n          buffer = value.slice(startPosition);\n          break;\n        }\n        if (code === 10 && startPosition === endPosition && atCarriageReturn) {\n          chunks.push(-3);\n          atCarriageReturn = void 0;\n        } else {\n          if (atCarriageReturn) {\n            chunks.push(-5);\n            atCarriageReturn = void 0;\n          }\n          if (startPosition < endPosition) {\n            chunks.push(value.slice(startPosition, endPosition));\n            column += endPosition - startPosition;\n          }\n          switch (code) {\n            case 0: {\n              chunks.push(65533);\n              column++;\n              break;\n            }\n            case 9: {\n              next = Math.ceil(column / 4) * 4;\n              chunks.push(-2);\n              while (column++ < next) chunks.push(-1);\n              break;\n            }\n            case 10: {\n              chunks.push(-4);\n              column = 1;\n              break;\n            }\n            default: {\n              atCarriageReturn = true;\n              column = 1;\n            }\n          }\n        }\n        startPosition = endPosition + 1;\n      }\n      if (end) {\n        if (atCarriageReturn) chunks.push(-5);\n        if (buffer) chunks.push(buffer);\n        chunks.push(null);\n      }\n      return chunks;\n    }\n  }\n  const characterEscapeOrReference = /\\\\([!-/:-@[-`{-~])|&(#(?:\\d{1,7}|x[\\da-f]{1,6})|[\\da-z]{1,31});/gi;\n  function decodeString(value) {\n    return value.replace(characterEscapeOrReference, decode);\n  }\n  function decode($0, $1, $2) {\n    if ($1) {\n      return $1;\n    }\n    const head = $2.charCodeAt(0);\n    if (head === 35) {\n      const head2 = $2.charCodeAt(1);\n      const hex = head2 === 120 || head2 === 88;\n      return decodeNumericCharacterReference($2.slice(hex ? 2 : 1), hex ? 16 : 10);\n    }\n    return decodeNamedCharacterReference($2) || $0;\n  }\n  function stringifyPosition(value) {\n    if (!value || typeof value !== "object") {\n      return "";\n    }\n    if ("position" in value || "type" in value) {\n      return position(value.position);\n    }\n    if ("start" in value || "end" in value) {\n      return position(value);\n    }\n    if ("line" in value || "column" in value) {\n      return point$1(value);\n    }\n    return "";\n  }\n  function point$1(point2) {\n    return index(point2 && point2.line) + ":" + index(point2 && point2.column);\n  }\n  function position(pos) {\n    return point$1(pos && pos.start) + "-" + point$1(pos && pos.end);\n  }\n  function index(value) {\n    return value && typeof value === "number" ? value : 1;\n  }\n  const own = {}.hasOwnProperty;\n  function fromMarkdown(value, encoding, options2) {\n    if (typeof encoding !== "string") {\n      options2 = encoding;\n      encoding = void 0;\n    }\n    return compiler(options2)(postprocess(parse$1(options2).document().write(preprocess()(value, encoding, true))));\n  }\n  function compiler(options2) {\n    const config = {\n      transforms: [],\n      canContainEols: ["emphasis", "fragment", "heading", "paragraph", "strong"],\n      enter: {\n        autolink: opener(link),\n        autolinkProtocol: onenterdata,\n        autolinkEmail: onenterdata,\n        atxHeading: opener(heading),\n        blockQuote: opener(blockQuote2),\n        characterEscape: onenterdata,\n        characterReference: onenterdata,\n        codeFenced: opener(codeFlow),\n        codeFencedFenceInfo: buffer,\n        codeFencedFenceMeta: buffer,\n        codeIndented: opener(codeFlow, buffer),\n        codeText: opener(codeText2, buffer),\n        codeTextData: onenterdata,\n        data: onenterdata,\n        codeFlowValue: onenterdata,\n        definition: opener(definition2),\n        definitionDestinationString: buffer,\n        definitionLabelString: buffer,\n        definitionTitleString: buffer,\n        emphasis: opener(emphasis),\n        hardBreakEscape: opener(hardBreak),\n        hardBreakTrailing: opener(hardBreak),\n        htmlFlow: opener(html, buffer),\n        htmlFlowData: onenterdata,\n        htmlText: opener(html, buffer),\n        htmlTextData: onenterdata,\n        image: opener(image),\n        label: buffer,\n        link: opener(link),\n        listItem: opener(listItem),\n        listItemValue: onenterlistitemvalue,\n        listOrdered: opener(list2, onenterlistordered),\n        listUnordered: opener(list2),\n        paragraph: opener(paragraph),\n        reference: onenterreference,\n        referenceString: buffer,\n        resourceDestinationString: buffer,\n        resourceTitleString: buffer,\n        setextHeading: opener(heading),\n        strong: opener(strong),\n        thematicBreak: opener(thematicBreak2)\n      },\n      exit: {\n        atxHeading: closer(),\n        atxHeadingSequence: onexitatxheadingsequence,\n        autolink: closer(),\n        autolinkEmail: onexitautolinkemail,\n        autolinkProtocol: onexitautolinkprotocol,\n        blockQuote: closer(),\n        characterEscapeValue: onexitdata,\n        characterReferenceMarkerHexadecimal: onexitcharacterreferencemarker,\n        characterReferenceMarkerNumeric: onexitcharacterreferencemarker,\n        characterReferenceValue: onexitcharacterreferencevalue,\n        characterReference: onexitcharacterreference,\n        codeFenced: closer(onexitcodefenced),\n        codeFencedFence: onexitcodefencedfence,\n        codeFencedFenceInfo: onexitcodefencedfenceinfo,\n        codeFencedFenceMeta: onexitcodefencedfencemeta,\n        codeFlowValue: onexitdata,\n        codeIndented: closer(onexitcodeindented),\n        codeText: closer(onexitcodetext),\n        codeTextData: onexitdata,\n        data: onexitdata,\n        definition: closer(),\n        definitionDestinationString: onexitdefinitiondestinationstring,\n        definitionLabelString: onexitdefinitionlabelstring,\n        definitionTitleString: onexitdefinitiontitlestring,\n        emphasis: closer(),\n        hardBreakEscape: closer(onexithardbreak),\n        hardBreakTrailing: closer(onexithardbreak),\n        htmlFlow: closer(onexithtmlflow),\n        htmlFlowData: onexitdata,\n        htmlText: closer(onexithtmltext),\n        htmlTextData: onexitdata,\n        image: closer(onexitimage),\n        label: onexitlabel,\n        labelText: onexitlabeltext,\n        lineEnding: onexitlineending,\n        link: closer(onexitlink),\n        listItem: closer(),\n        listOrdered: closer(),\n        listUnordered: closer(),\n        paragraph: closer(),\n        referenceString: onexitreferencestring,\n        resourceDestinationString: onexitresourcedestinationstring,\n        resourceTitleString: onexitresourcetitlestring,\n        resource: onexitresource,\n        setextHeading: closer(onexitsetextheading),\n        setextHeadingLineSequence: onexitsetextheadinglinesequence,\n        setextHeadingText: onexitsetextheadingtext,\n        strong: closer(),\n        thematicBreak: closer()\n      }\n    };\n    configure(config, (options2 || {}).mdastExtensions || []);\n    const data = {};\n    return compile;\n    function compile(events) {\n      let tree = {\n        type: "root",\n        children: []\n      };\n      const context = {\n        stack: [tree],\n        tokenStack: [],\n        config,\n        enter,\n        exit: exit2,\n        buffer,\n        resume,\n        data\n      };\n      const listStack = [];\n      let index2 = -1;\n      while (++index2 < events.length) {\n        if (events[index2][1].type === "listOrdered" || events[index2][1].type === "listUnordered") {\n          if (events[index2][0] === "enter") {\n            listStack.push(index2);\n          } else {\n            const tail = listStack.pop();\n            index2 = prepareList(events, tail, index2);\n          }\n        }\n      }\n      index2 = -1;\n      while (++index2 < events.length) {\n        const handler = config[events[index2][0]];\n        if (own.call(handler, events[index2][1].type)) {\n          handler[events[index2][1].type].call(Object.assign({\n            sliceSerialize: events[index2][2].sliceSerialize\n          }, context), events[index2][1]);\n        }\n      }\n      if (context.tokenStack.length > 0) {\n        const tail = context.tokenStack[context.tokenStack.length - 1];\n        const handler = tail[1] || defaultOnError;\n        handler.call(context, void 0, tail[0]);\n      }\n      tree.position = {\n        start: point(events.length > 0 ? events[0][1].start : {\n          line: 1,\n          column: 1,\n          offset: 0\n        }),\n        end: point(events.length > 0 ? events[events.length - 2][1].end : {\n          line: 1,\n          column: 1,\n          offset: 0\n        })\n      };\n      index2 = -1;\n      while (++index2 < config.transforms.length) {\n        tree = config.transforms[index2](tree) || tree;\n      }\n      return tree;\n    }\n    function prepareList(events, start, length) {\n      let index2 = start - 1;\n      let containerBalance = -1;\n      let listSpread = false;\n      let listItem2;\n      let lineIndex;\n      let firstBlankLineIndex;\n      let atMarker;\n      while (++index2 <= length) {\n        const event = events[index2];\n        switch (event[1].type) {\n          case "listUnordered":\n          case "listOrdered":\n          case "blockQuote": {\n            if (event[0] === "enter") {\n              containerBalance++;\n            } else {\n              containerBalance--;\n            }\n            atMarker = void 0;\n            break;\n          }\n          case "lineEndingBlank": {\n            if (event[0] === "enter") {\n              if (listItem2 && !atMarker && !containerBalance && !firstBlankLineIndex) {\n                firstBlankLineIndex = index2;\n              }\n              atMarker = void 0;\n            }\n            break;\n          }\n          case "linePrefix":\n          case "listItemValue":\n          case "listItemMarker":\n          case "listItemPrefix":\n          case "listItemPrefixWhitespace": {\n            break;\n          }\n          default: {\n            atMarker = void 0;\n          }\n        }\n        if (!containerBalance && event[0] === "enter" && event[1].type === "listItemPrefix" || containerBalance === -1 && event[0] === "exit" && (event[1].type === "listUnordered" || event[1].type === "listOrdered")) {\n          if (listItem2) {\n            let tailIndex = index2;\n            lineIndex = void 0;\n            while (tailIndex--) {\n              const tailEvent = events[tailIndex];\n              if (tailEvent[1].type === "lineEnding" || tailEvent[1].type === "lineEndingBlank") {\n                if (tailEvent[0] === "exit") continue;\n                if (lineIndex) {\n                  events[lineIndex][1].type = "lineEndingBlank";\n                  listSpread = true;\n                }\n                tailEvent[1].type = "lineEnding";\n                lineIndex = tailIndex;\n              } else if (tailEvent[1].type === "linePrefix" || tailEvent[1].type === "blockQuotePrefix" || tailEvent[1].type === "blockQuotePrefixWhitespace" || tailEvent[1].type === "blockQuoteMarker" || tailEvent[1].type === "listItemIndent") ;\n              else {\n                break;\n              }\n            }\n            if (firstBlankLineIndex && (!lineIndex || firstBlankLineIndex < lineIndex)) {\n              listItem2._spread = true;\n            }\n            listItem2.end = Object.assign({}, lineIndex ? events[lineIndex][1].start : event[1].end);\n            events.splice(lineIndex || index2, 0, ["exit", listItem2, event[2]]);\n            index2++;\n            length++;\n          }\n          if (event[1].type === "listItemPrefix") {\n            const item = {\n              type: "listItem",\n              _spread: false,\n              start: Object.assign({}, event[1].start),\n              // @ts-expect-error: weâ€™ll add `end` in a second.\n              end: void 0\n            };\n            listItem2 = item;\n            events.splice(index2, 0, ["enter", item, event[2]]);\n            index2++;\n            length++;\n            firstBlankLineIndex = void 0;\n            atMarker = true;\n          }\n        }\n      }\n      events[start][1]._spread = listSpread;\n      return length;\n    }\n    function opener(create, and) {\n      return open;\n      function open(token) {\n        enter.call(this, create(token), token);\n        if (and) and.call(this, token);\n      }\n    }\n    function buffer() {\n      this.stack.push({\n        type: "fragment",\n        children: []\n      });\n    }\n    function enter(node2, token, errorHandler) {\n      const parent = this.stack[this.stack.length - 1];\n      const siblings = parent.children;\n      siblings.push(node2);\n      this.stack.push(node2);\n      this.tokenStack.push([token, errorHandler || void 0]);\n      node2.position = {\n        start: point(token.start),\n        // @ts-expect-error: `end` will be patched later.\n        end: void 0\n      };\n    }\n    function closer(and) {\n      return close;\n      function close(token) {\n        if (and) and.call(this, token);\n        exit2.call(this, token);\n      }\n    }\n    function exit2(token, onExitError) {\n      const node2 = this.stack.pop();\n      const open = this.tokenStack.pop();\n      if (!open) {\n        throw new Error("Cannot close `" + token.type + "` (" + stringifyPosition({\n          start: token.start,\n          end: token.end\n        }) + "): itâ€™s not open");\n      } else if (open[0].type !== token.type) {\n        if (onExitError) {\n          onExitError.call(this, token, open[0]);\n        } else {\n          const handler = open[1] || defaultOnError;\n          handler.call(this, token, open[0]);\n        }\n      }\n      node2.position.end = point(token.end);\n    }\n    function resume() {\n      return toString(this.stack.pop());\n    }\n    function onenterlistordered() {\n      this.data.expectingFirstListItemValue = true;\n    }\n    function onenterlistitemvalue(token) {\n      if (this.data.expectingFirstListItemValue) {\n        const ancestor = this.stack[this.stack.length - 2];\n        ancestor.start = Number.parseInt(this.sliceSerialize(token), 10);\n        this.data.expectingFirstListItemValue = void 0;\n      }\n    }\n    function onexitcodefencedfenceinfo() {\n      const data2 = this.resume();\n      const node2 = this.stack[this.stack.length - 1];\n      node2.lang = data2;\n    }\n    function onexitcodefencedfencemeta() {\n      const data2 = this.resume();\n      const node2 = this.stack[this.stack.length - 1];\n      node2.meta = data2;\n    }\n    function onexitcodefencedfence() {\n      if (this.data.flowCodeInside) return;\n      this.buffer();\n      this.data.flowCodeInside = true;\n    }\n    function onexitcodefenced() {\n      const data2 = this.resume();\n      const node2 = this.stack[this.stack.length - 1];\n      node2.value = data2.replace(/^(\\r?\\n|\\r)|(\\r?\\n|\\r)$/g, "");\n      this.data.flowCodeInside = void 0;\n    }\n    function onexitcodeindented() {\n      const data2 = this.resume();\n      const node2 = this.stack[this.stack.length - 1];\n      node2.value = data2.replace(/(\\r?\\n|\\r)$/g, "");\n    }\n    function onexitdefinitionlabelstring(token) {\n      const label = this.resume();\n      const node2 = this.stack[this.stack.length - 1];\n      node2.label = label;\n      node2.identifier = normalizeIdentifier(this.sliceSerialize(token)).toLowerCase();\n    }\n    function onexitdefinitiontitlestring() {\n      const data2 = this.resume();\n      const node2 = this.stack[this.stack.length - 1];\n      node2.title = data2;\n    }\n    function onexitdefinitiondestinationstring() {\n      const data2 = this.resume();\n      const node2 = this.stack[this.stack.length - 1];\n      node2.url = data2;\n    }\n    function onexitatxheadingsequence(token) {\n      const node2 = this.stack[this.stack.length - 1];\n      if (!node2.depth) {\n        const depth = this.sliceSerialize(token).length;\n        node2.depth = depth;\n      }\n    }\n    function onexitsetextheadingtext() {\n      this.data.setextHeadingSlurpLineEnding = true;\n    }\n    function onexitsetextheadinglinesequence(token) {\n      const node2 = this.stack[this.stack.length - 1];\n      node2.depth = this.sliceSerialize(token).codePointAt(0) === 61 ? 1 : 2;\n    }\n    function onexitsetextheading() {\n      this.data.setextHeadingSlurpLineEnding = void 0;\n    }\n    function onenterdata(token) {\n      const node2 = this.stack[this.stack.length - 1];\n      const siblings = node2.children;\n      let tail = siblings[siblings.length - 1];\n      if (!tail || tail.type !== "text") {\n        tail = text2();\n        tail.position = {\n          start: point(token.start),\n          // @ts-expect-error: weâ€™ll add `end` later.\n          end: void 0\n        };\n        siblings.push(tail);\n      }\n      this.stack.push(tail);\n    }\n    function onexitdata(token) {\n      const tail = this.stack.pop();\n      tail.value += this.sliceSerialize(token);\n      tail.position.end = point(token.end);\n    }\n    function onexitlineending(token) {\n      const context = this.stack[this.stack.length - 1];\n      if (this.data.atHardBreak) {\n        const tail = context.children[context.children.length - 1];\n        tail.position.end = point(token.end);\n        this.data.atHardBreak = void 0;\n        return;\n      }\n      if (!this.data.setextHeadingSlurpLineEnding && config.canContainEols.includes(context.type)) {\n        onenterdata.call(this, token);\n        onexitdata.call(this, token);\n      }\n    }\n    function onexithardbreak() {\n      this.data.atHardBreak = true;\n    }\n    function onexithtmlflow() {\n      const data2 = this.resume();\n      const node2 = this.stack[this.stack.length - 1];\n      node2.value = data2;\n    }\n    function onexithtmltext() {\n      const data2 = this.resume();\n      const node2 = this.stack[this.stack.length - 1];\n      node2.value = data2;\n    }\n    function onexitcodetext() {\n      const data2 = this.resume();\n      const node2 = this.stack[this.stack.length - 1];\n      node2.value = data2;\n    }\n    function onexitlink() {\n      const node2 = this.stack[this.stack.length - 1];\n      if (this.data.inReference) {\n        const referenceType = this.data.referenceType || "shortcut";\n        node2.type += "Reference";\n        node2.referenceType = referenceType;\n        delete node2.url;\n        delete node2.title;\n      } else {\n        delete node2.identifier;\n        delete node2.label;\n      }\n      this.data.referenceType = void 0;\n    }\n    function onexitimage() {\n      const node2 = this.stack[this.stack.length - 1];\n      if (this.data.inReference) {\n        const referenceType = this.data.referenceType || "shortcut";\n        node2.type += "Reference";\n        node2.referenceType = referenceType;\n        delete node2.url;\n        delete node2.title;\n      } else {\n        delete node2.identifier;\n        delete node2.label;\n      }\n      this.data.referenceType = void 0;\n    }\n    function onexitlabeltext(token) {\n      const string2 = this.sliceSerialize(token);\n      const ancestor = this.stack[this.stack.length - 2];\n      ancestor.label = decodeString(string2);\n      ancestor.identifier = normalizeIdentifier(string2).toLowerCase();\n    }\n    function onexitlabel() {\n      const fragment = this.stack[this.stack.length - 1];\n      const value = this.resume();\n      const node2 = this.stack[this.stack.length - 1];\n      this.data.inReference = true;\n      if (node2.type === "link") {\n        const children = fragment.children;\n        node2.children = children;\n      } else {\n        node2.alt = value;\n      }\n    }\n    function onexitresourcedestinationstring() {\n      const data2 = this.resume();\n      const node2 = this.stack[this.stack.length - 1];\n      node2.url = data2;\n    }\n    function onexitresourcetitlestring() {\n      const data2 = this.resume();\n      const node2 = this.stack[this.stack.length - 1];\n      node2.title = data2;\n    }\n    function onexitresource() {\n      this.data.inReference = void 0;\n    }\n    function onenterreference() {\n      this.data.referenceType = "collapsed";\n    }\n    function onexitreferencestring(token) {\n      const label = this.resume();\n      const node2 = this.stack[this.stack.length - 1];\n      node2.label = label;\n      node2.identifier = normalizeIdentifier(this.sliceSerialize(token)).toLowerCase();\n      this.data.referenceType = "full";\n    }\n    function onexitcharacterreferencemarker(token) {\n      this.data.characterReferenceType = token.type;\n    }\n    function onexitcharacterreferencevalue(token) {\n      const data2 = this.sliceSerialize(token);\n      const type2 = this.data.characterReferenceType;\n      let value;\n      if (type2) {\n        value = decodeNumericCharacterReference(data2, type2 === "characterReferenceMarkerNumeric" ? 10 : 16);\n        this.data.characterReferenceType = void 0;\n      } else {\n        const result = decodeNamedCharacterReference(data2);\n        value = result;\n      }\n      const tail = this.stack[this.stack.length - 1];\n      tail.value += value;\n    }\n    function onexitcharacterreference(token) {\n      const tail = this.stack.pop();\n      tail.position.end = point(token.end);\n    }\n    function onexitautolinkprotocol(token) {\n      onexitdata.call(this, token);\n      const node2 = this.stack[this.stack.length - 1];\n      node2.url = this.sliceSerialize(token);\n    }\n    function onexitautolinkemail(token) {\n      onexitdata.call(this, token);\n      const node2 = this.stack[this.stack.length - 1];\n      node2.url = "mailto:" + this.sliceSerialize(token);\n    }\n    function blockQuote2() {\n      return {\n        type: "blockquote",\n        children: []\n      };\n    }\n    function codeFlow() {\n      return {\n        type: "code",\n        lang: null,\n        meta: null,\n        value: ""\n      };\n    }\n    function codeText2() {\n      return {\n        type: "inlineCode",\n        value: ""\n      };\n    }\n    function definition2() {\n      return {\n        type: "definition",\n        identifier: "",\n        label: null,\n        title: null,\n        url: ""\n      };\n    }\n    function emphasis() {\n      return {\n        type: "emphasis",\n        children: []\n      };\n    }\n    function heading() {\n      return {\n        type: "heading",\n        // @ts-expect-error `depth` will be set later.\n        depth: 0,\n        children: []\n      };\n    }\n    function hardBreak() {\n      return {\n        type: "break"\n      };\n    }\n    function html() {\n      return {\n        type: "html",\n        value: ""\n      };\n    }\n    function image() {\n      return {\n        type: "image",\n        title: null,\n        url: "",\n        alt: null\n      };\n    }\n    function link() {\n      return {\n        type: "link",\n        title: null,\n        url: "",\n        children: []\n      };\n    }\n    function list2(token) {\n      return {\n        type: "list",\n        ordered: token.type === "listOrdered",\n        start: null,\n        spread: token._spread,\n        children: []\n      };\n    }\n    function listItem(token) {\n      return {\n        type: "listItem",\n        spread: token._spread,\n        checked: null,\n        children: []\n      };\n    }\n    function paragraph() {\n      return {\n        type: "paragraph",\n        children: []\n      };\n    }\n    function strong() {\n      return {\n        type: "strong",\n        children: []\n      };\n    }\n    function text2() {\n      return {\n        type: "text",\n        value: ""\n      };\n    }\n    function thematicBreak2() {\n      return {\n        type: "thematicBreak"\n      };\n    }\n  }\n  function point(d) {\n    return {\n      line: d.line,\n      column: d.column,\n      offset: d.offset\n    };\n  }\n  function configure(combined, extensions) {\n    let index2 = -1;\n    while (++index2 < extensions.length) {\n      const value = extensions[index2];\n      if (Array.isArray(value)) {\n        configure(combined, value);\n      } else {\n        extension(combined, value);\n      }\n    }\n  }\n  function extension(combined, extension2) {\n    let key;\n    for (key in extension2) {\n      if (own.call(extension2, key)) {\n        switch (key) {\n          case "canContainEols": {\n            const right = extension2[key];\n            if (right) {\n              combined[key].push(...right);\n            }\n            break;\n          }\n          case "transforms": {\n            const right = extension2[key];\n            if (right) {\n              combined[key].push(...right);\n            }\n            break;\n          }\n          case "enter":\n          case "exit": {\n            const right = extension2[key];\n            if (right) {\n              Object.assign(combined[key], right);\n            }\n            break;\n          }\n        }\n      }\n    }\n  }\n  function defaultOnError(left, right) {\n    if (left) {\n      throw new Error("Cannot close `" + left.type + "` (" + stringifyPosition({\n        start: left.start,\n        end: left.end\n      }) + "): a different token (`" + right.type + "`, " + stringifyPosition({\n        start: right.start,\n        end: right.end\n      }) + ") is open");\n    } else {\n      throw new Error("Cannot close document, a token (`" + right.type + "`, " + stringifyPosition({\n        start: right.start,\n        end: right.end\n      }) + ") is still open");\n    }\n  }\n  function isBytes(a) {\n    return a instanceof Uint8Array || ArrayBuffer.isView(a) && a.constructor.name === "Uint8Array";\n  }\n  function abytes(value, length, title = "") {\n    const bytes = isBytes(value);\n    const len = value?.length;\n    const needsLen = length !== void 0;\n    if (!bytes || needsLen) {\n      const prefix = title && `"${title}" `;\n      const ofLen = "";\n      const got = bytes ? `length=${len}` : `type=${typeof value}`;\n      throw new Error(prefix + "expected Uint8Array" + ofLen + ", got " + got);\n    }\n    return value;\n  }\n  function aexists(instance, checkFinished = true) {\n    if (instance.destroyed)\n      throw new Error("Hash instance has been destroyed");\n    if (checkFinished && instance.finished)\n      throw new Error("Hash#digest() has already been called");\n  }\n  function aoutput(out, instance) {\n    abytes(out, void 0, "digestInto() output");\n    const min = instance.outputLen;\n    if (out.length < min) {\n      throw new Error(\'"digestInto() output" expected to be of length >=\' + min);\n    }\n  }\n  function clean(...arrays) {\n    for (let i = 0; i < arrays.length; i++) {\n      arrays[i].fill(0);\n    }\n  }\n  function createView(arr) {\n    return new DataView(arr.buffer, arr.byteOffset, arr.byteLength);\n  }\n  function rotr(word, shift) {\n    return word << 32 - shift | word >>> shift;\n  }\n  function createHasher(hashCons, info = {}) {\n    const hashC = (msg, opts) => hashCons(opts).update(msg).digest();\n    const tmp = hashCons(void 0);\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (opts) => hashCons(opts);\n    Object.assign(hashC, info);\n    return Object.freeze(hashC);\n  }\n  const oidNist = (suffix) => ({\n    oid: Uint8Array.from([6, 9, 96, 134, 72, 1, 101, 3, 4, 2, suffix])\n  });\n  function Chi(a, b, c) {\n    return a & b ^ ~a & c;\n  }\n  function Maj(a, b, c) {\n    return a & b ^ a & c ^ b & c;\n  }\n  class HashMD {\n    blockLen;\n    outputLen;\n    padOffset;\n    isLE;\n    // For partial updates less than block size\n    buffer;\n    view;\n    finished = false;\n    length = 0;\n    pos = 0;\n    destroyed = false;\n    constructor(blockLen, outputLen, padOffset, isLE) {\n      this.blockLen = blockLen;\n      this.outputLen = outputLen;\n      this.padOffset = padOffset;\n      this.isLE = isLE;\n      this.buffer = new Uint8Array(blockLen);\n      this.view = createView(this.buffer);\n    }\n    update(data) {\n      aexists(this);\n      abytes(data);\n      const { view, buffer, blockLen } = this;\n      const len = data.length;\n      for (let pos = 0; pos < len; ) {\n        const take = Math.min(blockLen - this.pos, len - pos);\n        if (take === blockLen) {\n          const dataView = createView(data);\n          for (; blockLen <= len - pos; pos += blockLen)\n            this.process(dataView, pos);\n          continue;\n        }\n        buffer.set(data.subarray(pos, pos + take), this.pos);\n        this.pos += take;\n        pos += take;\n        if (this.pos === blockLen) {\n          this.process(view, 0);\n          this.pos = 0;\n        }\n      }\n      this.length += data.length;\n      this.roundClean();\n      return this;\n    }\n    digestInto(out) {\n      aexists(this);\n      aoutput(out, this);\n      this.finished = true;\n      const { buffer, view, blockLen, isLE } = this;\n      let { pos } = this;\n      buffer[pos++] = 128;\n      clean(this.buffer.subarray(pos));\n      if (this.padOffset > blockLen - pos) {\n        this.process(view, 0);\n        pos = 0;\n      }\n      for (let i = pos; i < blockLen; i++)\n        buffer[i] = 0;\n      view.setBigUint64(blockLen - 8, BigInt(this.length * 8), isLE);\n      this.process(view, 0);\n      const oview = createView(out);\n      const len = this.outputLen;\n      if (len % 4)\n        throw new Error("_sha2: outputLen must be aligned to 32bit");\n      const outLen = len / 4;\n      const state = this.get();\n      if (outLen > state.length)\n        throw new Error("_sha2: outputLen bigger than state");\n      for (let i = 0; i < outLen; i++)\n        oview.setUint32(4 * i, state[i], isLE);\n    }\n    digest() {\n      const { buffer, outputLen } = this;\n      this.digestInto(buffer);\n      const res = buffer.slice(0, outputLen);\n      this.destroy();\n      return res;\n    }\n    _cloneInto(to) {\n      to ||= new this.constructor();\n      to.set(...this.get());\n      const { blockLen, buffer, length, finished, destroyed, pos } = this;\n      to.destroyed = destroyed;\n      to.finished = finished;\n      to.length = length;\n      to.pos = pos;\n      if (length % blockLen)\n        to.buffer.set(buffer);\n      return to;\n    }\n    clone() {\n      return this._cloneInto();\n    }\n  }\n  const SHA256_IV = /* @__PURE__ */ Uint32Array.from([\n    1779033703,\n    3144134277,\n    1013904242,\n    2773480762,\n    1359893119,\n    2600822924,\n    528734635,\n    1541459225\n  ]);\n  const SHA256_K = /* @__PURE__ */ Uint32Array.from([\n    1116352408,\n    1899447441,\n    3049323471,\n    3921009573,\n    961987163,\n    1508970993,\n    2453635748,\n    2870763221,\n    3624381080,\n    310598401,\n    607225278,\n    1426881987,\n    1925078388,\n    2162078206,\n    2614888103,\n    3248222580,\n    3835390401,\n    4022224774,\n    264347078,\n    604807628,\n    770255983,\n    1249150122,\n    1555081692,\n    1996064986,\n    2554220882,\n    2821834349,\n    2952996808,\n    3210313671,\n    3336571891,\n    3584528711,\n    113926993,\n    338241895,\n    666307205,\n    773529912,\n    1294757372,\n    1396182291,\n    1695183700,\n    1986661051,\n    2177026350,\n    2456956037,\n    2730485921,\n    2820302411,\n    3259730800,\n    3345764771,\n    3516065817,\n    3600352804,\n    4094571909,\n    275423344,\n    430227734,\n    506948616,\n    659060556,\n    883997877,\n    958139571,\n    1322822218,\n    1537002063,\n    1747873779,\n    1955562222,\n    2024104815,\n    2227730452,\n    2361852424,\n    2428436474,\n    2756734187,\n    3204031479,\n    3329325298\n  ]);\n  const SHA256_W = /* @__PURE__ */ new Uint32Array(64);\n  class SHA2_32B extends HashMD {\n    constructor(outputLen) {\n      super(64, outputLen, 8, false);\n    }\n    get() {\n      const { A, B, C, D, E, F, G, H } = this;\n      return [A, B, C, D, E, F, G, H];\n    }\n    // prettier-ignore\n    set(A, B, C, D, E, F, G, H) {\n      this.A = A | 0;\n      this.B = B | 0;\n      this.C = C | 0;\n      this.D = D | 0;\n      this.E = E | 0;\n      this.F = F | 0;\n      this.G = G | 0;\n      this.H = H | 0;\n    }\n    process(view, offset) {\n      for (let i = 0; i < 16; i++, offset += 4)\n        SHA256_W[i] = view.getUint32(offset, false);\n      for (let i = 16; i < 64; i++) {\n        const W15 = SHA256_W[i - 15];\n        const W2 = SHA256_W[i - 2];\n        const s0 = rotr(W15, 7) ^ rotr(W15, 18) ^ W15 >>> 3;\n        const s1 = rotr(W2, 17) ^ rotr(W2, 19) ^ W2 >>> 10;\n        SHA256_W[i] = s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16] | 0;\n      }\n      let { A, B, C, D, E, F, G, H } = this;\n      for (let i = 0; i < 64; i++) {\n        const sigma1 = rotr(E, 6) ^ rotr(E, 11) ^ rotr(E, 25);\n        const T1 = H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i] | 0;\n        const sigma0 = rotr(A, 2) ^ rotr(A, 13) ^ rotr(A, 22);\n        const T2 = sigma0 + Maj(A, B, C) | 0;\n        H = G;\n        G = F;\n        F = E;\n        E = D + T1 | 0;\n        D = C;\n        C = B;\n        B = A;\n        A = T1 + T2 | 0;\n      }\n      A = A + this.A | 0;\n      B = B + this.B | 0;\n      C = C + this.C | 0;\n      D = D + this.D | 0;\n      E = E + this.E | 0;\n      F = F + this.F | 0;\n      G = G + this.G | 0;\n      H = H + this.H | 0;\n      this.set(A, B, C, D, E, F, G, H);\n    }\n    roundClean() {\n      clean(SHA256_W);\n    }\n    destroy() {\n      this.set(0, 0, 0, 0, 0, 0, 0, 0);\n      clean(this.buffer);\n    }\n  }\n  class _SHA256 extends SHA2_32B {\n    // We cannot use array here since array allows indexing by variable\n    // which means optimizer/compiler cannot use registers.\n    A = SHA256_IV[0] | 0;\n    B = SHA256_IV[1] | 0;\n    C = SHA256_IV[2] | 0;\n    D = SHA256_IV[3] | 0;\n    E = SHA256_IV[4] | 0;\n    F = SHA256_IV[5] | 0;\n    G = SHA256_IV[6] | 0;\n    H = SHA256_IV[7] | 0;\n    constructor() {\n      super(32);\n    }\n  }\n  const sha256 = /* @__PURE__ */ createHasher(\n    () => new _SHA256(),\n    /* @__PURE__ */ oidNist(1)\n  );\n  const MARKER_REGEX = /^\\[([^\\]])\\]\\s+/;\n  const OBSIDIAN_TASK_PRIORITIES = /(ðŸ”º|â«|ðŸ”¼|ðŸ”½|â¬ï¸)/g;\n  function stripLeadingSpaces(spaces, line) {\n    let result = line;\n    let remainingSpaces = spaces;\n    while (remainingSpaces > 0 && result.length > 0) {\n      const firstChar = result[0];\n      if (firstChar === " ") {\n        result = result.slice(1);\n        remainingSpaces--;\n      } else if (firstChar === "	") {\n        const tabSpaces = 4;\n        result = result.slice(1);\n        remainingSpaces -= tabSpaces;\n      } else {\n        break;\n      }\n    }\n    return result;\n  }\n  function parseContent(unparsedTitle, description) {\n    const checkContent = unparsedTitle.match(MARKER_REGEX);\n    unparsedTitle = unparsedTitle.slice(checkContent[0].length);\n    let marker = checkContent[1];\n    const status = parseTaskStatusMarker(marker) ?? "none";\n    let dueDate = null;\n    const dateMatch = unparsedTitle.match(/due: (\\d{4}-\\d{2}-\\d{2})/i);\n    if (dateMatch) {\n      dueDate = dateMatch[1];\n    }\n    const now = (/* @__PURE__ */ new Date()).toISOString();\n    const tags = [];\n    const tagMatches = unparsedTitle.match(/#([a-zA-Z0-9_-]+)/g);\n    if (tagMatches) {\n      tags.push(...tagMatches.map((tag) => tag.substring(1)));\n    }\n    const dataviewTags = {};\n    const dataviewPattern = /\\[([^\\]]+)::([^\\]]+)\\]\\s*/g;\n    for (const match of unparsedTitle.matchAll(dataviewPattern)) {\n      const [key, value] = [match[1], match[2]];\n      dataviewTags[key] = value;\n    }\n    let title = unparsedTitle.replace(dataviewPattern, "").trim();\n    let priority = parseTaskPriority(dataviewTags.priority) ?? "none";\n    let taskPluginPriority = title.match(OBSIDIAN_TASK_PRIORITIES);\n    if (taskPluginPriority && taskPluginPriority[0]) {\n      switch (taskPluginPriority[0]) {\n        case "ðŸ”º":\n          priority = "critical";\n          break;\n        case "â«":\n          priority = "high";\n          break;\n        case "ðŸ”¼":\n          priority = "medium";\n          break;\n        case "ðŸ”½":\n          priority = "low";\n          break;\n        case "â¬ï¸":\n          priority = "wish";\n          break;\n      }\n    }\n    title = title.replace(OBSIDIAN_TASK_PRIORITIES, "").trim();\n    return {\n      title,\n      description,\n      marker,\n      status,\n      priority,\n      project: "default",\n      // default project\n      section: "default",\n      // default section\n      assignee: "",\n      // no assignee by default\n      dueDate,\n      createdAt: now,\n      updatedAt: now,\n      completedAt: null,\n      subtasks: [],\n      dependencies: [],\n      tags\n    };\n  }\n  function countLines(text2) {\n    return text2.split(/\\n/).length;\n  }\n  function parseTasks(path, markdownContent) {\n    const todos = [];\n    try {\n      let processListItem = function(listItem) {\n        const firstChild = listItem.children[0];\n        if (!firstChild || firstChild.type != "paragraph") {\n          return;\n        }\n        const startColumn = firstChild.position.start.column;\n        const startOffset = firstChild.position.start.offset;\n        const endOffset = firstChild.position.end.offset;\n        const titleContent = markdownContent.substring(startOffset, endOffset);\n        if (!MARKER_REGEX.test(titleContent)) {\n          return;\n        }\n        const listItemStartLine = listItem.position.start.line;\n        const listItemStartOffset = listItem.position.start.offset;\n        const id = `${path}:${startOffset}`;\n        if (countLines(markdownContent.substring(0, listItemStartOffset)) != listItemStartLine) {\n          Logger.error("Line count mismatch!");\n        }\n        let description = null;\n        if (listItem.children.length > 1) {\n          const childrenStartOffset = listItem.children[1].position.start.offset;\n          const childrenEndOffset = listItem.children.slice(-1)[0].position.end.offset;\n          const childrenContent = markdownContent.substring(\n            childrenStartOffset,\n            childrenEndOffset\n          );\n          let firstLine = true;\n          description = childrenContent.replace(/^.*$/gm, (str2) => {\n            if (firstLine) {\n              firstLine = false;\n              return str2;\n            }\n            return stripLeadingSpaces(startColumn, str2);\n          });\n        }\n        const taskMeta = {\n          id,\n          path,\n          startLine: listItemStartLine,\n          startColumn: listItem.position.start.column,\n          startOffset: listItemStartOffset,\n          endOffset: listItem.position.end.offset,\n          endLine: listItem.position.end.line,\n          fileHash: sha256(new TextEncoder().encode(markdownContent))\n        };\n        const taskDetails = parseContent(titleContent, description);\n        if (taskDetails.title) {\n          todos.push({ ...taskMeta, ...taskDetails });\n        }\n      };\n      const ast = fromMarkdown(markdownContent);\n      const walkAst = (node2) => {\n        for (const child of node2.children) {\n          if (child.type === "listItem") {\n            processListItem(child);\n          }\n          if ("children" in child) {\n            walkAst(child);\n          }\n        }\n      };\n      walkAst(ast);\n      return todos;\n    } catch (error) {\n      Logger.error("Error parsing markdown:", error);\n      return [];\n    }\n  }\n  var __viteBrowserExternal = {};\n  var __viteBrowserExternal$1 = /* @__PURE__ */ Object.freeze({\n    __proto__: null,\n    default: __viteBrowserExternal\n  });\n  var require$$0 = /* @__PURE__ */ getAugmentedNamespace(__viteBrowserExternal$1);\n  var kindOf;\n  var hasRequiredKindOf;\n  function requireKindOf() {\n    if (hasRequiredKindOf) return kindOf;\n    hasRequiredKindOf = 1;\n    var toString2 = Object.prototype.toString;\n    kindOf = function kindOf2(val) {\n      if (val === void 0) return "undefined";\n      if (val === null) return "null";\n      var type2 = typeof val;\n      if (type2 === "boolean") return "boolean";\n      if (type2 === "string") return "string";\n      if (type2 === "number") return "number";\n      if (type2 === "symbol") return "symbol";\n      if (type2 === "function") {\n        return isGeneratorFn(val) ? "generatorfunction" : "function";\n      }\n      if (isArray(val)) return "array";\n      if (isBuffer(val)) return "buffer";\n      if (isArguments(val)) return "arguments";\n      if (isDate(val)) return "date";\n      if (isError(val)) return "error";\n      if (isRegexp(val)) return "regexp";\n      switch (ctorName(val)) {\n        case "Symbol":\n          return "symbol";\n        case "Promise":\n          return "promise";\n        // Set, Map, WeakSet, WeakMap\n        case "WeakMap":\n          return "weakmap";\n        case "WeakSet":\n          return "weakset";\n        case "Map":\n          return "map";\n        case "Set":\n          return "set";\n        // 8-bit typed arrays\n        case "Int8Array":\n          return "int8array";\n        case "Uint8Array":\n          return "uint8array";\n        case "Uint8ClampedArray":\n          return "uint8clampedarray";\n        // 16-bit typed arrays\n        case "Int16Array":\n          return "int16array";\n        case "Uint16Array":\n          return "uint16array";\n        // 32-bit typed arrays\n        case "Int32Array":\n          return "int32array";\n        case "Uint32Array":\n          return "uint32array";\n        case "Float32Array":\n          return "float32array";\n        case "Float64Array":\n          return "float64array";\n      }\n      if (isGeneratorObj(val)) {\n        return "generator";\n      }\n      type2 = toString2.call(val);\n      switch (type2) {\n        case "[object Object]":\n          return "object";\n        // iterators\n        case "[object Map Iterator]":\n          return "mapiterator";\n        case "[object Set Iterator]":\n          return "setiterator";\n        case "[object String Iterator]":\n          return "stringiterator";\n        case "[object Array Iterator]":\n          return "arrayiterator";\n      }\n      return type2.slice(8, -1).toLowerCase().replace(/\\s/g, "");\n    };\n    function ctorName(val) {\n      return typeof val.constructor === "function" ? val.constructor.name : null;\n    }\n    function isArray(val) {\n      if (Array.isArray) return Array.isArray(val);\n      return val instanceof Array;\n    }\n    function isError(val) {\n      return val instanceof Error || typeof val.message === "string" && val.constructor && typeof val.constructor.stackTraceLimit === "number";\n    }\n    function isDate(val) {\n      if (val instanceof Date) return true;\n      return typeof val.toDateString === "function" && typeof val.getDate === "function" && typeof val.setDate === "function";\n    }\n    function isRegexp(val) {\n      if (val instanceof RegExp) return true;\n      return typeof val.flags === "string" && typeof val.ignoreCase === "boolean" && typeof val.multiline === "boolean" && typeof val.global === "boolean";\n    }\n    function isGeneratorFn(name, val) {\n      return ctorName(name) === "GeneratorFunction";\n    }\n    function isGeneratorObj(val) {\n      return typeof val.throw === "function" && typeof val.return === "function" && typeof val.next === "function";\n    }\n    function isArguments(val) {\n      try {\n        if (typeof val.length === "number" && typeof val.callee === "function") {\n          return true;\n        }\n      } catch (err) {\n        if (err.message.indexOf("callee") !== -1) {\n          return true;\n        }\n      }\n      return false;\n    }\n    function isBuffer(val) {\n      if (val.constructor && typeof val.constructor.isBuffer === "function") {\n        return val.constructor.isBuffer(val);\n      }\n      return false;\n    }\n    return kindOf;\n  }\n  var isExtendable;\n  var hasRequiredIsExtendable;\n  function requireIsExtendable() {\n    if (hasRequiredIsExtendable) return isExtendable;\n    hasRequiredIsExtendable = 1;\n    isExtendable = function isExtendable2(val) {\n      return typeof val !== "undefined" && val !== null && (typeof val === "object" || typeof val === "function");\n    };\n    return isExtendable;\n  }\n  var extendShallow;\n  var hasRequiredExtendShallow;\n  function requireExtendShallow() {\n    if (hasRequiredExtendShallow) return extendShallow;\n    hasRequiredExtendShallow = 1;\n    var isObject = requireIsExtendable();\n    extendShallow = function extend(o) {\n      if (!isObject(o)) {\n        o = {};\n      }\n      var len = arguments.length;\n      for (var i = 1; i < len; i++) {\n        var obj = arguments[i];\n        if (isObject(obj)) {\n          assign(o, obj);\n        }\n      }\n      return o;\n    };\n    function assign(a, b) {\n      for (var key in b) {\n        if (hasOwn(b, key)) {\n          a[key] = b[key];\n        }\n      }\n    }\n    function hasOwn(obj, key) {\n      return Object.prototype.hasOwnProperty.call(obj, key);\n    }\n    return extendShallow;\n  }\n  var sectionMatter;\n  var hasRequiredSectionMatter;\n  function requireSectionMatter() {\n    if (hasRequiredSectionMatter) return sectionMatter;\n    hasRequiredSectionMatter = 1;\n    var typeOf = requireKindOf();\n    var extend = requireExtendShallow();\n    sectionMatter = function(input, options2) {\n      if (typeof options2 === "function") {\n        options2 = { parse: options2 };\n      }\n      var file = toObject(input);\n      var defaults2 = { section_delimiter: "---", parse: identity };\n      var opts = extend({}, defaults2, options2);\n      var delim = opts.section_delimiter;\n      var lines = file.content.split(/\\r?\\n/);\n      var sections = null;\n      var section = createSection();\n      var content2 = [];\n      var stack = [];\n      function initSections(val) {\n        file.content = val;\n        sections = [];\n        content2 = [];\n      }\n      function closeSection(val) {\n        if (stack.length) {\n          section.key = getKey(stack[0], delim);\n          section.content = val;\n          opts.parse(section, sections);\n          sections.push(section);\n          section = createSection();\n          content2 = [];\n          stack = [];\n        }\n      }\n      for (var i = 0; i < lines.length; i++) {\n        var line = lines[i];\n        var len = stack.length;\n        var ln = line.trim();\n        if (isDelimiter(ln, delim)) {\n          if (ln.length === 3 && i !== 0) {\n            if (len === 0 || len === 2) {\n              content2.push(line);\n              continue;\n            }\n            stack.push(ln);\n            section.data = content2.join("\\n");\n            content2 = [];\n            continue;\n          }\n          if (sections === null) {\n            initSections(content2.join("\\n"));\n          }\n          if (len === 2) {\n            closeSection(content2.join("\\n"));\n          }\n          stack.push(ln);\n          continue;\n        }\n        content2.push(line);\n      }\n      if (sections === null) {\n        initSections(content2.join("\\n"));\n      } else {\n        closeSection(content2.join("\\n"));\n      }\n      file.sections = sections;\n      return file;\n    };\n    function isDelimiter(line, delim) {\n      if (line.slice(0, delim.length) !== delim) {\n        return false;\n      }\n      if (line.charAt(delim.length + 1) === delim.slice(-1)) {\n        return false;\n      }\n      return true;\n    }\n    function toObject(input) {\n      if (typeOf(input) !== "object") {\n        input = { content: input };\n      }\n      if (typeof input.content !== "string" && !isBuffer(input.content)) {\n        throw new TypeError("expected a buffer or string");\n      }\n      input.content = input.content.toString();\n      input.sections = [];\n      return input;\n    }\n    function getKey(val, delim) {\n      return val ? val.slice(delim.length).trim() : "";\n    }\n    function createSection() {\n      return { key: "", data: "", content: "" };\n    }\n    function identity(val) {\n      return val;\n    }\n    function isBuffer(val) {\n      if (val && val.constructor && typeof val.constructor.isBuffer === "function") {\n        return val.constructor.isBuffer(val);\n      }\n      return false;\n    }\n    return sectionMatter;\n  }\n  var engines = { exports: {} };\n  var jsYaml$1 = {};\n  var loader = {};\n  var common = {};\n  var hasRequiredCommon;\n  function requireCommon() {\n    if (hasRequiredCommon) return common;\n    hasRequiredCommon = 1;\n    function isNothing(subject) {\n      return typeof subject === "undefined" || subject === null;\n    }\n    function isObject(subject) {\n      return typeof subject === "object" && subject !== null;\n    }\n    function toArray(sequence) {\n      if (Array.isArray(sequence)) return sequence;\n      else if (isNothing(sequence)) return [];\n      return [sequence];\n    }\n    function extend(target, source) {\n      var index2, length, key, sourceKeys;\n      if (source) {\n        sourceKeys = Object.keys(source);\n        for (index2 = 0, length = sourceKeys.length; index2 < length; index2 += 1) {\n          key = sourceKeys[index2];\n          target[key] = source[key];\n        }\n      }\n      return target;\n    }\n    function repeat(string2, count) {\n      var result = "", cycle;\n      for (cycle = 0; cycle < count; cycle += 1) {\n        result += string2;\n      }\n      return result;\n    }\n    function isNegativeZero(number) {\n      return number === 0 && Number.NEGATIVE_INFINITY === 1 / number;\n    }\n    common.isNothing = isNothing;\n    common.isObject = isObject;\n    common.toArray = toArray;\n    common.repeat = repeat;\n    common.isNegativeZero = isNegativeZero;\n    common.extend = extend;\n    return common;\n  }\n  var exception;\n  var hasRequiredException;\n  function requireException() {\n    if (hasRequiredException) return exception;\n    hasRequiredException = 1;\n    function YAMLException(reason, mark2) {\n      Error.call(this);\n      this.name = "YAMLException";\n      this.reason = reason;\n      this.mark = mark2;\n      this.message = (this.reason || "(unknown reason)") + (this.mark ? " " + this.mark.toString() : "");\n      if (Error.captureStackTrace) {\n        Error.captureStackTrace(this, this.constructor);\n      } else {\n        this.stack = new Error().stack || "";\n      }\n    }\n    YAMLException.prototype = Object.create(Error.prototype);\n    YAMLException.prototype.constructor = YAMLException;\n    YAMLException.prototype.toString = function toString2(compact) {\n      var result = this.name + ": ";\n      result += this.reason || "(unknown reason)";\n      if (!compact && this.mark) {\n        result += " " + this.mark.toString();\n      }\n      return result;\n    };\n    exception = YAMLException;\n    return exception;\n  }\n  var mark;\n  var hasRequiredMark;\n  function requireMark() {\n    if (hasRequiredMark) return mark;\n    hasRequiredMark = 1;\n    var common2 = requireCommon();\n    function Mark(name, buffer, position2, line, column) {\n      this.name = name;\n      this.buffer = buffer;\n      this.position = position2;\n      this.line = line;\n      this.column = column;\n    }\n    Mark.prototype.getSnippet = function getSnippet(indent, maxLength) {\n      var head, start, tail, end, snippet;\n      if (!this.buffer) return null;\n      indent = indent || 4;\n      maxLength = maxLength || 75;\n      head = "";\n      start = this.position;\n      while (start > 0 && "\\0\\r\\nÂ…\\u2028\\u2029".indexOf(this.buffer.charAt(start - 1)) === -1) {\n        start -= 1;\n        if (this.position - start > maxLength / 2 - 1) {\n          head = " ... ";\n          start += 5;\n          break;\n        }\n      }\n      tail = "";\n      end = this.position;\n      while (end < this.buffer.length && "\\0\\r\\nÂ…\\u2028\\u2029".indexOf(this.buffer.charAt(end)) === -1) {\n        end += 1;\n        if (end - this.position > maxLength / 2 - 1) {\n          tail = " ... ";\n          end -= 5;\n          break;\n        }\n      }\n      snippet = this.buffer.slice(start, end);\n      return common2.repeat(" ", indent) + head + snippet + tail + "\\n" + common2.repeat(" ", indent + this.position - start + head.length) + "^";\n    };\n    Mark.prototype.toString = function toString2(compact) {\n      var snippet, where = "";\n      if (this.name) {\n        where += \'in "\' + this.name + \'" \';\n      }\n      where += "at line " + (this.line + 1) + ", column " + (this.column + 1);\n      if (!compact) {\n        snippet = this.getSnippet();\n        if (snippet) {\n          where += ":\\n" + snippet;\n        }\n      }\n      return where;\n    };\n    mark = Mark;\n    return mark;\n  }\n  var type;\n  var hasRequiredType;\n  function requireType() {\n    if (hasRequiredType) return type;\n    hasRequiredType = 1;\n    var YAMLException = requireException();\n    var TYPE_CONSTRUCTOR_OPTIONS = [\n      "kind",\n      "resolve",\n      "construct",\n      "instanceOf",\n      "predicate",\n      "represent",\n      "defaultStyle",\n      "styleAliases"\n    ];\n    var YAML_NODE_KINDS = [\n      "scalar",\n      "sequence",\n      "mapping"\n    ];\n    function compileStyleAliases(map2) {\n      var result = {};\n      if (map2 !== null) {\n        Object.keys(map2).forEach(function(style) {\n          map2[style].forEach(function(alias) {\n            result[String(alias)] = style;\n          });\n        });\n      }\n      return result;\n    }\n    function Type(tag, options2) {\n      options2 = options2 || {};\n      Object.keys(options2).forEach(function(name) {\n        if (TYPE_CONSTRUCTOR_OPTIONS.indexOf(name) === -1) {\n          throw new YAMLException(\'Unknown option "\' + name + \'" is met in definition of "\' + tag + \'" YAML type.\');\n        }\n      });\n      this.tag = tag;\n      this.kind = options2["kind"] || null;\n      this.resolve = options2["resolve"] || function() {\n        return true;\n      };\n      this.construct = options2["construct"] || function(data) {\n        return data;\n      };\n      this.instanceOf = options2["instanceOf"] || null;\n      this.predicate = options2["predicate"] || null;\n      this.represent = options2["represent"] || null;\n      this.defaultStyle = options2["defaultStyle"] || null;\n      this.styleAliases = compileStyleAliases(options2["styleAliases"] || null);\n      if (YAML_NODE_KINDS.indexOf(this.kind) === -1) {\n        throw new YAMLException(\'Unknown kind "\' + this.kind + \'" is specified for "\' + tag + \'" YAML type.\');\n      }\n    }\n    type = Type;\n    return type;\n  }\n  var schema;\n  var hasRequiredSchema;\n  function requireSchema() {\n    if (hasRequiredSchema) return schema;\n    hasRequiredSchema = 1;\n    var common2 = requireCommon();\n    var YAMLException = requireException();\n    var Type = requireType();\n    function compileList(schema2, name, result) {\n      var exclude = [];\n      schema2.include.forEach(function(includedSchema) {\n        result = compileList(includedSchema, name, result);\n      });\n      schema2[name].forEach(function(currentType) {\n        result.forEach(function(previousType, previousIndex) {\n          if (previousType.tag === currentType.tag && previousType.kind === currentType.kind) {\n            exclude.push(previousIndex);\n          }\n        });\n        result.push(currentType);\n      });\n      return result.filter(function(type2, index2) {\n        return exclude.indexOf(index2) === -1;\n      });\n    }\n    function compileMap() {\n      var result = {\n        scalar: {},\n        sequence: {},\n        mapping: {},\n        fallback: {}\n      }, index2, length;\n      function collectType(type2) {\n        result[type2.kind][type2.tag] = result["fallback"][type2.tag] = type2;\n      }\n      for (index2 = 0, length = arguments.length; index2 < length; index2 += 1) {\n        arguments[index2].forEach(collectType);\n      }\n      return result;\n    }\n    function Schema(definition2) {\n      this.include = definition2.include || [];\n      this.implicit = definition2.implicit || [];\n      this.explicit = definition2.explicit || [];\n      this.implicit.forEach(function(type2) {\n        if (type2.loadKind && type2.loadKind !== "scalar") {\n          throw new YAMLException("There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.");\n        }\n      });\n      this.compiledImplicit = compileList(this, "implicit", []);\n      this.compiledExplicit = compileList(this, "explicit", []);\n      this.compiledTypeMap = compileMap(this.compiledImplicit, this.compiledExplicit);\n    }\n    Schema.DEFAULT = null;\n    Schema.create = function createSchema() {\n      var schemas, types;\n      switch (arguments.length) {\n        case 1:\n          schemas = Schema.DEFAULT;\n          types = arguments[0];\n          break;\n        case 2:\n          schemas = arguments[0];\n          types = arguments[1];\n          break;\n        default:\n          throw new YAMLException("Wrong number of arguments for Schema.create function");\n      }\n      schemas = common2.toArray(schemas);\n      types = common2.toArray(types);\n      if (!schemas.every(function(schema2) {\n        return schema2 instanceof Schema;\n      })) {\n        throw new YAMLException("Specified list of super schemas (or a single Schema object) contains a non-Schema object.");\n      }\n      if (!types.every(function(type2) {\n        return type2 instanceof Type;\n      })) {\n        throw new YAMLException("Specified list of YAML types (or a single Type object) contains a non-Type object.");\n      }\n      return new Schema({\n        include: schemas,\n        explicit: types\n      });\n    };\n    schema = Schema;\n    return schema;\n  }\n  var str;\n  var hasRequiredStr;\n  function requireStr() {\n    if (hasRequiredStr) return str;\n    hasRequiredStr = 1;\n    var Type = requireType();\n    str = new Type("tag:yaml.org,2002:str", {\n      kind: "scalar",\n      construct: function(data) {\n        return data !== null ? data : "";\n      }\n    });\n    return str;\n  }\n  var seq;\n  var hasRequiredSeq;\n  function requireSeq() {\n    if (hasRequiredSeq) return seq;\n    hasRequiredSeq = 1;\n    var Type = requireType();\n    seq = new Type("tag:yaml.org,2002:seq", {\n      kind: "sequence",\n      construct: function(data) {\n        return data !== null ? data : [];\n      }\n    });\n    return seq;\n  }\n  var map;\n  var hasRequiredMap;\n  function requireMap() {\n    if (hasRequiredMap) return map;\n    hasRequiredMap = 1;\n    var Type = requireType();\n    map = new Type("tag:yaml.org,2002:map", {\n      kind: "mapping",\n      construct: function(data) {\n        return data !== null ? data : {};\n      }\n    });\n    return map;\n  }\n  var failsafe;\n  var hasRequiredFailsafe;\n  function requireFailsafe() {\n    if (hasRequiredFailsafe) return failsafe;\n    hasRequiredFailsafe = 1;\n    var Schema = requireSchema();\n    failsafe = new Schema({\n      explicit: [\n        requireStr(),\n        requireSeq(),\n        requireMap()\n      ]\n    });\n    return failsafe;\n  }\n  var _null;\n  var hasRequired_null;\n  function require_null() {\n    if (hasRequired_null) return _null;\n    hasRequired_null = 1;\n    var Type = requireType();\n    function resolveYamlNull(data) {\n      if (data === null) return true;\n      var max = data.length;\n      return max === 1 && data === "~" || max === 4 && (data === "null" || data === "Null" || data === "NULL");\n    }\n    function constructYamlNull() {\n      return null;\n    }\n    function isNull(object) {\n      return object === null;\n    }\n    _null = new Type("tag:yaml.org,2002:null", {\n      kind: "scalar",\n      resolve: resolveYamlNull,\n      construct: constructYamlNull,\n      predicate: isNull,\n      represent: {\n        canonical: function() {\n          return "~";\n        },\n        lowercase: function() {\n          return "null";\n        },\n        uppercase: function() {\n          return "NULL";\n        },\n        camelcase: function() {\n          return "Null";\n        }\n      },\n      defaultStyle: "lowercase"\n    });\n    return _null;\n  }\n  var bool;\n  var hasRequiredBool;\n  function requireBool() {\n    if (hasRequiredBool) return bool;\n    hasRequiredBool = 1;\n    var Type = requireType();\n    function resolveYamlBoolean(data) {\n      if (data === null) return false;\n      var max = data.length;\n      return max === 4 && (data === "true" || data === "True" || data === "TRUE") || max === 5 && (data === "false" || data === "False" || data === "FALSE");\n    }\n    function constructYamlBoolean(data) {\n      return data === "true" || data === "True" || data === "TRUE";\n    }\n    function isBoolean(object) {\n      return Object.prototype.toString.call(object) === "[object Boolean]";\n    }\n    bool = new Type("tag:yaml.org,2002:bool", {\n      kind: "scalar",\n      resolve: resolveYamlBoolean,\n      construct: constructYamlBoolean,\n      predicate: isBoolean,\n      represent: {\n        lowercase: function(object) {\n          return object ? "true" : "false";\n        },\n        uppercase: function(object) {\n          return object ? "TRUE" : "FALSE";\n        },\n        camelcase: function(object) {\n          return object ? "True" : "False";\n        }\n      },\n      defaultStyle: "lowercase"\n    });\n    return bool;\n  }\n  var int;\n  var hasRequiredInt;\n  function requireInt() {\n    if (hasRequiredInt) return int;\n    hasRequiredInt = 1;\n    var common2 = requireCommon();\n    var Type = requireType();\n    function isHexCode(c) {\n      return 48 <= c && c <= 57 || 65 <= c && c <= 70 || 97 <= c && c <= 102;\n    }\n    function isOctCode(c) {\n      return 48 <= c && c <= 55;\n    }\n    function isDecCode(c) {\n      return 48 <= c && c <= 57;\n    }\n    function resolveYamlInteger(data) {\n      if (data === null) return false;\n      var max = data.length, index2 = 0, hasDigits = false, ch;\n      if (!max) return false;\n      ch = data[index2];\n      if (ch === "-" || ch === "+") {\n        ch = data[++index2];\n      }\n      if (ch === "0") {\n        if (index2 + 1 === max) return true;\n        ch = data[++index2];\n        if (ch === "b") {\n          index2++;\n          for (; index2 < max; index2++) {\n            ch = data[index2];\n            if (ch === "_") continue;\n            if (ch !== "0" && ch !== "1") return false;\n            hasDigits = true;\n          }\n          return hasDigits && ch !== "_";\n        }\n        if (ch === "x") {\n          index2++;\n          for (; index2 < max; index2++) {\n            ch = data[index2];\n            if (ch === "_") continue;\n            if (!isHexCode(data.charCodeAt(index2))) return false;\n            hasDigits = true;\n          }\n          return hasDigits && ch !== "_";\n        }\n        for (; index2 < max; index2++) {\n          ch = data[index2];\n          if (ch === "_") continue;\n          if (!isOctCode(data.charCodeAt(index2))) return false;\n          hasDigits = true;\n        }\n        return hasDigits && ch !== "_";\n      }\n      if (ch === "_") return false;\n      for (; index2 < max; index2++) {\n        ch = data[index2];\n        if (ch === "_") continue;\n        if (ch === ":") break;\n        if (!isDecCode(data.charCodeAt(index2))) {\n          return false;\n        }\n        hasDigits = true;\n      }\n      if (!hasDigits || ch === "_") return false;\n      if (ch !== ":") return true;\n      return /^(:[0-5]?[0-9])+$/.test(data.slice(index2));\n    }\n    function constructYamlInteger(data) {\n      var value = data, sign = 1, ch, base, digits = [];\n      if (value.indexOf("_") !== -1) {\n        value = value.replace(/_/g, "");\n      }\n      ch = value[0];\n      if (ch === "-" || ch === "+") {\n        if (ch === "-") sign = -1;\n        value = value.slice(1);\n        ch = value[0];\n      }\n      if (value === "0") return 0;\n      if (ch === "0") {\n        if (value[1] === "b") return sign * parseInt(value.slice(2), 2);\n        if (value[1] === "x") return sign * parseInt(value, 16);\n        return sign * parseInt(value, 8);\n      }\n      if (value.indexOf(":") !== -1) {\n        value.split(":").forEach(function(v) {\n          digits.unshift(parseInt(v, 10));\n        });\n        value = 0;\n        base = 1;\n        digits.forEach(function(d) {\n          value += d * base;\n          base *= 60;\n        });\n        return sign * value;\n      }\n      return sign * parseInt(value, 10);\n    }\n    function isInteger(object) {\n      return Object.prototype.toString.call(object) === "[object Number]" && (object % 1 === 0 && !common2.isNegativeZero(object));\n    }\n    int = new Type("tag:yaml.org,2002:int", {\n      kind: "scalar",\n      resolve: resolveYamlInteger,\n      construct: constructYamlInteger,\n      predicate: isInteger,\n      represent: {\n        binary: function(obj) {\n          return obj >= 0 ? "0b" + obj.toString(2) : "-0b" + obj.toString(2).slice(1);\n        },\n        octal: function(obj) {\n          return obj >= 0 ? "0" + obj.toString(8) : "-0" + obj.toString(8).slice(1);\n        },\n        decimal: function(obj) {\n          return obj.toString(10);\n        },\n        /* eslint-disable max-len */\n        hexadecimal: function(obj) {\n          return obj >= 0 ? "0x" + obj.toString(16).toUpperCase() : "-0x" + obj.toString(16).toUpperCase().slice(1);\n        }\n      },\n      defaultStyle: "decimal",\n      styleAliases: {\n        binary: [2, "bin"],\n        octal: [8, "oct"],\n        decimal: [10, "dec"],\n        hexadecimal: [16, "hex"]\n      }\n    });\n    return int;\n  }\n  var float;\n  var hasRequiredFloat;\n  function requireFloat() {\n    if (hasRequiredFloat) return float;\n    hasRequiredFloat = 1;\n    var common2 = requireCommon();\n    var Type = requireType();\n    var YAML_FLOAT_PATTERN = new RegExp(\n      // 2.5e4, 2.5 and integers\n      "^(?:[-+]?(?:0|[1-9][0-9_]*)(?:\\\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?|\\\\.[0-9_]+(?:[eE][-+]?[0-9]+)?|[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+\\\\.[0-9_]*|[-+]?\\\\.(?:inf|Inf|INF)|\\\\.(?:nan|NaN|NAN))$"\n    );\n    function resolveYamlFloat(data) {\n      if (data === null) return false;\n      if (!YAML_FLOAT_PATTERN.test(data) || // Quick hack to not allow integers end with `_`\n      // Probably should update regexp & check speed\n      data[data.length - 1] === "_") {\n        return false;\n      }\n      return true;\n    }\n    function constructYamlFloat(data) {\n      var value, sign, base, digits;\n      value = data.replace(/_/g, "").toLowerCase();\n      sign = value[0] === "-" ? -1 : 1;\n      digits = [];\n      if ("+-".indexOf(value[0]) >= 0) {\n        value = value.slice(1);\n      }\n      if (value === ".inf") {\n        return sign === 1 ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY;\n      } else if (value === ".nan") {\n        return NaN;\n      } else if (value.indexOf(":") >= 0) {\n        value.split(":").forEach(function(v) {\n          digits.unshift(parseFloat(v, 10));\n        });\n        value = 0;\n        base = 1;\n        digits.forEach(function(d) {\n          value += d * base;\n          base *= 60;\n        });\n        return sign * value;\n      }\n      return sign * parseFloat(value, 10);\n    }\n    var SCIENTIFIC_WITHOUT_DOT = /^[-+]?[0-9]+e/;\n    function representYamlFloat(object, style) {\n      var res;\n      if (isNaN(object)) {\n        switch (style) {\n          case "lowercase":\n            return ".nan";\n          case "uppercase":\n            return ".NAN";\n          case "camelcase":\n            return ".NaN";\n        }\n      } else if (Number.POSITIVE_INFINITY === object) {\n        switch (style) {\n          case "lowercase":\n            return ".inf";\n          case "uppercase":\n            return ".INF";\n          case "camelcase":\n            return ".Inf";\n        }\n      } else if (Number.NEGATIVE_INFINITY === object) {\n        switch (style) {\n          case "lowercase":\n            return "-.inf";\n          case "uppercase":\n            return "-.INF";\n          case "camelcase":\n            return "-.Inf";\n        }\n      } else if (common2.isNegativeZero(object)) {\n        return "-0.0";\n      }\n      res = object.toString(10);\n      return SCIENTIFIC_WITHOUT_DOT.test(res) ? res.replace("e", ".e") : res;\n    }\n    function isFloat(object) {\n      return Object.prototype.toString.call(object) === "[object Number]" && (object % 1 !== 0 || common2.isNegativeZero(object));\n    }\n    float = new Type("tag:yaml.org,2002:float", {\n      kind: "scalar",\n      resolve: resolveYamlFloat,\n      construct: constructYamlFloat,\n      predicate: isFloat,\n      represent: representYamlFloat,\n      defaultStyle: "lowercase"\n    });\n    return float;\n  }\n  var json;\n  var hasRequiredJson;\n  function requireJson() {\n    if (hasRequiredJson) return json;\n    hasRequiredJson = 1;\n    var Schema = requireSchema();\n    json = new Schema({\n      include: [\n        requireFailsafe()\n      ],\n      implicit: [\n        require_null(),\n        requireBool(),\n        requireInt(),\n        requireFloat()\n      ]\n    });\n    return json;\n  }\n  var core;\n  var hasRequiredCore;\n  function requireCore() {\n    if (hasRequiredCore) return core;\n    hasRequiredCore = 1;\n    var Schema = requireSchema();\n    core = new Schema({\n      include: [\n        requireJson()\n      ]\n    });\n    return core;\n  }\n  var timestamp;\n  var hasRequiredTimestamp;\n  function requireTimestamp() {\n    if (hasRequiredTimestamp) return timestamp;\n    hasRequiredTimestamp = 1;\n    var Type = requireType();\n    var YAML_DATE_REGEXP = new RegExp(\n      "^([0-9][0-9][0-9][0-9])-([0-9][0-9])-([0-9][0-9])$"\n    );\n    var YAML_TIMESTAMP_REGEXP = new RegExp(\n      "^([0-9][0-9][0-9][0-9])-([0-9][0-9]?)-([0-9][0-9]?)(?:[Tt]|[ \\\\t]+)([0-9][0-9]?):([0-9][0-9]):([0-9][0-9])(?:\\\\.([0-9]*))?(?:[ \\\\t]*(Z|([-+])([0-9][0-9]?)(?::([0-9][0-9]))?))?$"\n    );\n    function resolveYamlTimestamp(data) {\n      if (data === null) return false;\n      if (YAML_DATE_REGEXP.exec(data) !== null) return true;\n      if (YAML_TIMESTAMP_REGEXP.exec(data) !== null) return true;\n      return false;\n    }\n    function constructYamlTimestamp(data) {\n      var match, year, month, day, hour, minute, second, fraction = 0, delta = null, tz_hour, tz_minute, date;\n      match = YAML_DATE_REGEXP.exec(data);\n      if (match === null) match = YAML_TIMESTAMP_REGEXP.exec(data);\n      if (match === null) throw new Error("Date resolve error");\n      year = +match[1];\n      month = +match[2] - 1;\n      day = +match[3];\n      if (!match[4]) {\n        return new Date(Date.UTC(year, month, day));\n      }\n      hour = +match[4];\n      minute = +match[5];\n      second = +match[6];\n      if (match[7]) {\n        fraction = match[7].slice(0, 3);\n        while (fraction.length < 3) {\n          fraction += "0";\n        }\n        fraction = +fraction;\n      }\n      if (match[9]) {\n        tz_hour = +match[10];\n        tz_minute = +(match[11] || 0);\n        delta = (tz_hour * 60 + tz_minute) * 6e4;\n        if (match[9] === "-") delta = -delta;\n      }\n      date = new Date(Date.UTC(year, month, day, hour, minute, second, fraction));\n      if (delta) date.setTime(date.getTime() - delta);\n      return date;\n    }\n    function representYamlTimestamp(object) {\n      return object.toISOString();\n    }\n    timestamp = new Type("tag:yaml.org,2002:timestamp", {\n      kind: "scalar",\n      resolve: resolveYamlTimestamp,\n      construct: constructYamlTimestamp,\n      instanceOf: Date,\n      represent: representYamlTimestamp\n    });\n    return timestamp;\n  }\n  var merge;\n  var hasRequiredMerge;\n  function requireMerge() {\n    if (hasRequiredMerge) return merge;\n    hasRequiredMerge = 1;\n    var Type = requireType();\n    function resolveYamlMerge(data) {\n      return data === "<<" || data === null;\n    }\n    merge = new Type("tag:yaml.org,2002:merge", {\n      kind: "scalar",\n      resolve: resolveYamlMerge\n    });\n    return merge;\n  }\n  function commonjsRequire(path) {\n    throw new Error(\'Could not dynamically require "\' + path + \'". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.\');\n  }\n  var binary;\n  var hasRequiredBinary;\n  function requireBinary() {\n    if (hasRequiredBinary) return binary;\n    hasRequiredBinary = 1;\n    var NodeBuffer;\n    try {\n      var _require = commonjsRequire;\n      NodeBuffer = _require("buffer").Buffer;\n    } catch (__) {\n    }\n    var Type = requireType();\n    var BASE64_MAP = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\\n\\r";\n    function resolveYamlBinary(data) {\n      if (data === null) return false;\n      var code, idx, bitlen = 0, max = data.length, map2 = BASE64_MAP;\n      for (idx = 0; idx < max; idx++) {\n        code = map2.indexOf(data.charAt(idx));\n        if (code > 64) continue;\n        if (code < 0) return false;\n        bitlen += 6;\n      }\n      return bitlen % 8 === 0;\n    }\n    function constructYamlBinary(data) {\n      var idx, tailbits, input = data.replace(/[\\r\\n=]/g, ""), max = input.length, map2 = BASE64_MAP, bits = 0, result = [];\n      for (idx = 0; idx < max; idx++) {\n        if (idx % 4 === 0 && idx) {\n          result.push(bits >> 16 & 255);\n          result.push(bits >> 8 & 255);\n          result.push(bits & 255);\n        }\n        bits = bits << 6 | map2.indexOf(input.charAt(idx));\n      }\n      tailbits = max % 4 * 6;\n      if (tailbits === 0) {\n        result.push(bits >> 16 & 255);\n        result.push(bits >> 8 & 255);\n        result.push(bits & 255);\n      } else if (tailbits === 18) {\n        result.push(bits >> 10 & 255);\n        result.push(bits >> 2 & 255);\n      } else if (tailbits === 12) {\n        result.push(bits >> 4 & 255);\n      }\n      if (NodeBuffer) {\n        return NodeBuffer.from ? NodeBuffer.from(result) : new NodeBuffer(result);\n      }\n      return result;\n    }\n    function representYamlBinary(object) {\n      var result = "", bits = 0, idx, tail, max = object.length, map2 = BASE64_MAP;\n      for (idx = 0; idx < max; idx++) {\n        if (idx % 3 === 0 && idx) {\n          result += map2[bits >> 18 & 63];\n          result += map2[bits >> 12 & 63];\n          result += map2[bits >> 6 & 63];\n          result += map2[bits & 63];\n        }\n        bits = (bits << 8) + object[idx];\n      }\n      tail = max % 3;\n      if (tail === 0) {\n        result += map2[bits >> 18 & 63];\n        result += map2[bits >> 12 & 63];\n        result += map2[bits >> 6 & 63];\n        result += map2[bits & 63];\n      } else if (tail === 2) {\n        result += map2[bits >> 10 & 63];\n        result += map2[bits >> 4 & 63];\n        result += map2[bits << 2 & 63];\n        result += map2[64];\n      } else if (tail === 1) {\n        result += map2[bits >> 2 & 63];\n        result += map2[bits << 4 & 63];\n        result += map2[64];\n        result += map2[64];\n      }\n      return result;\n    }\n    function isBinary(object) {\n      return NodeBuffer && NodeBuffer.isBuffer(object);\n    }\n    binary = new Type("tag:yaml.org,2002:binary", {\n      kind: "scalar",\n      resolve: resolveYamlBinary,\n      construct: constructYamlBinary,\n      predicate: isBinary,\n      represent: representYamlBinary\n    });\n    return binary;\n  }\n  var omap;\n  var hasRequiredOmap;\n  function requireOmap() {\n    if (hasRequiredOmap) return omap;\n    hasRequiredOmap = 1;\n    var Type = requireType();\n    var _hasOwnProperty = Object.prototype.hasOwnProperty;\n    var _toString = Object.prototype.toString;\n    function resolveYamlOmap(data) {\n      if (data === null) return true;\n      var objectKeys = [], index2, length, pair, pairKey, pairHasKey, object = data;\n      for (index2 = 0, length = object.length; index2 < length; index2 += 1) {\n        pair = object[index2];\n        pairHasKey = false;\n        if (_toString.call(pair) !== "[object Object]") return false;\n        for (pairKey in pair) {\n          if (_hasOwnProperty.call(pair, pairKey)) {\n            if (!pairHasKey) pairHasKey = true;\n            else return false;\n          }\n        }\n        if (!pairHasKey) return false;\n        if (objectKeys.indexOf(pairKey) === -1) objectKeys.push(pairKey);\n        else return false;\n      }\n      return true;\n    }\n    function constructYamlOmap(data) {\n      return data !== null ? data : [];\n    }\n    omap = new Type("tag:yaml.org,2002:omap", {\n      kind: "sequence",\n      resolve: resolveYamlOmap,\n      construct: constructYamlOmap\n    });\n    return omap;\n  }\n  var pairs;\n  var hasRequiredPairs;\n  function requirePairs() {\n    if (hasRequiredPairs) return pairs;\n    hasRequiredPairs = 1;\n    var Type = requireType();\n    var _toString = Object.prototype.toString;\n    function resolveYamlPairs(data) {\n      if (data === null) return true;\n      var index2, length, pair, keys, result, object = data;\n      result = new Array(object.length);\n      for (index2 = 0, length = object.length; index2 < length; index2 += 1) {\n        pair = object[index2];\n        if (_toString.call(pair) !== "[object Object]") return false;\n        keys = Object.keys(pair);\n        if (keys.length !== 1) return false;\n        result[index2] = [keys[0], pair[keys[0]]];\n      }\n      return true;\n    }\n    function constructYamlPairs(data) {\n      if (data === null) return [];\n      var index2, length, pair, keys, result, object = data;\n      result = new Array(object.length);\n      for (index2 = 0, length = object.length; index2 < length; index2 += 1) {\n        pair = object[index2];\n        keys = Object.keys(pair);\n        result[index2] = [keys[0], pair[keys[0]]];\n      }\n      return result;\n    }\n    pairs = new Type("tag:yaml.org,2002:pairs", {\n      kind: "sequence",\n      resolve: resolveYamlPairs,\n      construct: constructYamlPairs\n    });\n    return pairs;\n  }\n  var set;\n  var hasRequiredSet;\n  function requireSet() {\n    if (hasRequiredSet) return set;\n    hasRequiredSet = 1;\n    var Type = requireType();\n    var _hasOwnProperty = Object.prototype.hasOwnProperty;\n    function resolveYamlSet(data) {\n      if (data === null) return true;\n      var key, object = data;\n      for (key in object) {\n        if (_hasOwnProperty.call(object, key)) {\n          if (object[key] !== null) return false;\n        }\n      }\n      return true;\n    }\n    function constructYamlSet(data) {\n      return data !== null ? data : {};\n    }\n    set = new Type("tag:yaml.org,2002:set", {\n      kind: "mapping",\n      resolve: resolveYamlSet,\n      construct: constructYamlSet\n    });\n    return set;\n  }\n  var default_safe;\n  var hasRequiredDefault_safe;\n  function requireDefault_safe() {\n    if (hasRequiredDefault_safe) return default_safe;\n    hasRequiredDefault_safe = 1;\n    var Schema = requireSchema();\n    default_safe = new Schema({\n      include: [\n        requireCore()\n      ],\n      implicit: [\n        requireTimestamp(),\n        requireMerge()\n      ],\n      explicit: [\n        requireBinary(),\n        requireOmap(),\n        requirePairs(),\n        requireSet()\n      ]\n    });\n    return default_safe;\n  }\n  var _undefined;\n  var hasRequired_undefined;\n  function require_undefined() {\n    if (hasRequired_undefined) return _undefined;\n    hasRequired_undefined = 1;\n    var Type = requireType();\n    function resolveJavascriptUndefined() {\n      return true;\n    }\n    function constructJavascriptUndefined() {\n      return void 0;\n    }\n    function representJavascriptUndefined() {\n      return "";\n    }\n    function isUndefined(object) {\n      return typeof object === "undefined";\n    }\n    _undefined = new Type("tag:yaml.org,2002:js/undefined", {\n      kind: "scalar",\n      resolve: resolveJavascriptUndefined,\n      construct: constructJavascriptUndefined,\n      predicate: isUndefined,\n      represent: representJavascriptUndefined\n    });\n    return _undefined;\n  }\n  var regexp;\n  var hasRequiredRegexp;\n  function requireRegexp() {\n    if (hasRequiredRegexp) return regexp;\n    hasRequiredRegexp = 1;\n    var Type = requireType();\n    function resolveJavascriptRegExp(data) {\n      if (data === null) return false;\n      if (data.length === 0) return false;\n      var regexp2 = data, tail = /\\/([gim]*)$/.exec(data), modifiers = "";\n      if (regexp2[0] === "/") {\n        if (tail) modifiers = tail[1];\n        if (modifiers.length > 3) return false;\n        if (regexp2[regexp2.length - modifiers.length - 1] !== "/") return false;\n      }\n      return true;\n    }\n    function constructJavascriptRegExp(data) {\n      var regexp2 = data, tail = /\\/([gim]*)$/.exec(data), modifiers = "";\n      if (regexp2[0] === "/") {\n        if (tail) modifiers = tail[1];\n        regexp2 = regexp2.slice(1, regexp2.length - modifiers.length - 1);\n      }\n      return new RegExp(regexp2, modifiers);\n    }\n    function representJavascriptRegExp(object) {\n      var result = "/" + object.source + "/";\n      if (object.global) result += "g";\n      if (object.multiline) result += "m";\n      if (object.ignoreCase) result += "i";\n      return result;\n    }\n    function isRegExp(object) {\n      return Object.prototype.toString.call(object) === "[object RegExp]";\n    }\n    regexp = new Type("tag:yaml.org,2002:js/regexp", {\n      kind: "scalar",\n      resolve: resolveJavascriptRegExp,\n      construct: constructJavascriptRegExp,\n      predicate: isRegExp,\n      represent: representJavascriptRegExp\n    });\n    return regexp;\n  }\n  var _function;\n  var hasRequired_function;\n  function require_function() {\n    if (hasRequired_function) return _function;\n    hasRequired_function = 1;\n    var esprima;\n    try {\n      var _require = commonjsRequire;\n      esprima = _require("esprima");\n    } catch (_) {\n      if (typeof window !== "undefined") esprima = window.esprima;\n    }\n    var Type = requireType();\n    function resolveJavascriptFunction(data) {\n      if (data === null) return false;\n      try {\n        var source = "(" + data + ")", ast = esprima.parse(source, { range: true });\n        if (ast.type !== "Program" || ast.body.length !== 1 || ast.body[0].type !== "ExpressionStatement" || ast.body[0].expression.type !== "ArrowFunctionExpression" && ast.body[0].expression.type !== "FunctionExpression") {\n          return false;\n        }\n        return true;\n      } catch (err) {\n        return false;\n      }\n    }\n    function constructJavascriptFunction(data) {\n      var source = "(" + data + ")", ast = esprima.parse(source, { range: true }), params = [], body;\n      if (ast.type !== "Program" || ast.body.length !== 1 || ast.body[0].type !== "ExpressionStatement" || ast.body[0].expression.type !== "ArrowFunctionExpression" && ast.body[0].expression.type !== "FunctionExpression") {\n        throw new Error("Failed to resolve function");\n      }\n      ast.body[0].expression.params.forEach(function(param) {\n        params.push(param.name);\n      });\n      body = ast.body[0].expression.body.range;\n      if (ast.body[0].expression.body.type === "BlockStatement") {\n        return new Function(params, source.slice(body[0] + 1, body[1] - 1));\n      }\n      return new Function(params, "return " + source.slice(body[0], body[1]));\n    }\n    function representJavascriptFunction(object) {\n      return object.toString();\n    }\n    function isFunction(object) {\n      return Object.prototype.toString.call(object) === "[object Function]";\n    }\n    _function = new Type("tag:yaml.org,2002:js/function", {\n      kind: "scalar",\n      resolve: resolveJavascriptFunction,\n      construct: constructJavascriptFunction,\n      predicate: isFunction,\n      represent: representJavascriptFunction\n    });\n    return _function;\n  }\n  var default_full;\n  var hasRequiredDefault_full;\n  function requireDefault_full() {\n    if (hasRequiredDefault_full) return default_full;\n    hasRequiredDefault_full = 1;\n    var Schema = requireSchema();\n    default_full = Schema.DEFAULT = new Schema({\n      include: [\n        requireDefault_safe()\n      ],\n      explicit: [\n        require_undefined(),\n        requireRegexp(),\n        require_function()\n      ]\n    });\n    return default_full;\n  }\n  var hasRequiredLoader;\n  function requireLoader() {\n    if (hasRequiredLoader) return loader;\n    hasRequiredLoader = 1;\n    var common2 = requireCommon();\n    var YAMLException = requireException();\n    var Mark = requireMark();\n    var DEFAULT_SAFE_SCHEMA = requireDefault_safe();\n    var DEFAULT_FULL_SCHEMA = requireDefault_full();\n    var _hasOwnProperty = Object.prototype.hasOwnProperty;\n    var CONTEXT_FLOW_IN = 1;\n    var CONTEXT_FLOW_OUT = 2;\n    var CONTEXT_BLOCK_IN = 3;\n    var CONTEXT_BLOCK_OUT = 4;\n    var CHOMPING_CLIP = 1;\n    var CHOMPING_STRIP = 2;\n    var CHOMPING_KEEP = 3;\n    var PATTERN_NON_PRINTABLE = /[\\x00-\\x08\\x0B\\x0C\\x0E-\\x1F\\x7F-\\x84\\x86-\\x9F\\uFFFE\\uFFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF]/;\n    var PATTERN_NON_ASCII_LINE_BREAKS = /[\\x85\\u2028\\u2029]/;\n    var PATTERN_FLOW_INDICATORS = /[,\\[\\]\\{\\}]/;\n    var PATTERN_TAG_HANDLE = /^(?:!|!!|![a-z\\-]+!)$/i;\n    var PATTERN_TAG_URI = /^(?:!|[^,\\[\\]\\{\\}])(?:%[0-9a-f]{2}|[0-9a-z\\-#;\\/\\?:@&=\\+\\$,_\\.!~\\*\'\\(\\)\\[\\]])*$/i;\n    function _class(obj) {\n      return Object.prototype.toString.call(obj);\n    }\n    function is_EOL(c) {\n      return c === 10 || c === 13;\n    }\n    function is_WHITE_SPACE(c) {\n      return c === 9 || c === 32;\n    }\n    function is_WS_OR_EOL(c) {\n      return c === 9 || c === 32 || c === 10 || c === 13;\n    }\n    function is_FLOW_INDICATOR(c) {\n      return c === 44 || c === 91 || c === 93 || c === 123 || c === 125;\n    }\n    function fromHexCode(c) {\n      var lc;\n      if (48 <= c && c <= 57) {\n        return c - 48;\n      }\n      lc = c | 32;\n      if (97 <= lc && lc <= 102) {\n        return lc - 97 + 10;\n      }\n      return -1;\n    }\n    function escapedHexLen(c) {\n      if (c === 120) {\n        return 2;\n      }\n      if (c === 117) {\n        return 4;\n      }\n      if (c === 85) {\n        return 8;\n      }\n      return 0;\n    }\n    function fromDecimalCode(c) {\n      if (48 <= c && c <= 57) {\n        return c - 48;\n      }\n      return -1;\n    }\n    function simpleEscapeSequence(c) {\n      return c === 48 ? "\\0" : c === 97 ? "\\x07" : c === 98 ? "\\b" : c === 116 ? "	" : c === 9 ? "	" : c === 110 ? "\\n" : c === 118 ? "\\v" : c === 102 ? "\\f" : c === 114 ? "\\r" : c === 101 ? "\\x1B" : c === 32 ? " " : c === 34 ? \'"\' : c === 47 ? "/" : c === 92 ? "\\\\" : c === 78 ? "Â…" : c === 95 ? "Â " : c === 76 ? "\\u2028" : c === 80 ? "\\u2029" : "";\n    }\n    function charFromCodepoint(c) {\n      if (c <= 65535) {\n        return String.fromCharCode(c);\n      }\n      return String.fromCharCode(\n        (c - 65536 >> 10) + 55296,\n        (c - 65536 & 1023) + 56320\n      );\n    }\n    function setProperty(object, key, value) {\n      if (key === "__proto__") {\n        Object.defineProperty(object, key, {\n          configurable: true,\n          enumerable: true,\n          writable: true,\n          value\n        });\n      } else {\n        object[key] = value;\n      }\n    }\n    var simpleEscapeCheck = new Array(256);\n    var simpleEscapeMap = new Array(256);\n    for (var i = 0; i < 256; i++) {\n      simpleEscapeCheck[i] = simpleEscapeSequence(i) ? 1 : 0;\n      simpleEscapeMap[i] = simpleEscapeSequence(i);\n    }\n    function State(input, options2) {\n      this.input = input;\n      this.filename = options2["filename"] || null;\n      this.schema = options2["schema"] || DEFAULT_FULL_SCHEMA;\n      this.onWarning = options2["onWarning"] || null;\n      this.legacy = options2["legacy"] || false;\n      this.json = options2["json"] || false;\n      this.listener = options2["listener"] || null;\n      this.implicitTypes = this.schema.compiledImplicit;\n      this.typeMap = this.schema.compiledTypeMap;\n      this.length = input.length;\n      this.position = 0;\n      this.line = 0;\n      this.lineStart = 0;\n      this.lineIndent = 0;\n      this.documents = [];\n    }\n    function generateError(state, message) {\n      return new YAMLException(\n        message,\n        new Mark(state.filename, state.input, state.position, state.line, state.position - state.lineStart)\n      );\n    }\n    function throwError(state, message) {\n      throw generateError(state, message);\n    }\n    function throwWarning(state, message) {\n      if (state.onWarning) {\n        state.onWarning.call(null, generateError(state, message));\n      }\n    }\n    var directiveHandlers = {\n      YAML: function handleYamlDirective(state, name, args) {\n        var match, major, minor;\n        if (state.version !== null) {\n          throwError(state, "duplication of %YAML directive");\n        }\n        if (args.length !== 1) {\n          throwError(state, "YAML directive accepts exactly one argument");\n        }\n        match = /^([0-9]+)\\.([0-9]+)$/.exec(args[0]);\n        if (match === null) {\n          throwError(state, "ill-formed argument of the YAML directive");\n        }\n        major = parseInt(match[1], 10);\n        minor = parseInt(match[2], 10);\n        if (major !== 1) {\n          throwError(state, "unacceptable YAML version of the document");\n        }\n        state.version = args[0];\n        state.checkLineBreaks = minor < 2;\n        if (minor !== 1 && minor !== 2) {\n          throwWarning(state, "unsupported YAML version of the document");\n        }\n      },\n      TAG: function handleTagDirective(state, name, args) {\n        var handle, prefix;\n        if (args.length !== 2) {\n          throwError(state, "TAG directive accepts exactly two arguments");\n        }\n        handle = args[0];\n        prefix = args[1];\n        if (!PATTERN_TAG_HANDLE.test(handle)) {\n          throwError(state, "ill-formed tag handle (first argument) of the TAG directive");\n        }\n        if (_hasOwnProperty.call(state.tagMap, handle)) {\n          throwError(state, \'there is a previously declared suffix for "\' + handle + \'" tag handle\');\n        }\n        if (!PATTERN_TAG_URI.test(prefix)) {\n          throwError(state, "ill-formed tag prefix (second argument) of the TAG directive");\n        }\n        state.tagMap[handle] = prefix;\n      }\n    };\n    function captureSegment(state, start, end, checkJson) {\n      var _position, _length, _character, _result;\n      if (start < end) {\n        _result = state.input.slice(start, end);\n        if (checkJson) {\n          for (_position = 0, _length = _result.length; _position < _length; _position += 1) {\n            _character = _result.charCodeAt(_position);\n            if (!(_character === 9 || 32 <= _character && _character <= 1114111)) {\n              throwError(state, "expected valid JSON character");\n            }\n          }\n        } else if (PATTERN_NON_PRINTABLE.test(_result)) {\n          throwError(state, "the stream contains non-printable characters");\n        }\n        state.result += _result;\n      }\n    }\n    function mergeMappings(state, destination, source, overridableKeys) {\n      var sourceKeys, key, index2, quantity;\n      if (!common2.isObject(source)) {\n        throwError(state, "cannot merge mappings; the provided source object is unacceptable");\n      }\n      sourceKeys = Object.keys(source);\n      for (index2 = 0, quantity = sourceKeys.length; index2 < quantity; index2 += 1) {\n        key = sourceKeys[index2];\n        if (!_hasOwnProperty.call(destination, key)) {\n          setProperty(destination, key, source[key]);\n          overridableKeys[key] = true;\n        }\n      }\n    }\n    function storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, startLine, startPos) {\n      var index2, quantity;\n      if (Array.isArray(keyNode)) {\n        keyNode = Array.prototype.slice.call(keyNode);\n        for (index2 = 0, quantity = keyNode.length; index2 < quantity; index2 += 1) {\n          if (Array.isArray(keyNode[index2])) {\n            throwError(state, "nested arrays are not supported inside keys");\n          }\n          if (typeof keyNode === "object" && _class(keyNode[index2]) === "[object Object]") {\n            keyNode[index2] = "[object Object]";\n          }\n        }\n      }\n      if (typeof keyNode === "object" && _class(keyNode) === "[object Object]") {\n        keyNode = "[object Object]";\n      }\n      keyNode = String(keyNode);\n      if (_result === null) {\n        _result = {};\n      }\n      if (keyTag === "tag:yaml.org,2002:merge") {\n        if (Array.isArray(valueNode)) {\n          for (index2 = 0, quantity = valueNode.length; index2 < quantity; index2 += 1) {\n            mergeMappings(state, _result, valueNode[index2], overridableKeys);\n          }\n        } else {\n          mergeMappings(state, _result, valueNode, overridableKeys);\n        }\n      } else {\n        if (!state.json && !_hasOwnProperty.call(overridableKeys, keyNode) && _hasOwnProperty.call(_result, keyNode)) {\n          state.line = startLine || state.line;\n          state.position = startPos || state.position;\n          throwError(state, "duplicated mapping key");\n        }\n        setProperty(_result, keyNode, valueNode);\n        delete overridableKeys[keyNode];\n      }\n      return _result;\n    }\n    function readLineBreak(state) {\n      var ch;\n      ch = state.input.charCodeAt(state.position);\n      if (ch === 10) {\n        state.position++;\n      } else if (ch === 13) {\n        state.position++;\n        if (state.input.charCodeAt(state.position) === 10) {\n          state.position++;\n        }\n      } else {\n        throwError(state, "a line break is expected");\n      }\n      state.line += 1;\n      state.lineStart = state.position;\n    }\n    function skipSeparationSpace(state, allowComments, checkIndent) {\n      var lineBreaks = 0, ch = state.input.charCodeAt(state.position);\n      while (ch !== 0) {\n        while (is_WHITE_SPACE(ch)) {\n          ch = state.input.charCodeAt(++state.position);\n        }\n        if (allowComments && ch === 35) {\n          do {\n            ch = state.input.charCodeAt(++state.position);\n          } while (ch !== 10 && ch !== 13 && ch !== 0);\n        }\n        if (is_EOL(ch)) {\n          readLineBreak(state);\n          ch = state.input.charCodeAt(state.position);\n          lineBreaks++;\n          state.lineIndent = 0;\n          while (ch === 32) {\n            state.lineIndent++;\n            ch = state.input.charCodeAt(++state.position);\n          }\n        } else {\n          break;\n        }\n      }\n      if (checkIndent !== -1 && lineBreaks !== 0 && state.lineIndent < checkIndent) {\n        throwWarning(state, "deficient indentation");\n      }\n      return lineBreaks;\n    }\n    function testDocumentSeparator(state) {\n      var _position = state.position, ch;\n      ch = state.input.charCodeAt(_position);\n      if ((ch === 45 || ch === 46) && ch === state.input.charCodeAt(_position + 1) && ch === state.input.charCodeAt(_position + 2)) {\n        _position += 3;\n        ch = state.input.charCodeAt(_position);\n        if (ch === 0 || is_WS_OR_EOL(ch)) {\n          return true;\n        }\n      }\n      return false;\n    }\n    function writeFoldedLines(state, count) {\n      if (count === 1) {\n        state.result += " ";\n      } else if (count > 1) {\n        state.result += common2.repeat("\\n", count - 1);\n      }\n    }\n    function readPlainScalar(state, nodeIndent, withinFlowCollection) {\n      var preceding, following, captureStart, captureEnd, hasPendingContent, _line, _lineStart, _lineIndent, _kind = state.kind, _result = state.result, ch;\n      ch = state.input.charCodeAt(state.position);\n      if (is_WS_OR_EOL(ch) || is_FLOW_INDICATOR(ch) || ch === 35 || ch === 38 || ch === 42 || ch === 33 || ch === 124 || ch === 62 || ch === 39 || ch === 34 || ch === 37 || ch === 64 || ch === 96) {\n        return false;\n      }\n      if (ch === 63 || ch === 45) {\n        following = state.input.charCodeAt(state.position + 1);\n        if (is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following)) {\n          return false;\n        }\n      }\n      state.kind = "scalar";\n      state.result = "";\n      captureStart = captureEnd = state.position;\n      hasPendingContent = false;\n      while (ch !== 0) {\n        if (ch === 58) {\n          following = state.input.charCodeAt(state.position + 1);\n          if (is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following)) {\n            break;\n          }\n        } else if (ch === 35) {\n          preceding = state.input.charCodeAt(state.position - 1);\n          if (is_WS_OR_EOL(preceding)) {\n            break;\n          }\n        } else if (state.position === state.lineStart && testDocumentSeparator(state) || withinFlowCollection && is_FLOW_INDICATOR(ch)) {\n          break;\n        } else if (is_EOL(ch)) {\n          _line = state.line;\n          _lineStart = state.lineStart;\n          _lineIndent = state.lineIndent;\n          skipSeparationSpace(state, false, -1);\n          if (state.lineIndent >= nodeIndent) {\n            hasPendingContent = true;\n            ch = state.input.charCodeAt(state.position);\n            continue;\n          } else {\n            state.position = captureEnd;\n            state.line = _line;\n            state.lineStart = _lineStart;\n            state.lineIndent = _lineIndent;\n            break;\n          }\n        }\n        if (hasPendingContent) {\n          captureSegment(state, captureStart, captureEnd, false);\n          writeFoldedLines(state, state.line - _line);\n          captureStart = captureEnd = state.position;\n          hasPendingContent = false;\n        }\n        if (!is_WHITE_SPACE(ch)) {\n          captureEnd = state.position + 1;\n        }\n        ch = state.input.charCodeAt(++state.position);\n      }\n      captureSegment(state, captureStart, captureEnd, false);\n      if (state.result) {\n        return true;\n      }\n      state.kind = _kind;\n      state.result = _result;\n      return false;\n    }\n    function readSingleQuotedScalar(state, nodeIndent) {\n      var ch, captureStart, captureEnd;\n      ch = state.input.charCodeAt(state.position);\n      if (ch !== 39) {\n        return false;\n      }\n      state.kind = "scalar";\n      state.result = "";\n      state.position++;\n      captureStart = captureEnd = state.position;\n      while ((ch = state.input.charCodeAt(state.position)) !== 0) {\n        if (ch === 39) {\n          captureSegment(state, captureStart, state.position, true);\n          ch = state.input.charCodeAt(++state.position);\n          if (ch === 39) {\n            captureStart = state.position;\n            state.position++;\n            captureEnd = state.position;\n          } else {\n            return true;\n          }\n        } else if (is_EOL(ch)) {\n          captureSegment(state, captureStart, captureEnd, true);\n          writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));\n          captureStart = captureEnd = state.position;\n        } else if (state.position === state.lineStart && testDocumentSeparator(state)) {\n          throwError(state, "unexpected end of the document within a single quoted scalar");\n        } else {\n          state.position++;\n          captureEnd = state.position;\n        }\n      }\n      throwError(state, "unexpected end of the stream within a single quoted scalar");\n    }\n    function readDoubleQuotedScalar(state, nodeIndent) {\n      var captureStart, captureEnd, hexLength, hexResult, tmp, ch;\n      ch = state.input.charCodeAt(state.position);\n      if (ch !== 34) {\n        return false;\n      }\n      state.kind = "scalar";\n      state.result = "";\n      state.position++;\n      captureStart = captureEnd = state.position;\n      while ((ch = state.input.charCodeAt(state.position)) !== 0) {\n        if (ch === 34) {\n          captureSegment(state, captureStart, state.position, true);\n          state.position++;\n          return true;\n        } else if (ch === 92) {\n          captureSegment(state, captureStart, state.position, true);\n          ch = state.input.charCodeAt(++state.position);\n          if (is_EOL(ch)) {\n            skipSeparationSpace(state, false, nodeIndent);\n          } else if (ch < 256 && simpleEscapeCheck[ch]) {\n            state.result += simpleEscapeMap[ch];\n            state.position++;\n          } else if ((tmp = escapedHexLen(ch)) > 0) {\n            hexLength = tmp;\n            hexResult = 0;\n            for (; hexLength > 0; hexLength--) {\n              ch = state.input.charCodeAt(++state.position);\n              if ((tmp = fromHexCode(ch)) >= 0) {\n                hexResult = (hexResult << 4) + tmp;\n              } else {\n                throwError(state, "expected hexadecimal character");\n              }\n            }\n            state.result += charFromCodepoint(hexResult);\n            state.position++;\n          } else {\n            throwError(state, "unknown escape sequence");\n          }\n          captureStart = captureEnd = state.position;\n        } else if (is_EOL(ch)) {\n          captureSegment(state, captureStart, captureEnd, true);\n          writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));\n          captureStart = captureEnd = state.position;\n        } else if (state.position === state.lineStart && testDocumentSeparator(state)) {\n          throwError(state, "unexpected end of the document within a double quoted scalar");\n        } else {\n          state.position++;\n          captureEnd = state.position;\n        }\n      }\n      throwError(state, "unexpected end of the stream within a double quoted scalar");\n    }\n    function readFlowCollection(state, nodeIndent) {\n      var readNext = true, _line, _tag = state.tag, _result, _anchor = state.anchor, following, terminator, isPair, isExplicitPair, isMapping, overridableKeys = {}, keyNode, keyTag, valueNode, ch;\n      ch = state.input.charCodeAt(state.position);\n      if (ch === 91) {\n        terminator = 93;\n        isMapping = false;\n        _result = [];\n      } else if (ch === 123) {\n        terminator = 125;\n        isMapping = true;\n        _result = {};\n      } else {\n        return false;\n      }\n      if (state.anchor !== null) {\n        state.anchorMap[state.anchor] = _result;\n      }\n      ch = state.input.charCodeAt(++state.position);\n      while (ch !== 0) {\n        skipSeparationSpace(state, true, nodeIndent);\n        ch = state.input.charCodeAt(state.position);\n        if (ch === terminator) {\n          state.position++;\n          state.tag = _tag;\n          state.anchor = _anchor;\n          state.kind = isMapping ? "mapping" : "sequence";\n          state.result = _result;\n          return true;\n        } else if (!readNext) {\n          throwError(state, "missed comma between flow collection entries");\n        }\n        keyTag = keyNode = valueNode = null;\n        isPair = isExplicitPair = false;\n        if (ch === 63) {\n          following = state.input.charCodeAt(state.position + 1);\n          if (is_WS_OR_EOL(following)) {\n            isPair = isExplicitPair = true;\n            state.position++;\n            skipSeparationSpace(state, true, nodeIndent);\n          }\n        }\n        _line = state.line;\n        composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);\n        keyTag = state.tag;\n        keyNode = state.result;\n        skipSeparationSpace(state, true, nodeIndent);\n        ch = state.input.charCodeAt(state.position);\n        if ((isExplicitPair || state.line === _line) && ch === 58) {\n          isPair = true;\n          ch = state.input.charCodeAt(++state.position);\n          skipSeparationSpace(state, true, nodeIndent);\n          composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);\n          valueNode = state.result;\n        }\n        if (isMapping) {\n          storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode);\n        } else if (isPair) {\n          _result.push(storeMappingPair(state, null, overridableKeys, keyTag, keyNode, valueNode));\n        } else {\n          _result.push(keyNode);\n        }\n        skipSeparationSpace(state, true, nodeIndent);\n        ch = state.input.charCodeAt(state.position);\n        if (ch === 44) {\n          readNext = true;\n          ch = state.input.charCodeAt(++state.position);\n        } else {\n          readNext = false;\n        }\n      }\n      throwError(state, "unexpected end of the stream within a flow collection");\n    }\n    function readBlockScalar(state, nodeIndent) {\n      var captureStart, folding, chomping = CHOMPING_CLIP, didReadContent = false, detectedIndent = false, textIndent = nodeIndent, emptyLines = 0, atMoreIndented = false, tmp, ch;\n      ch = state.input.charCodeAt(state.position);\n      if (ch === 124) {\n        folding = false;\n      } else if (ch === 62) {\n        folding = true;\n      } else {\n        return false;\n      }\n      state.kind = "scalar";\n      state.result = "";\n      while (ch !== 0) {\n        ch = state.input.charCodeAt(++state.position);\n        if (ch === 43 || ch === 45) {\n          if (CHOMPING_CLIP === chomping) {\n            chomping = ch === 43 ? CHOMPING_KEEP : CHOMPING_STRIP;\n          } else {\n            throwError(state, "repeat of a chomping mode identifier");\n          }\n        } else if ((tmp = fromDecimalCode(ch)) >= 0) {\n          if (tmp === 0) {\n            throwError(state, "bad explicit indentation width of a block scalar; it cannot be less than one");\n          } else if (!detectedIndent) {\n            textIndent = nodeIndent + tmp - 1;\n            detectedIndent = true;\n          } else {\n            throwError(state, "repeat of an indentation width identifier");\n          }\n        } else {\n          break;\n        }\n      }\n      if (is_WHITE_SPACE(ch)) {\n        do {\n          ch = state.input.charCodeAt(++state.position);\n        } while (is_WHITE_SPACE(ch));\n        if (ch === 35) {\n          do {\n            ch = state.input.charCodeAt(++state.position);\n          } while (!is_EOL(ch) && ch !== 0);\n        }\n      }\n      while (ch !== 0) {\n        readLineBreak(state);\n        state.lineIndent = 0;\n        ch = state.input.charCodeAt(state.position);\n        while ((!detectedIndent || state.lineIndent < textIndent) && ch === 32) {\n          state.lineIndent++;\n          ch = state.input.charCodeAt(++state.position);\n        }\n        if (!detectedIndent && state.lineIndent > textIndent) {\n          textIndent = state.lineIndent;\n        }\n        if (is_EOL(ch)) {\n          emptyLines++;\n          continue;\n        }\n        if (state.lineIndent < textIndent) {\n          if (chomping === CHOMPING_KEEP) {\n            state.result += common2.repeat("\\n", didReadContent ? 1 + emptyLines : emptyLines);\n          } else if (chomping === CHOMPING_CLIP) {\n            if (didReadContent) {\n              state.result += "\\n";\n            }\n          }\n          break;\n        }\n        if (folding) {\n          if (is_WHITE_SPACE(ch)) {\n            atMoreIndented = true;\n            state.result += common2.repeat("\\n", didReadContent ? 1 + emptyLines : emptyLines);\n          } else if (atMoreIndented) {\n            atMoreIndented = false;\n            state.result += common2.repeat("\\n", emptyLines + 1);\n          } else if (emptyLines === 0) {\n            if (didReadContent) {\n              state.result += " ";\n            }\n          } else {\n            state.result += common2.repeat("\\n", emptyLines);\n          }\n        } else {\n          state.result += common2.repeat("\\n", didReadContent ? 1 + emptyLines : emptyLines);\n        }\n        didReadContent = true;\n        detectedIndent = true;\n        emptyLines = 0;\n        captureStart = state.position;\n        while (!is_EOL(ch) && ch !== 0) {\n          ch = state.input.charCodeAt(++state.position);\n        }\n        captureSegment(state, captureStart, state.position, false);\n      }\n      return true;\n    }\n    function readBlockSequence(state, nodeIndent) {\n      var _line, _tag = state.tag, _anchor = state.anchor, _result = [], following, detected = false, ch;\n      if (state.anchor !== null) {\n        state.anchorMap[state.anchor] = _result;\n      }\n      ch = state.input.charCodeAt(state.position);\n      while (ch !== 0) {\n        if (ch !== 45) {\n          break;\n        }\n        following = state.input.charCodeAt(state.position + 1);\n        if (!is_WS_OR_EOL(following)) {\n          break;\n        }\n        detected = true;\n        state.position++;\n        if (skipSeparationSpace(state, true, -1)) {\n          if (state.lineIndent <= nodeIndent) {\n            _result.push(null);\n            ch = state.input.charCodeAt(state.position);\n            continue;\n          }\n        }\n        _line = state.line;\n        composeNode(state, nodeIndent, CONTEXT_BLOCK_IN, false, true);\n        _result.push(state.result);\n        skipSeparationSpace(state, true, -1);\n        ch = state.input.charCodeAt(state.position);\n        if ((state.line === _line || state.lineIndent > nodeIndent) && ch !== 0) {\n          throwError(state, "bad indentation of a sequence entry");\n        } else if (state.lineIndent < nodeIndent) {\n          break;\n        }\n      }\n      if (detected) {\n        state.tag = _tag;\n        state.anchor = _anchor;\n        state.kind = "sequence";\n        state.result = _result;\n        return true;\n      }\n      return false;\n    }\n    function readBlockMapping(state, nodeIndent, flowIndent) {\n      var following, allowCompact, _line, _pos, _tag = state.tag, _anchor = state.anchor, _result = {}, overridableKeys = {}, keyTag = null, keyNode = null, valueNode = null, atExplicitKey = false, detected = false, ch;\n      if (state.anchor !== null) {\n        state.anchorMap[state.anchor] = _result;\n      }\n      ch = state.input.charCodeAt(state.position);\n      while (ch !== 0) {\n        following = state.input.charCodeAt(state.position + 1);\n        _line = state.line;\n        _pos = state.position;\n        if ((ch === 63 || ch === 58) && is_WS_OR_EOL(following)) {\n          if (ch === 63) {\n            if (atExplicitKey) {\n              storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null);\n              keyTag = keyNode = valueNode = null;\n            }\n            detected = true;\n            atExplicitKey = true;\n            allowCompact = true;\n          } else if (atExplicitKey) {\n            atExplicitKey = false;\n            allowCompact = true;\n          } else {\n            throwError(state, "incomplete explicit mapping pair; a key node is missed; or followed by a non-tabulated empty line");\n          }\n          state.position += 1;\n          ch = following;\n        } else if (composeNode(state, flowIndent, CONTEXT_FLOW_OUT, false, true)) {\n          if (state.line === _line) {\n            ch = state.input.charCodeAt(state.position);\n            while (is_WHITE_SPACE(ch)) {\n              ch = state.input.charCodeAt(++state.position);\n            }\n            if (ch === 58) {\n              ch = state.input.charCodeAt(++state.position);\n              if (!is_WS_OR_EOL(ch)) {\n                throwError(state, "a whitespace character is expected after the key-value separator within a block mapping");\n              }\n              if (atExplicitKey) {\n                storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null);\n                keyTag = keyNode = valueNode = null;\n              }\n              detected = true;\n              atExplicitKey = false;\n              allowCompact = false;\n              keyTag = state.tag;\n              keyNode = state.result;\n            } else if (detected) {\n              throwError(state, "can not read an implicit mapping pair; a colon is missed");\n            } else {\n              state.tag = _tag;\n              state.anchor = _anchor;\n              return true;\n            }\n          } else if (detected) {\n            throwError(state, "can not read a block mapping entry; a multiline key may not be an implicit key");\n          } else {\n            state.tag = _tag;\n            state.anchor = _anchor;\n            return true;\n          }\n        } else {\n          break;\n        }\n        if (state.line === _line || state.lineIndent > nodeIndent) {\n          if (composeNode(state, nodeIndent, CONTEXT_BLOCK_OUT, true, allowCompact)) {\n            if (atExplicitKey) {\n              keyNode = state.result;\n            } else {\n              valueNode = state.result;\n            }\n          }\n          if (!atExplicitKey) {\n            storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _line, _pos);\n            keyTag = keyNode = valueNode = null;\n          }\n          skipSeparationSpace(state, true, -1);\n          ch = state.input.charCodeAt(state.position);\n        }\n        if (state.lineIndent > nodeIndent && ch !== 0) {\n          throwError(state, "bad indentation of a mapping entry");\n        } else if (state.lineIndent < nodeIndent) {\n          break;\n        }\n      }\n      if (atExplicitKey) {\n        storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null);\n      }\n      if (detected) {\n        state.tag = _tag;\n        state.anchor = _anchor;\n        state.kind = "mapping";\n        state.result = _result;\n      }\n      return detected;\n    }\n    function readTagProperty(state) {\n      var _position, isVerbatim = false, isNamed = false, tagHandle, tagName, ch;\n      ch = state.input.charCodeAt(state.position);\n      if (ch !== 33) return false;\n      if (state.tag !== null) {\n        throwError(state, "duplication of a tag property");\n      }\n      ch = state.input.charCodeAt(++state.position);\n      if (ch === 60) {\n        isVerbatim = true;\n        ch = state.input.charCodeAt(++state.position);\n      } else if (ch === 33) {\n        isNamed = true;\n        tagHandle = "!!";\n        ch = state.input.charCodeAt(++state.position);\n      } else {\n        tagHandle = "!";\n      }\n      _position = state.position;\n      if (isVerbatim) {\n        do {\n          ch = state.input.charCodeAt(++state.position);\n        } while (ch !== 0 && ch !== 62);\n        if (state.position < state.length) {\n          tagName = state.input.slice(_position, state.position);\n          ch = state.input.charCodeAt(++state.position);\n        } else {\n          throwError(state, "unexpected end of the stream within a verbatim tag");\n        }\n      } else {\n        while (ch !== 0 && !is_WS_OR_EOL(ch)) {\n          if (ch === 33) {\n            if (!isNamed) {\n              tagHandle = state.input.slice(_position - 1, state.position + 1);\n              if (!PATTERN_TAG_HANDLE.test(tagHandle)) {\n                throwError(state, "named tag handle cannot contain such characters");\n              }\n              isNamed = true;\n              _position = state.position + 1;\n            } else {\n              throwError(state, "tag suffix cannot contain exclamation marks");\n            }\n          }\n          ch = state.input.charCodeAt(++state.position);\n        }\n        tagName = state.input.slice(_position, state.position);\n        if (PATTERN_FLOW_INDICATORS.test(tagName)) {\n          throwError(state, "tag suffix cannot contain flow indicator characters");\n        }\n      }\n      if (tagName && !PATTERN_TAG_URI.test(tagName)) {\n        throwError(state, "tag name cannot contain such characters: " + tagName);\n      }\n      if (isVerbatim) {\n        state.tag = tagName;\n      } else if (_hasOwnProperty.call(state.tagMap, tagHandle)) {\n        state.tag = state.tagMap[tagHandle] + tagName;\n      } else if (tagHandle === "!") {\n        state.tag = "!" + tagName;\n      } else if (tagHandle === "!!") {\n        state.tag = "tag:yaml.org,2002:" + tagName;\n      } else {\n        throwError(state, \'undeclared tag handle "\' + tagHandle + \'"\');\n      }\n      return true;\n    }\n    function readAnchorProperty(state) {\n      var _position, ch;\n      ch = state.input.charCodeAt(state.position);\n      if (ch !== 38) return false;\n      if (state.anchor !== null) {\n        throwError(state, "duplication of an anchor property");\n      }\n      ch = state.input.charCodeAt(++state.position);\n      _position = state.position;\n      while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {\n        ch = state.input.charCodeAt(++state.position);\n      }\n      if (state.position === _position) {\n        throwError(state, "name of an anchor node must contain at least one character");\n      }\n      state.anchor = state.input.slice(_position, state.position);\n      return true;\n    }\n    function readAlias(state) {\n      var _position, alias, ch;\n      ch = state.input.charCodeAt(state.position);\n      if (ch !== 42) return false;\n      ch = state.input.charCodeAt(++state.position);\n      _position = state.position;\n      while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {\n        ch = state.input.charCodeAt(++state.position);\n      }\n      if (state.position === _position) {\n        throwError(state, "name of an alias node must contain at least one character");\n      }\n      alias = state.input.slice(_position, state.position);\n      if (!_hasOwnProperty.call(state.anchorMap, alias)) {\n        throwError(state, \'unidentified alias "\' + alias + \'"\');\n      }\n      state.result = state.anchorMap[alias];\n      skipSeparationSpace(state, true, -1);\n      return true;\n    }\n    function composeNode(state, parentIndent, nodeContext, allowToSeek, allowCompact) {\n      var allowBlockStyles, allowBlockScalars, allowBlockCollections, indentStatus = 1, atNewLine = false, hasContent = false, typeIndex, typeQuantity, type2, flowIndent, blockIndent;\n      if (state.listener !== null) {\n        state.listener("open", state);\n      }\n      state.tag = null;\n      state.anchor = null;\n      state.kind = null;\n      state.result = null;\n      allowBlockStyles = allowBlockScalars = allowBlockCollections = CONTEXT_BLOCK_OUT === nodeContext || CONTEXT_BLOCK_IN === nodeContext;\n      if (allowToSeek) {\n        if (skipSeparationSpace(state, true, -1)) {\n          atNewLine = true;\n          if (state.lineIndent > parentIndent) {\n            indentStatus = 1;\n          } else if (state.lineIndent === parentIndent) {\n            indentStatus = 0;\n          } else if (state.lineIndent < parentIndent) {\n            indentStatus = -1;\n          }\n        }\n      }\n      if (indentStatus === 1) {\n        while (readTagProperty(state) || readAnchorProperty(state)) {\n          if (skipSeparationSpace(state, true, -1)) {\n            atNewLine = true;\n            allowBlockCollections = allowBlockStyles;\n            if (state.lineIndent > parentIndent) {\n              indentStatus = 1;\n            } else if (state.lineIndent === parentIndent) {\n              indentStatus = 0;\n            } else if (state.lineIndent < parentIndent) {\n              indentStatus = -1;\n            }\n          } else {\n            allowBlockCollections = false;\n          }\n        }\n      }\n      if (allowBlockCollections) {\n        allowBlockCollections = atNewLine || allowCompact;\n      }\n      if (indentStatus === 1 || CONTEXT_BLOCK_OUT === nodeContext) {\n        if (CONTEXT_FLOW_IN === nodeContext || CONTEXT_FLOW_OUT === nodeContext) {\n          flowIndent = parentIndent;\n        } else {\n          flowIndent = parentIndent + 1;\n        }\n        blockIndent = state.position - state.lineStart;\n        if (indentStatus === 1) {\n          if (allowBlockCollections && (readBlockSequence(state, blockIndent) || readBlockMapping(state, blockIndent, flowIndent)) || readFlowCollection(state, flowIndent)) {\n            hasContent = true;\n          } else {\n            if (allowBlockScalars && readBlockScalar(state, flowIndent) || readSingleQuotedScalar(state, flowIndent) || readDoubleQuotedScalar(state, flowIndent)) {\n              hasContent = true;\n            } else if (readAlias(state)) {\n              hasContent = true;\n              if (state.tag !== null || state.anchor !== null) {\n                throwError(state, "alias node should not have any properties");\n              }\n            } else if (readPlainScalar(state, flowIndent, CONTEXT_FLOW_IN === nodeContext)) {\n              hasContent = true;\n              if (state.tag === null) {\n                state.tag = "?";\n              }\n            }\n            if (state.anchor !== null) {\n              state.anchorMap[state.anchor] = state.result;\n            }\n          }\n        } else if (indentStatus === 0) {\n          hasContent = allowBlockCollections && readBlockSequence(state, blockIndent);\n        }\n      }\n      if (state.tag !== null && state.tag !== "!") {\n        if (state.tag === "?") {\n          if (state.result !== null && state.kind !== "scalar") {\n            throwError(state, \'unacceptable node kind for !<?> tag; it should be "scalar", not "\' + state.kind + \'"\');\n          }\n          for (typeIndex = 0, typeQuantity = state.implicitTypes.length; typeIndex < typeQuantity; typeIndex += 1) {\n            type2 = state.implicitTypes[typeIndex];\n            if (type2.resolve(state.result)) {\n              state.result = type2.construct(state.result);\n              state.tag = type2.tag;\n              if (state.anchor !== null) {\n                state.anchorMap[state.anchor] = state.result;\n              }\n              break;\n            }\n          }\n        } else if (_hasOwnProperty.call(state.typeMap[state.kind || "fallback"], state.tag)) {\n          type2 = state.typeMap[state.kind || "fallback"][state.tag];\n          if (state.result !== null && type2.kind !== state.kind) {\n            throwError(state, "unacceptable node kind for !<" + state.tag + \'> tag; it should be "\' + type2.kind + \'", not "\' + state.kind + \'"\');\n          }\n          if (!type2.resolve(state.result)) {\n            throwError(state, "cannot resolve a node with !<" + state.tag + "> explicit tag");\n          } else {\n            state.result = type2.construct(state.result);\n            if (state.anchor !== null) {\n              state.anchorMap[state.anchor] = state.result;\n            }\n          }\n        } else {\n          throwError(state, "unknown tag !<" + state.tag + ">");\n        }\n      }\n      if (state.listener !== null) {\n        state.listener("close", state);\n      }\n      return state.tag !== null || state.anchor !== null || hasContent;\n    }\n    function readDocument(state) {\n      var documentStart = state.position, _position, directiveName, directiveArgs, hasDirectives = false, ch;\n      state.version = null;\n      state.checkLineBreaks = state.legacy;\n      state.tagMap = {};\n      state.anchorMap = {};\n      while ((ch = state.input.charCodeAt(state.position)) !== 0) {\n        skipSeparationSpace(state, true, -1);\n        ch = state.input.charCodeAt(state.position);\n        if (state.lineIndent > 0 || ch !== 37) {\n          break;\n        }\n        hasDirectives = true;\n        ch = state.input.charCodeAt(++state.position);\n        _position = state.position;\n        while (ch !== 0 && !is_WS_OR_EOL(ch)) {\n          ch = state.input.charCodeAt(++state.position);\n        }\n        directiveName = state.input.slice(_position, state.position);\n        directiveArgs = [];\n        if (directiveName.length < 1) {\n          throwError(state, "directive name must not be less than one character in length");\n        }\n        while (ch !== 0) {\n          while (is_WHITE_SPACE(ch)) {\n            ch = state.input.charCodeAt(++state.position);\n          }\n          if (ch === 35) {\n            do {\n              ch = state.input.charCodeAt(++state.position);\n            } while (ch !== 0 && !is_EOL(ch));\n            break;\n          }\n          if (is_EOL(ch)) break;\n          _position = state.position;\n          while (ch !== 0 && !is_WS_OR_EOL(ch)) {\n            ch = state.input.charCodeAt(++state.position);\n          }\n          directiveArgs.push(state.input.slice(_position, state.position));\n        }\n        if (ch !== 0) readLineBreak(state);\n        if (_hasOwnProperty.call(directiveHandlers, directiveName)) {\n          directiveHandlers[directiveName](state, directiveName, directiveArgs);\n        } else {\n          throwWarning(state, \'unknown document directive "\' + directiveName + \'"\');\n        }\n      }\n      skipSeparationSpace(state, true, -1);\n      if (state.lineIndent === 0 && state.input.charCodeAt(state.position) === 45 && state.input.charCodeAt(state.position + 1) === 45 && state.input.charCodeAt(state.position + 2) === 45) {\n        state.position += 3;\n        skipSeparationSpace(state, true, -1);\n      } else if (hasDirectives) {\n        throwError(state, "directives end mark is expected");\n      }\n      composeNode(state, state.lineIndent - 1, CONTEXT_BLOCK_OUT, false, true);\n      skipSeparationSpace(state, true, -1);\n      if (state.checkLineBreaks && PATTERN_NON_ASCII_LINE_BREAKS.test(state.input.slice(documentStart, state.position))) {\n        throwWarning(state, "non-ASCII line breaks are interpreted as content");\n      }\n      state.documents.push(state.result);\n      if (state.position === state.lineStart && testDocumentSeparator(state)) {\n        if (state.input.charCodeAt(state.position) === 46) {\n          state.position += 3;\n          skipSeparationSpace(state, true, -1);\n        }\n        return;\n      }\n      if (state.position < state.length - 1) {\n        throwError(state, "end of the stream or a document separator is expected");\n      } else {\n        return;\n      }\n    }\n    function loadDocuments(input, options2) {\n      input = String(input);\n      options2 = options2 || {};\n      if (input.length !== 0) {\n        if (input.charCodeAt(input.length - 1) !== 10 && input.charCodeAt(input.length - 1) !== 13) {\n          input += "\\n";\n        }\n        if (input.charCodeAt(0) === 65279) {\n          input = input.slice(1);\n        }\n      }\n      var state = new State(input, options2);\n      var nullpos = input.indexOf("\\0");\n      if (nullpos !== -1) {\n        state.position = nullpos;\n        throwError(state, "null byte is not allowed in input");\n      }\n      state.input += "\\0";\n      while (state.input.charCodeAt(state.position) === 32) {\n        state.lineIndent += 1;\n        state.position += 1;\n      }\n      while (state.position < state.length - 1) {\n        readDocument(state);\n      }\n      return state.documents;\n    }\n    function loadAll(input, iterator2, options2) {\n      if (iterator2 !== null && typeof iterator2 === "object" && typeof options2 === "undefined") {\n        options2 = iterator2;\n        iterator2 = null;\n      }\n      var documents = loadDocuments(input, options2);\n      if (typeof iterator2 !== "function") {\n        return documents;\n      }\n      for (var index2 = 0, length = documents.length; index2 < length; index2 += 1) {\n        iterator2(documents[index2]);\n      }\n    }\n    function load(input, options2) {\n      var documents = loadDocuments(input, options2);\n      if (documents.length === 0) {\n        return void 0;\n      } else if (documents.length === 1) {\n        return documents[0];\n      }\n      throw new YAMLException("expected a single document in the stream, but found more");\n    }\n    function safeLoadAll(input, iterator2, options2) {\n      if (typeof iterator2 === "object" && iterator2 !== null && typeof options2 === "undefined") {\n        options2 = iterator2;\n        iterator2 = null;\n      }\n      return loadAll(input, iterator2, common2.extend({ schema: DEFAULT_SAFE_SCHEMA }, options2));\n    }\n    function safeLoad(input, options2) {\n      return load(input, common2.extend({ schema: DEFAULT_SAFE_SCHEMA }, options2));\n    }\n    loader.loadAll = loadAll;\n    loader.load = load;\n    loader.safeLoadAll = safeLoadAll;\n    loader.safeLoad = safeLoad;\n    return loader;\n  }\n  var dumper = {};\n  var hasRequiredDumper;\n  function requireDumper() {\n    if (hasRequiredDumper) return dumper;\n    hasRequiredDumper = 1;\n    var common2 = requireCommon();\n    var YAMLException = requireException();\n    var DEFAULT_FULL_SCHEMA = requireDefault_full();\n    var DEFAULT_SAFE_SCHEMA = requireDefault_safe();\n    var _toString = Object.prototype.toString;\n    var _hasOwnProperty = Object.prototype.hasOwnProperty;\n    var CHAR_TAB = 9;\n    var CHAR_LINE_FEED = 10;\n    var CHAR_CARRIAGE_RETURN = 13;\n    var CHAR_SPACE = 32;\n    var CHAR_EXCLAMATION = 33;\n    var CHAR_DOUBLE_QUOTE = 34;\n    var CHAR_SHARP = 35;\n    var CHAR_PERCENT = 37;\n    var CHAR_AMPERSAND = 38;\n    var CHAR_SINGLE_QUOTE = 39;\n    var CHAR_ASTERISK = 42;\n    var CHAR_COMMA = 44;\n    var CHAR_MINUS = 45;\n    var CHAR_COLON = 58;\n    var CHAR_EQUALS = 61;\n    var CHAR_GREATER_THAN = 62;\n    var CHAR_QUESTION = 63;\n    var CHAR_COMMERCIAL_AT = 64;\n    var CHAR_LEFT_SQUARE_BRACKET = 91;\n    var CHAR_RIGHT_SQUARE_BRACKET = 93;\n    var CHAR_GRAVE_ACCENT = 96;\n    var CHAR_LEFT_CURLY_BRACKET = 123;\n    var CHAR_VERTICAL_LINE = 124;\n    var CHAR_RIGHT_CURLY_BRACKET = 125;\n    var ESCAPE_SEQUENCES = {};\n    ESCAPE_SEQUENCES[0] = "\\\\0";\n    ESCAPE_SEQUENCES[7] = "\\\\a";\n    ESCAPE_SEQUENCES[8] = "\\\\b";\n    ESCAPE_SEQUENCES[9] = "\\\\t";\n    ESCAPE_SEQUENCES[10] = "\\\\n";\n    ESCAPE_SEQUENCES[11] = "\\\\v";\n    ESCAPE_SEQUENCES[12] = "\\\\f";\n    ESCAPE_SEQUENCES[13] = "\\\\r";\n    ESCAPE_SEQUENCES[27] = "\\\\e";\n    ESCAPE_SEQUENCES[34] = \'\\\\"\';\n    ESCAPE_SEQUENCES[92] = "\\\\\\\\";\n    ESCAPE_SEQUENCES[133] = "\\\\N";\n    ESCAPE_SEQUENCES[160] = "\\\\_";\n    ESCAPE_SEQUENCES[8232] = "\\\\L";\n    ESCAPE_SEQUENCES[8233] = "\\\\P";\n    var DEPRECATED_BOOLEANS_SYNTAX = [\n      "y",\n      "Y",\n      "yes",\n      "Yes",\n      "YES",\n      "on",\n      "On",\n      "ON",\n      "n",\n      "N",\n      "no",\n      "No",\n      "NO",\n      "off",\n      "Off",\n      "OFF"\n    ];\n    function compileStyleMap(schema2, map2) {\n      var result, keys, index2, length, tag, style, type2;\n      if (map2 === null) return {};\n      result = {};\n      keys = Object.keys(map2);\n      for (index2 = 0, length = keys.length; index2 < length; index2 += 1) {\n        tag = keys[index2];\n        style = String(map2[tag]);\n        if (tag.slice(0, 2) === "!!") {\n          tag = "tag:yaml.org,2002:" + tag.slice(2);\n        }\n        type2 = schema2.compiledTypeMap["fallback"][tag];\n        if (type2 && _hasOwnProperty.call(type2.styleAliases, style)) {\n          style = type2.styleAliases[style];\n        }\n        result[tag] = style;\n      }\n      return result;\n    }\n    function encodeHex(character) {\n      var string2, handle, length;\n      string2 = character.toString(16).toUpperCase();\n      if (character <= 255) {\n        handle = "x";\n        length = 2;\n      } else if (character <= 65535) {\n        handle = "u";\n        length = 4;\n      } else if (character <= 4294967295) {\n        handle = "U";\n        length = 8;\n      } else {\n        throw new YAMLException("code point within a string may not be greater than 0xFFFFFFFF");\n      }\n      return "\\\\" + handle + common2.repeat("0", length - string2.length) + string2;\n    }\n    function State(options2) {\n      this.schema = options2["schema"] || DEFAULT_FULL_SCHEMA;\n      this.indent = Math.max(1, options2["indent"] || 2);\n      this.noArrayIndent = options2["noArrayIndent"] || false;\n      this.skipInvalid = options2["skipInvalid"] || false;\n      this.flowLevel = common2.isNothing(options2["flowLevel"]) ? -1 : options2["flowLevel"];\n      this.styleMap = compileStyleMap(this.schema, options2["styles"] || null);\n      this.sortKeys = options2["sortKeys"] || false;\n      this.lineWidth = options2["lineWidth"] || 80;\n      this.noRefs = options2["noRefs"] || false;\n      this.noCompatMode = options2["noCompatMode"] || false;\n      this.condenseFlow = options2["condenseFlow"] || false;\n      this.implicitTypes = this.schema.compiledImplicit;\n      this.explicitTypes = this.schema.compiledExplicit;\n      this.tag = null;\n      this.result = "";\n      this.duplicates = [];\n      this.usedDuplicates = null;\n    }\n    function indentString(string2, spaces) {\n      var ind = common2.repeat(" ", spaces), position2 = 0, next = -1, result = "", line, length = string2.length;\n      while (position2 < length) {\n        next = string2.indexOf("\\n", position2);\n        if (next === -1) {\n          line = string2.slice(position2);\n          position2 = length;\n        } else {\n          line = string2.slice(position2, next + 1);\n          position2 = next + 1;\n        }\n        if (line.length && line !== "\\n") result += ind;\n        result += line;\n      }\n      return result;\n    }\n    function generateNextLine(state, level) {\n      return "\\n" + common2.repeat(" ", state.indent * level);\n    }\n    function testImplicitResolving(state, str2) {\n      var index2, length, type2;\n      for (index2 = 0, length = state.implicitTypes.length; index2 < length; index2 += 1) {\n        type2 = state.implicitTypes[index2];\n        if (type2.resolve(str2)) {\n          return true;\n        }\n      }\n      return false;\n    }\n    function isWhitespace(c) {\n      return c === CHAR_SPACE || c === CHAR_TAB;\n    }\n    function isPrintable(c) {\n      return 32 <= c && c <= 126 || 161 <= c && c <= 55295 && c !== 8232 && c !== 8233 || 57344 <= c && c <= 65533 && c !== 65279 || 65536 <= c && c <= 1114111;\n    }\n    function isNsChar(c) {\n      return isPrintable(c) && !isWhitespace(c) && c !== 65279 && c !== CHAR_CARRIAGE_RETURN && c !== CHAR_LINE_FEED;\n    }\n    function isPlainSafe(c, prev) {\n      return isPrintable(c) && c !== 65279 && c !== CHAR_COMMA && c !== CHAR_LEFT_SQUARE_BRACKET && c !== CHAR_RIGHT_SQUARE_BRACKET && c !== CHAR_LEFT_CURLY_BRACKET && c !== CHAR_RIGHT_CURLY_BRACKET && c !== CHAR_COLON && (c !== CHAR_SHARP || prev && isNsChar(prev));\n    }\n    function isPlainSafeFirst(c) {\n      return isPrintable(c) && c !== 65279 && !isWhitespace(c) && c !== CHAR_MINUS && c !== CHAR_QUESTION && c !== CHAR_COLON && c !== CHAR_COMMA && c !== CHAR_LEFT_SQUARE_BRACKET && c !== CHAR_RIGHT_SQUARE_BRACKET && c !== CHAR_LEFT_CURLY_BRACKET && c !== CHAR_RIGHT_CURLY_BRACKET && c !== CHAR_SHARP && c !== CHAR_AMPERSAND && c !== CHAR_ASTERISK && c !== CHAR_EXCLAMATION && c !== CHAR_VERTICAL_LINE && c !== CHAR_EQUALS && c !== CHAR_GREATER_THAN && c !== CHAR_SINGLE_QUOTE && c !== CHAR_DOUBLE_QUOTE && c !== CHAR_PERCENT && c !== CHAR_COMMERCIAL_AT && c !== CHAR_GRAVE_ACCENT;\n    }\n    function needIndentIndicator(string2) {\n      var leadingSpaceRe = /^\\n* /;\n      return leadingSpaceRe.test(string2);\n    }\n    var STYLE_PLAIN = 1, STYLE_SINGLE = 2, STYLE_LITERAL = 3, STYLE_FOLDED = 4, STYLE_DOUBLE = 5;\n    function chooseScalarStyle(string2, singleLineOnly, indentPerLevel, lineWidth, testAmbiguousType) {\n      var i;\n      var char, prev_char;\n      var hasLineBreak = false;\n      var hasFoldableLine = false;\n      var shouldTrackWidth = lineWidth !== -1;\n      var previousLineBreak = -1;\n      var plain = isPlainSafeFirst(string2.charCodeAt(0)) && !isWhitespace(string2.charCodeAt(string2.length - 1));\n      if (singleLineOnly) {\n        for (i = 0; i < string2.length; i++) {\n          char = string2.charCodeAt(i);\n          if (!isPrintable(char)) {\n            return STYLE_DOUBLE;\n          }\n          prev_char = i > 0 ? string2.charCodeAt(i - 1) : null;\n          plain = plain && isPlainSafe(char, prev_char);\n        }\n      } else {\n        for (i = 0; i < string2.length; i++) {\n          char = string2.charCodeAt(i);\n          if (char === CHAR_LINE_FEED) {\n            hasLineBreak = true;\n            if (shouldTrackWidth) {\n              hasFoldableLine = hasFoldableLine || // Foldable line = too long, and not more-indented.\n              i - previousLineBreak - 1 > lineWidth && string2[previousLineBreak + 1] !== " ";\n              previousLineBreak = i;\n            }\n          } else if (!isPrintable(char)) {\n            return STYLE_DOUBLE;\n          }\n          prev_char = i > 0 ? string2.charCodeAt(i - 1) : null;\n          plain = plain && isPlainSafe(char, prev_char);\n        }\n        hasFoldableLine = hasFoldableLine || shouldTrackWidth && (i - previousLineBreak - 1 > lineWidth && string2[previousLineBreak + 1] !== " ");\n      }\n      if (!hasLineBreak && !hasFoldableLine) {\n        return plain && !testAmbiguousType(string2) ? STYLE_PLAIN : STYLE_SINGLE;\n      }\n      if (indentPerLevel > 9 && needIndentIndicator(string2)) {\n        return STYLE_DOUBLE;\n      }\n      return hasFoldableLine ? STYLE_FOLDED : STYLE_LITERAL;\n    }\n    function writeScalar(state, string2, level, iskey) {\n      state.dump = (function() {\n        if (string2.length === 0) {\n          return "\'\'";\n        }\n        if (!state.noCompatMode && DEPRECATED_BOOLEANS_SYNTAX.indexOf(string2) !== -1) {\n          return "\'" + string2 + "\'";\n        }\n        var indent = state.indent * Math.max(1, level);\n        var lineWidth = state.lineWidth === -1 ? -1 : Math.max(Math.min(state.lineWidth, 40), state.lineWidth - indent);\n        var singleLineOnly = iskey || state.flowLevel > -1 && level >= state.flowLevel;\n        function testAmbiguity(string3) {\n          return testImplicitResolving(state, string3);\n        }\n        switch (chooseScalarStyle(string2, singleLineOnly, state.indent, lineWidth, testAmbiguity)) {\n          case STYLE_PLAIN:\n            return string2;\n          case STYLE_SINGLE:\n            return "\'" + string2.replace(/\'/g, "\'\'") + "\'";\n          case STYLE_LITERAL:\n            return "|" + blockHeader(string2, state.indent) + dropEndingNewline(indentString(string2, indent));\n          case STYLE_FOLDED:\n            return ">" + blockHeader(string2, state.indent) + dropEndingNewline(indentString(foldString(string2, lineWidth), indent));\n          case STYLE_DOUBLE:\n            return \'"\' + escapeString(string2) + \'"\';\n          default:\n            throw new YAMLException("impossible error: invalid scalar style");\n        }\n      })();\n    }\n    function blockHeader(string2, indentPerLevel) {\n      var indentIndicator = needIndentIndicator(string2) ? String(indentPerLevel) : "";\n      var clip = string2[string2.length - 1] === "\\n";\n      var keep = clip && (string2[string2.length - 2] === "\\n" || string2 === "\\n");\n      var chomp = keep ? "+" : clip ? "" : "-";\n      return indentIndicator + chomp + "\\n";\n    }\n    function dropEndingNewline(string2) {\n      return string2[string2.length - 1] === "\\n" ? string2.slice(0, -1) : string2;\n    }\n    function foldString(string2, width) {\n      var lineRe = /(\\n+)([^\\n]*)/g;\n      var result = (function() {\n        var nextLF = string2.indexOf("\\n");\n        nextLF = nextLF !== -1 ? nextLF : string2.length;\n        lineRe.lastIndex = nextLF;\n        return foldLine(string2.slice(0, nextLF), width);\n      })();\n      var prevMoreIndented = string2[0] === "\\n" || string2[0] === " ";\n      var moreIndented;\n      var match;\n      while (match = lineRe.exec(string2)) {\n        var prefix = match[1], line = match[2];\n        moreIndented = line[0] === " ";\n        result += prefix + (!prevMoreIndented && !moreIndented && line !== "" ? "\\n" : "") + foldLine(line, width);\n        prevMoreIndented = moreIndented;\n      }\n      return result;\n    }\n    function foldLine(line, width) {\n      if (line === "" || line[0] === " ") return line;\n      var breakRe = / [^ ]/g;\n      var match;\n      var start = 0, end, curr = 0, next = 0;\n      var result = "";\n      while (match = breakRe.exec(line)) {\n        next = match.index;\n        if (next - start > width) {\n          end = curr > start ? curr : next;\n          result += "\\n" + line.slice(start, end);\n          start = end + 1;\n        }\n        curr = next;\n      }\n      result += "\\n";\n      if (line.length - start > width && curr > start) {\n        result += line.slice(start, curr) + "\\n" + line.slice(curr + 1);\n      } else {\n        result += line.slice(start);\n      }\n      return result.slice(1);\n    }\n    function escapeString(string2) {\n      var result = "";\n      var char, nextChar;\n      var escapeSeq;\n      for (var i = 0; i < string2.length; i++) {\n        char = string2.charCodeAt(i);\n        if (char >= 55296 && char <= 56319) {\n          nextChar = string2.charCodeAt(i + 1);\n          if (nextChar >= 56320 && nextChar <= 57343) {\n            result += encodeHex((char - 55296) * 1024 + nextChar - 56320 + 65536);\n            i++;\n            continue;\n          }\n        }\n        escapeSeq = ESCAPE_SEQUENCES[char];\n        result += !escapeSeq && isPrintable(char) ? string2[i] : escapeSeq || encodeHex(char);\n      }\n      return result;\n    }\n    function writeFlowSequence(state, level, object) {\n      var _result = "", _tag = state.tag, index2, length;\n      for (index2 = 0, length = object.length; index2 < length; index2 += 1) {\n        if (writeNode(state, level, object[index2], false, false)) {\n          if (index2 !== 0) _result += "," + (!state.condenseFlow ? " " : "");\n          _result += state.dump;\n        }\n      }\n      state.tag = _tag;\n      state.dump = "[" + _result + "]";\n    }\n    function writeBlockSequence(state, level, object, compact) {\n      var _result = "", _tag = state.tag, index2, length;\n      for (index2 = 0, length = object.length; index2 < length; index2 += 1) {\n        if (writeNode(state, level + 1, object[index2], true, true)) {\n          if (!compact || index2 !== 0) {\n            _result += generateNextLine(state, level);\n          }\n          if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {\n            _result += "-";\n          } else {\n            _result += "- ";\n          }\n          _result += state.dump;\n        }\n      }\n      state.tag = _tag;\n      state.dump = _result || "[]";\n    }\n    function writeFlowMapping(state, level, object) {\n      var _result = "", _tag = state.tag, objectKeyList = Object.keys(object), index2, length, objectKey, objectValue, pairBuffer;\n      for (index2 = 0, length = objectKeyList.length; index2 < length; index2 += 1) {\n        pairBuffer = "";\n        if (index2 !== 0) pairBuffer += ", ";\n        if (state.condenseFlow) pairBuffer += \'"\';\n        objectKey = objectKeyList[index2];\n        objectValue = object[objectKey];\n        if (!writeNode(state, level, objectKey, false, false)) {\n          continue;\n        }\n        if (state.dump.length > 1024) pairBuffer += "? ";\n        pairBuffer += state.dump + (state.condenseFlow ? \'"\' : "") + ":" + (state.condenseFlow ? "" : " ");\n        if (!writeNode(state, level, objectValue, false, false)) {\n          continue;\n        }\n        pairBuffer += state.dump;\n        _result += pairBuffer;\n      }\n      state.tag = _tag;\n      state.dump = "{" + _result + "}";\n    }\n    function writeBlockMapping(state, level, object, compact) {\n      var _result = "", _tag = state.tag, objectKeyList = Object.keys(object), index2, length, objectKey, objectValue, explicitPair, pairBuffer;\n      if (state.sortKeys === true) {\n        objectKeyList.sort();\n      } else if (typeof state.sortKeys === "function") {\n        objectKeyList.sort(state.sortKeys);\n      } else if (state.sortKeys) {\n        throw new YAMLException("sortKeys must be a boolean or a function");\n      }\n      for (index2 = 0, length = objectKeyList.length; index2 < length; index2 += 1) {\n        pairBuffer = "";\n        if (!compact || index2 !== 0) {\n          pairBuffer += generateNextLine(state, level);\n        }\n        objectKey = objectKeyList[index2];\n        objectValue = object[objectKey];\n        if (!writeNode(state, level + 1, objectKey, true, true, true)) {\n          continue;\n        }\n        explicitPair = state.tag !== null && state.tag !== "?" || state.dump && state.dump.length > 1024;\n        if (explicitPair) {\n          if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {\n            pairBuffer += "?";\n          } else {\n            pairBuffer += "? ";\n          }\n        }\n        pairBuffer += state.dump;\n        if (explicitPair) {\n          pairBuffer += generateNextLine(state, level);\n        }\n        if (!writeNode(state, level + 1, objectValue, true, explicitPair)) {\n          continue;\n        }\n        if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {\n          pairBuffer += ":";\n        } else {\n          pairBuffer += ": ";\n        }\n        pairBuffer += state.dump;\n        _result += pairBuffer;\n      }\n      state.tag = _tag;\n      state.dump = _result || "{}";\n    }\n    function detectType(state, object, explicit) {\n      var _result, typeList, index2, length, type2, style;\n      typeList = explicit ? state.explicitTypes : state.implicitTypes;\n      for (index2 = 0, length = typeList.length; index2 < length; index2 += 1) {\n        type2 = typeList[index2];\n        if ((type2.instanceOf || type2.predicate) && (!type2.instanceOf || typeof object === "object" && object instanceof type2.instanceOf) && (!type2.predicate || type2.predicate(object))) {\n          state.tag = explicit ? type2.tag : "?";\n          if (type2.represent) {\n            style = state.styleMap[type2.tag] || type2.defaultStyle;\n            if (_toString.call(type2.represent) === "[object Function]") {\n              _result = type2.represent(object, style);\n            } else if (_hasOwnProperty.call(type2.represent, style)) {\n              _result = type2.represent[style](object, style);\n            } else {\n              throw new YAMLException("!<" + type2.tag + \'> tag resolver accepts not "\' + style + \'" style\');\n            }\n            state.dump = _result;\n          }\n          return true;\n        }\n      }\n      return false;\n    }\n    function writeNode(state, level, object, block, compact, iskey) {\n      state.tag = null;\n      state.dump = object;\n      if (!detectType(state, object, false)) {\n        detectType(state, object, true);\n      }\n      var type2 = _toString.call(state.dump);\n      if (block) {\n        block = state.flowLevel < 0 || state.flowLevel > level;\n      }\n      var objectOrArray = type2 === "[object Object]" || type2 === "[object Array]", duplicateIndex, duplicate;\n      if (objectOrArray) {\n        duplicateIndex = state.duplicates.indexOf(object);\n        duplicate = duplicateIndex !== -1;\n      }\n      if (state.tag !== null && state.tag !== "?" || duplicate || state.indent !== 2 && level > 0) {\n        compact = false;\n      }\n      if (duplicate && state.usedDuplicates[duplicateIndex]) {\n        state.dump = "*ref_" + duplicateIndex;\n      } else {\n        if (objectOrArray && duplicate && !state.usedDuplicates[duplicateIndex]) {\n          state.usedDuplicates[duplicateIndex] = true;\n        }\n        if (type2 === "[object Object]") {\n          if (block && Object.keys(state.dump).length !== 0) {\n            writeBlockMapping(state, level, state.dump, compact);\n            if (duplicate) {\n              state.dump = "&ref_" + duplicateIndex + state.dump;\n            }\n          } else {\n            writeFlowMapping(state, level, state.dump);\n            if (duplicate) {\n              state.dump = "&ref_" + duplicateIndex + " " + state.dump;\n            }\n          }\n        } else if (type2 === "[object Array]") {\n          var arrayLevel = state.noArrayIndent && level > 0 ? level - 1 : level;\n          if (block && state.dump.length !== 0) {\n            writeBlockSequence(state, arrayLevel, state.dump, compact);\n            if (duplicate) {\n              state.dump = "&ref_" + duplicateIndex + state.dump;\n            }\n          } else {\n            writeFlowSequence(state, arrayLevel, state.dump);\n            if (duplicate) {\n              state.dump = "&ref_" + duplicateIndex + " " + state.dump;\n            }\n          }\n        } else if (type2 === "[object String]") {\n          if (state.tag !== "?") {\n            writeScalar(state, state.dump, level, iskey);\n          }\n        } else {\n          if (state.skipInvalid) return false;\n          throw new YAMLException("unacceptable kind of an object to dump " + type2);\n        }\n        if (state.tag !== null && state.tag !== "?") {\n          state.dump = "!<" + state.tag + "> " + state.dump;\n        }\n      }\n      return true;\n    }\n    function getDuplicateReferences(object, state) {\n      var objects = [], duplicatesIndexes = [], index2, length;\n      inspectNode(object, objects, duplicatesIndexes);\n      for (index2 = 0, length = duplicatesIndexes.length; index2 < length; index2 += 1) {\n        state.duplicates.push(objects[duplicatesIndexes[index2]]);\n      }\n      state.usedDuplicates = new Array(length);\n    }\n    function inspectNode(object, objects, duplicatesIndexes) {\n      var objectKeyList, index2, length;\n      if (object !== null && typeof object === "object") {\n        index2 = objects.indexOf(object);\n        if (index2 !== -1) {\n          if (duplicatesIndexes.indexOf(index2) === -1) {\n            duplicatesIndexes.push(index2);\n          }\n        } else {\n          objects.push(object);\n          if (Array.isArray(object)) {\n            for (index2 = 0, length = object.length; index2 < length; index2 += 1) {\n              inspectNode(object[index2], objects, duplicatesIndexes);\n            }\n          } else {\n            objectKeyList = Object.keys(object);\n            for (index2 = 0, length = objectKeyList.length; index2 < length; index2 += 1) {\n              inspectNode(object[objectKeyList[index2]], objects, duplicatesIndexes);\n            }\n          }\n        }\n      }\n    }\n    function dump(input, options2) {\n      options2 = options2 || {};\n      var state = new State(options2);\n      if (!state.noRefs) getDuplicateReferences(input, state);\n      if (writeNode(state, 0, input, true, true)) return state.dump + "\\n";\n      return "";\n    }\n    function safeDump(input, options2) {\n      return dump(input, common2.extend({ schema: DEFAULT_SAFE_SCHEMA }, options2));\n    }\n    dumper.dump = dump;\n    dumper.safeDump = safeDump;\n    return dumper;\n  }\n  var hasRequiredJsYaml$1;\n  function requireJsYaml$1() {\n    if (hasRequiredJsYaml$1) return jsYaml$1;\n    hasRequiredJsYaml$1 = 1;\n    var loader2 = requireLoader();\n    var dumper2 = requireDumper();\n    function deprecated(name) {\n      return function() {\n        throw new Error("Function " + name + " is deprecated and cannot be used.");\n      };\n    }\n    jsYaml$1.Type = requireType();\n    jsYaml$1.Schema = requireSchema();\n    jsYaml$1.FAILSAFE_SCHEMA = requireFailsafe();\n    jsYaml$1.JSON_SCHEMA = requireJson();\n    jsYaml$1.CORE_SCHEMA = requireCore();\n    jsYaml$1.DEFAULT_SAFE_SCHEMA = requireDefault_safe();\n    jsYaml$1.DEFAULT_FULL_SCHEMA = requireDefault_full();\n    jsYaml$1.load = loader2.load;\n    jsYaml$1.loadAll = loader2.loadAll;\n    jsYaml$1.safeLoad = loader2.safeLoad;\n    jsYaml$1.safeLoadAll = loader2.safeLoadAll;\n    jsYaml$1.dump = dumper2.dump;\n    jsYaml$1.safeDump = dumper2.safeDump;\n    jsYaml$1.YAMLException = requireException();\n    jsYaml$1.MINIMAL_SCHEMA = requireFailsafe();\n    jsYaml$1.SAFE_SCHEMA = requireDefault_safe();\n    jsYaml$1.DEFAULT_SCHEMA = requireDefault_full();\n    jsYaml$1.scan = deprecated("scan");\n    jsYaml$1.parse = deprecated("parse");\n    jsYaml$1.compose = deprecated("compose");\n    jsYaml$1.addConstructor = deprecated("addConstructor");\n    return jsYaml$1;\n  }\n  var jsYaml;\n  var hasRequiredJsYaml;\n  function requireJsYaml() {\n    if (hasRequiredJsYaml) return jsYaml;\n    hasRequiredJsYaml = 1;\n    var yaml2 = requireJsYaml$1();\n    jsYaml = yaml2;\n    return jsYaml;\n  }\n  var hasRequiredEngines;\n  function requireEngines() {\n    if (hasRequiredEngines) return engines.exports;\n    hasRequiredEngines = 1;\n    (function(module, exports$1) {\n      const yaml = requireJsYaml();\n      const engines = module.exports;\n      engines.yaml = {\n        parse: yaml.safeLoad.bind(yaml),\n        stringify: yaml.safeDump.bind(yaml)\n      };\n      engines.json = {\n        parse: JSON.parse.bind(JSON),\n        stringify: function(obj, options2) {\n          const opts = Object.assign({ replacer: null, space: 2 }, options2);\n          return JSON.stringify(obj, opts.replacer, opts.space);\n        }\n      };\n      engines.javascript = {\n        parse: function parse(str, options, wrap) {\n          try {\n            if (wrap !== false) {\n              str = "(function() {\\nreturn " + str.trim() + ";\\n}());";\n            }\n            return eval(str) || {};\n          } catch (err) {\n            if (wrap !== false && /(unexpected|identifier)/i.test(err.message)) {\n              return parse(str, options, false);\n            }\n            throw new SyntaxError(err);\n          }\n        },\n        stringify: function() {\n          throw new Error("stringifying JavaScript is not supported");\n        }\n      };\n    })(engines);\n    return engines.exports;\n  }\n  var utils = {};\n  var stripBomString;\n  var hasRequiredStripBomString;\n  function requireStripBomString() {\n    if (hasRequiredStripBomString) return stripBomString;\n    hasRequiredStripBomString = 1;\n    stripBomString = function(str2) {\n      if (typeof str2 === "string" && str2.charAt(0) === "\\uFEFF") {\n        return str2.slice(1);\n      }\n      return str2;\n    };\n    return stripBomString;\n  }\n  var hasRequiredUtils;\n  function requireUtils() {\n    if (hasRequiredUtils) return utils;\n    hasRequiredUtils = 1;\n    (function(exports$12) {\n      const stripBom = requireStripBomString();\n      const typeOf = requireKindOf();\n      exports$12.define = function(obj, key, val) {\n        Reflect.defineProperty(obj, key, {\n          enumerable: false,\n          configurable: true,\n          writable: true,\n          value: val\n        });\n      };\n      exports$12.isBuffer = function(val) {\n        return typeOf(val) === "buffer";\n      };\n      exports$12.isObject = function(val) {\n        return typeOf(val) === "object";\n      };\n      exports$12.toBuffer = function(input) {\n        return typeof input === "string" ? Buffer.from(input) : input;\n      };\n      exports$12.toString = function(input) {\n        if (exports$12.isBuffer(input)) return stripBom(String(input));\n        if (typeof input !== "string") {\n          throw new TypeError("expected input to be a string or buffer");\n        }\n        return stripBom(input);\n      };\n      exports$12.arrayify = function(val) {\n        return val ? Array.isArray(val) ? val : [val] : [];\n      };\n      exports$12.startsWith = function(str2, substr, len) {\n        if (typeof len !== "number") len = substr.length;\n        return str2.slice(0, len) === substr;\n      };\n    })(utils);\n    return utils;\n  }\n  var defaults;\n  var hasRequiredDefaults;\n  function requireDefaults() {\n    if (hasRequiredDefaults) return defaults;\n    hasRequiredDefaults = 1;\n    const engines2 = requireEngines();\n    const utils2 = requireUtils();\n    defaults = function(options2) {\n      const opts = Object.assign({}, options2);\n      opts.delimiters = utils2.arrayify(opts.delims || opts.delimiters || "---");\n      if (opts.delimiters.length === 1) {\n        opts.delimiters.push(opts.delimiters[0]);\n      }\n      opts.language = (opts.language || opts.lang || "yaml").toLowerCase();\n      opts.engines = Object.assign({}, engines2, opts.parsers, opts.engines);\n      return opts;\n    };\n    return defaults;\n  }\n  var engine;\n  var hasRequiredEngine;\n  function requireEngine() {\n    if (hasRequiredEngine) return engine;\n    hasRequiredEngine = 1;\n    engine = function(name, options2) {\n      let engine2 = options2.engines[name] || options2.engines[aliase(name)];\n      if (typeof engine2 === "undefined") {\n        throw new Error(\'gray-matter engine "\' + name + \'" is not registered\');\n      }\n      if (typeof engine2 === "function") {\n        engine2 = { parse: engine2 };\n      }\n      return engine2;\n    };\n    function aliase(name) {\n      switch (name.toLowerCase()) {\n        case "js":\n        case "javascript":\n          return "javascript";\n        case "coffee":\n        case "coffeescript":\n        case "cson":\n          return "coffee";\n        case "yaml":\n        case "yml":\n          return "yaml";\n        default: {\n          return name;\n        }\n      }\n    }\n    return engine;\n  }\n  var stringify;\n  var hasRequiredStringify;\n  function requireStringify() {\n    if (hasRequiredStringify) return stringify;\n    hasRequiredStringify = 1;\n    const typeOf = requireKindOf();\n    const getEngine = requireEngine();\n    const defaults2 = requireDefaults();\n    stringify = function(file, data, options2) {\n      if (data == null && options2 == null) {\n        switch (typeOf(file)) {\n          case "object":\n            data = file.data;\n            options2 = {};\n            break;\n          case "string":\n            return file;\n          default: {\n            throw new TypeError("expected file to be a string or object");\n          }\n        }\n      }\n      const str2 = file.content;\n      const opts = defaults2(options2);\n      if (data == null) {\n        if (!opts.data) return file;\n        data = opts.data;\n      }\n      const language = file.language || opts.language;\n      const engine2 = getEngine(language, opts);\n      if (typeof engine2.stringify !== "function") {\n        throw new TypeError(\'expected "\' + language + \'.stringify" to be a function\');\n      }\n      data = Object.assign({}, file.data, data);\n      const open = opts.delimiters[0];\n      const close = opts.delimiters[1];\n      const matter = engine2.stringify(data, options2).trim();\n      let buf = "";\n      if (matter !== "{}") {\n        buf = newline(open) + newline(matter) + newline(close);\n      }\n      if (typeof file.excerpt === "string" && file.excerpt !== "") {\n        if (str2.indexOf(file.excerpt.trim()) === -1) {\n          buf += newline(file.excerpt) + newline(close);\n        }\n      }\n      return buf + newline(str2);\n    };\n    function newline(str2) {\n      return str2.slice(-1) !== "\\n" ? str2 + "\\n" : str2;\n    }\n    return stringify;\n  }\n  var excerpt;\n  var hasRequiredExcerpt;\n  function requireExcerpt() {\n    if (hasRequiredExcerpt) return excerpt;\n    hasRequiredExcerpt = 1;\n    const defaults2 = requireDefaults();\n    excerpt = function(file, options2) {\n      const opts = defaults2(options2);\n      if (file.data == null) {\n        file.data = {};\n      }\n      if (typeof opts.excerpt === "function") {\n        return opts.excerpt(file, opts);\n      }\n      const sep = file.data.excerpt_separator || opts.excerpt_separator;\n      if (sep == null && (opts.excerpt === false || opts.excerpt == null)) {\n        return file;\n      }\n      const delimiter = typeof opts.excerpt === "string" ? opts.excerpt : sep || opts.delimiters[0];\n      const idx = file.content.indexOf(delimiter);\n      if (idx !== -1) {\n        file.excerpt = file.content.slice(0, idx);\n      }\n      return file;\n    };\n    return excerpt;\n  }\n  var toFile;\n  var hasRequiredToFile;\n  function requireToFile() {\n    if (hasRequiredToFile) return toFile;\n    hasRequiredToFile = 1;\n    const typeOf = requireKindOf();\n    const stringify2 = requireStringify();\n    const utils2 = requireUtils();\n    toFile = function(file) {\n      if (typeOf(file) !== "object") {\n        file = { content: file };\n      }\n      if (typeOf(file.data) !== "object") {\n        file.data = {};\n      }\n      if (file.contents && file.content == null) {\n        file.content = file.contents;\n      }\n      utils2.define(file, "orig", utils2.toBuffer(file.content));\n      utils2.define(file, "language", file.language || "");\n      utils2.define(file, "matter", file.matter || "");\n      utils2.define(file, "stringify", function(data, options2) {\n        if (options2 && options2.language) {\n          file.language = options2.language;\n        }\n        return stringify2(file, data, options2);\n      });\n      file.content = utils2.toString(file.content);\n      file.isEmpty = false;\n      file.excerpt = "";\n      return file;\n    };\n    return toFile;\n  }\n  var parse;\n  var hasRequiredParse;\n  function requireParse() {\n    if (hasRequiredParse) return parse;\n    hasRequiredParse = 1;\n    const getEngine = requireEngine();\n    const defaults2 = requireDefaults();\n    parse = function(language, str2, options2) {\n      const opts = defaults2(options2);\n      const engine2 = getEngine(language, opts);\n      if (typeof engine2.parse !== "function") {\n        throw new TypeError(\'expected "\' + language + \'.parse" to be a function\');\n      }\n      return engine2.parse(str2, opts);\n    };\n    return parse;\n  }\n  var grayMatter$1;\n  var hasRequiredGrayMatter;\n  function requireGrayMatter() {\n    if (hasRequiredGrayMatter) return grayMatter$1;\n    hasRequiredGrayMatter = 1;\n    const fs = require$$0;\n    const sections = requireSectionMatter();\n    const defaults2 = requireDefaults();\n    const stringify2 = requireStringify();\n    const excerpt2 = requireExcerpt();\n    const engines2 = requireEngines();\n    const toFile2 = requireToFile();\n    const parse2 = requireParse();\n    const utils2 = requireUtils();\n    function matter(input, options2) {\n      if (input === "") {\n        return { data: {}, content: input, excerpt: "", orig: input };\n      }\n      let file = toFile2(input);\n      const cached = matter.cache[file.content];\n      if (!options2) {\n        if (cached) {\n          file = Object.assign({}, cached);\n          file.orig = cached.orig;\n          return file;\n        }\n        matter.cache[file.content] = file;\n      }\n      return parseMatter(file, options2);\n    }\n    function parseMatter(file, options2) {\n      const opts = defaults2(options2);\n      const open = opts.delimiters[0];\n      const close = "\\n" + opts.delimiters[1];\n      let str2 = file.content;\n      if (opts.language) {\n        file.language = opts.language;\n      }\n      const openLen = open.length;\n      if (!utils2.startsWith(str2, open, openLen)) {\n        excerpt2(file, opts);\n        return file;\n      }\n      if (str2.charAt(openLen) === open.slice(-1)) {\n        return file;\n      }\n      str2 = str2.slice(openLen);\n      const len = str2.length;\n      const language = matter.language(str2, opts);\n      if (language.name) {\n        file.language = language.name;\n        str2 = str2.slice(language.raw.length);\n      }\n      let closeIndex = str2.indexOf(close);\n      if (closeIndex === -1) {\n        closeIndex = len;\n      }\n      file.matter = str2.slice(0, closeIndex);\n      const block = file.matter.replace(/^\\s*#[^\\n]+/gm, "").trim();\n      if (block === "") {\n        file.isEmpty = true;\n        file.empty = file.content;\n        file.data = {};\n      } else {\n        file.data = parse2(file.language, file.matter, opts);\n      }\n      if (closeIndex === len) {\n        file.content = "";\n      } else {\n        file.content = str2.slice(closeIndex + close.length);\n        if (file.content[0] === "\\r") {\n          file.content = file.content.slice(1);\n        }\n        if (file.content[0] === "\\n") {\n          file.content = file.content.slice(1);\n        }\n      }\n      excerpt2(file, opts);\n      if (opts.sections === true || typeof opts.section === "function") {\n        sections(file, opts.section);\n      }\n      return file;\n    }\n    matter.engines = engines2;\n    matter.stringify = function(file, data, options2) {\n      if (typeof file === "string") file = matter(file, options2);\n      return stringify2(file, data, options2);\n    };\n    matter.read = function(filepath, options2) {\n      const str2 = fs.readFileSync(filepath, "utf8");\n      const file = matter(str2, options2);\n      file.path = filepath;\n      return file;\n    };\n    matter.test = function(str2, options2) {\n      return utils2.startsWith(str2, defaults2(options2).delimiters[0]);\n    };\n    matter.language = function(str2, options2) {\n      const opts = defaults2(options2);\n      const open = opts.delimiters[0];\n      if (matter.test(str2)) {\n        str2 = str2.slice(open.length);\n      }\n      const language = str2.slice(0, str2.search(/\\r?\\n/));\n      return {\n        raw: language,\n        name: language ? language.trim() : ""\n      };\n    };\n    matter.cache = {};\n    matter.clearCache = function() {\n      matter.cache = {};\n    };\n    grayMatter$1 = matter;\n    return grayMatter$1;\n  }\n  var grayMatterExports = requireGrayMatter();\n  var grayMatter = /* @__PURE__ */ getDefaultExportFromCjs(grayMatterExports);\n  function messagePlugin(message) {\n    self.postMessage(message);\n  }\n  let taskDatabase;\n  let heldMessage = null;\n  self.onmessage = async (event) => {\n    let message;\n    if (typeof event.data === "string") {\n      if (!heldMessage) {\n        Logger.error(`Received unexpected supplemental message: ${event.data}`);\n        return;\n      }\n      heldMessage.content = event.data;\n      message = heldMessage;\n    } else {\n      message = event.data;\n    }\n    switch (message.type) {\n      case "health-check":\n        taskDatabase = new TaskDatabase(message.appId);\n        messagePlugin({\n          type: "health-check",\n          id: message.id,\n          result: true\n        });\n        break;\n      case "parse-markdown":\n        if (message.content == null) {\n          heldMessage = message;\n        } else {\n          await handleParseMarkdown(message);\n        }\n        break;\n    }\n  };\n  async function handleParseMarkdown(message) {\n    if (message.type !== "parse-markdown" || message.content == null) {\n      Logger.error("Invalid message type for handleParseMarkdown");\n      return;\n    }\n    const contentWithFrontmatter = grayMatter(message.content);\n    const tasks = parseTasks(message.path, contentWithFrontmatter.content);\n    Logger.debug(`Converted ${tasks.length} tasks from ${message.path}`, tasks);\n    try {\n      await taskDatabase.clearTasksByPath(message.path);\n      await taskDatabase.addTasks(tasks);\n      Logger.log(`Stored ${tasks.length} tasks in IndexedDB`);\n    } catch (error) {\n      Logger.error(`Failed to store tasks to database: ${error}`);\n    }\n    messagePlugin({\n      type: "parse-markdown",\n      id: message.id,\n      success: true\n    });\n  }\n})();\n//# sourceMappingURL=Worker.worker-CdeRMheS.js.map\n';
const blob = typeof self !== "undefined" && self.Blob && new Blob(["(self.URL || self.webkitURL).revokeObjectURL(self.location.href);", jsContent], { type: "text/javascript;charset=utf-8" });
function WorkerWrapper(options) {
  let objURL;
  try {
    objURL = blob && (self.URL || self.webkitURL).createObjectURL(blob);
    if (!objURL) throw "";
    const worker = new Worker(objURL, {
      name: options?.name
    });
    worker.addEventListener("error", () => {
      (self.URL || self.webkitURL).revokeObjectURL(objURL);
    });
    return worker;
  } catch (e2) {
    return new Worker(
      "data:text/javascript;charset=utf-8," + encodeURIComponent(jsContent),
      {
        name: options?.name
      }
    );
  }
}
class WorkerManager {
  worker;
  nextId = 0;
  pendingRequests = /* @__PURE__ */ new Map();
  constructor() {
    this.worker = new WorkerWrapper();
    this.worker.onmessage = (event) => {
      this.handleMessage(event.data);
    };
  }
  handleMessage(message) {
    const callback = this.pendingRequests.get(message.id);
    if (callback) {
      this.pendingRequests.delete(message.id);
      callback(message);
      return;
    }
  }
  nextRequestId() {
    return this.nextId++;
  }
  messageWorker(message) {
    this.worker.postMessage(message);
  }
  /**
   * Perform RPC call to worker
   * @param method RPC method name
   * @param params Parameterscallback Callback to invoke when response is received
   * @param params Parameters for the RPC call
   */
  RPC(method, params, supplemental) {
    return new Promise((resolve, reject) => {
      const id = this.nextRequestId();
      this.pendingRequests.set(id, resolve);
      switch (method) {
        case "health-check": {
          const p2 = params;
          this.messageWorker({
            type: "health-check",
            id,
            appId: p2.appId
          });
          break;
        }
        case "parse-markdown": {
          const p2 = params;
          this.messageWorker({
            type: "parse-markdown",
            id,
            path: p2.path,
            content: p2.content,
            timestamp: p2.timestamp
          });
          break;
        }
        default:
          this.pendingRequests.delete(id);
          reject(new Error(`Unknown RPC method: ${method}`));
      }
      if (supplemental) {
        this.worker.postMessage(supplemental);
      }
    });
  }
}
const anyMap = /* @__PURE__ */ new WeakMap();
const eventsMap = /* @__PURE__ */ new WeakMap();
const producersMap = /* @__PURE__ */ new WeakMap();
const anyProducer = /* @__PURE__ */ Symbol("anyProducer");
const resolvedPromise = Promise.resolve();
const listenerAdded = /* @__PURE__ */ Symbol("listenerAdded");
const listenerRemoved = /* @__PURE__ */ Symbol("listenerRemoved");
let canEmitMetaEvents = false;
let isGlobalDebugEnabled = false;
const isEventKeyType = (key) => typeof key === "string" || typeof key === "symbol" || typeof key === "number";
function assertEventName(eventName) {
  if (!isEventKeyType(eventName)) {
    throw new TypeError("`eventName` must be a string, symbol, or number");
  }
}
function assertListener(listener) {
  if (typeof listener !== "function") {
    throw new TypeError("listener must be a function");
  }
}
function getListeners(instance, eventName) {
  const events = eventsMap.get(instance);
  if (!events.has(eventName)) {
    return;
  }
  return events.get(eventName);
}
function getEventProducers(instance, eventName) {
  const key = isEventKeyType(eventName) ? eventName : anyProducer;
  const producers = producersMap.get(instance);
  if (!producers.has(key)) {
    return;
  }
  return producers.get(key);
}
function enqueueProducers(instance, eventName, eventData) {
  const producers = producersMap.get(instance);
  if (producers.has(eventName)) {
    for (const producer of producers.get(eventName)) {
      producer.enqueue(eventData);
    }
  }
  if (producers.has(anyProducer)) {
    const item = Promise.all([eventName, eventData]);
    for (const producer of producers.get(anyProducer)) {
      producer.enqueue(item);
    }
  }
}
function iterator(instance, eventNames) {
  eventNames = Array.isArray(eventNames) ? eventNames : [eventNames];
  let isFinished = false;
  let flush = () => {
  };
  let queue = [];
  const producer = {
    enqueue(item) {
      queue.push(item);
      flush();
    },
    finish() {
      isFinished = true;
      flush();
    }
  };
  for (const eventName of eventNames) {
    let set = getEventProducers(instance, eventName);
    if (!set) {
      set = /* @__PURE__ */ new Set();
      const producers = producersMap.get(instance);
      producers.set(eventName, set);
    }
    set.add(producer);
  }
  return {
    async next() {
      if (!queue) {
        return { done: true };
      }
      if (queue.length === 0) {
        if (isFinished) {
          queue = void 0;
          return this.next();
        }
        await new Promise((resolve) => {
          flush = resolve;
        });
        return this.next();
      }
      return {
        done: false,
        value: await queue.shift()
      };
    },
    async return(value) {
      queue = void 0;
      for (const eventName of eventNames) {
        const set = getEventProducers(instance, eventName);
        if (set) {
          set.delete(producer);
          if (set.size === 0) {
            const producers = producersMap.get(instance);
            producers.delete(eventName);
          }
        }
      }
      flush();
      return arguments.length > 0 ? { done: true, value: await value } : { done: true };
    },
    [Symbol.asyncIterator]() {
      return this;
    }
  };
}
function defaultMethodNamesOrAssert(methodNames) {
  if (methodNames === void 0) {
    return allEmitteryMethods;
  }
  if (!Array.isArray(methodNames)) {
    throw new TypeError("`methodNames` must be an array of strings");
  }
  for (const methodName of methodNames) {
    if (!allEmitteryMethods.includes(methodName)) {
      if (typeof methodName !== "string") {
        throw new TypeError("`methodNames` element must be a string");
      }
      throw new Error(`${methodName} is not Emittery method`);
    }
  }
  return methodNames;
}
const isMetaEvent = (eventName) => eventName === listenerAdded || eventName === listenerRemoved;
function emitMetaEvent(emitter, eventName, eventData) {
  if (!isMetaEvent(eventName)) {
    return;
  }
  try {
    canEmitMetaEvents = true;
    emitter.emit(eventName, eventData);
  } finally {
    canEmitMetaEvents = false;
  }
}
class Emittery {
  static mixin(emitteryPropertyName, methodNames) {
    methodNames = defaultMethodNamesOrAssert(methodNames);
    return (target) => {
      if (typeof target !== "function") {
        throw new TypeError("`target` must be function");
      }
      for (const methodName of methodNames) {
        if (target.prototype[methodName] !== void 0) {
          throw new Error(`The property \`${methodName}\` already exists on \`target\``);
        }
      }
      function getEmitteryProperty() {
        Object.defineProperty(this, emitteryPropertyName, {
          enumerable: false,
          value: new Emittery()
        });
        return this[emitteryPropertyName];
      }
      Object.defineProperty(target.prototype, emitteryPropertyName, {
        enumerable: false,
        get: getEmitteryProperty
      });
      const emitteryMethodCaller = (methodName) => function(...args) {
        return this[emitteryPropertyName][methodName](...args);
      };
      for (const methodName of methodNames) {
        Object.defineProperty(target.prototype, methodName, {
          enumerable: false,
          value: emitteryMethodCaller(methodName)
        });
      }
      return target;
    };
  }
  static get isDebugEnabled() {
    if (typeof globalThis.process?.env !== "object") {
      return isGlobalDebugEnabled;
    }
    const { env } = globalThis.process ?? { env: {} };
    return env.DEBUG === "emittery" || env.DEBUG === "*" || isGlobalDebugEnabled;
  }
  static set isDebugEnabled(newValue) {
    isGlobalDebugEnabled = newValue;
  }
  constructor(options = {}) {
    anyMap.set(this, /* @__PURE__ */ new Set());
    eventsMap.set(this, /* @__PURE__ */ new Map());
    producersMap.set(this, /* @__PURE__ */ new Map());
    producersMap.get(this).set(anyProducer, /* @__PURE__ */ new Set());
    this.debug = options.debug ?? {};
    if (this.debug.enabled === void 0) {
      this.debug.enabled = false;
    }
    if (!this.debug.logger) {
      this.debug.logger = (type, debugName, eventName, eventData) => {
        try {
          eventData = JSON.stringify(eventData);
        } catch {
          eventData = `Object with the following keys failed to stringify: ${Object.keys(eventData).join(",")}`;
        }
        if (typeof eventName === "symbol" || typeof eventName === "number") {
          eventName = eventName.toString();
        }
        const currentTime = /* @__PURE__ */ new Date();
        const logTime = `${currentTime.getHours()}:${currentTime.getMinutes()}:${currentTime.getSeconds()}.${currentTime.getMilliseconds()}`;
        console.log(`[${logTime}][emittery:${type}][${debugName}] Event Name: ${eventName}
	data: ${eventData}`);
      };
    }
  }
  logIfDebugEnabled(type, eventName, eventData) {
    if (Emittery.isDebugEnabled || this.debug.enabled) {
      this.debug.logger(type, this.debug.name, eventName, eventData);
    }
  }
  on(eventNames, listener, { signal } = {}) {
    assertListener(listener);
    eventNames = Array.isArray(eventNames) ? eventNames : [eventNames];
    for (const eventName of eventNames) {
      assertEventName(eventName);
      let set = getListeners(this, eventName);
      if (!set) {
        set = /* @__PURE__ */ new Set();
        const events = eventsMap.get(this);
        events.set(eventName, set);
      }
      set.add(listener);
      this.logIfDebugEnabled("subscribe", eventName, void 0);
      if (!isMetaEvent(eventName)) {
        emitMetaEvent(this, listenerAdded, { eventName, listener });
      }
    }
    const off = () => {
      this.off(eventNames, listener);
      signal?.removeEventListener("abort", off);
    };
    signal?.addEventListener("abort", off, { once: true });
    if (signal?.aborted) {
      off();
    }
    return off;
  }
  off(eventNames, listener) {
    assertListener(listener);
    eventNames = Array.isArray(eventNames) ? eventNames : [eventNames];
    for (const eventName of eventNames) {
      assertEventName(eventName);
      const set = getListeners(this, eventName);
      if (set) {
        set.delete(listener);
        if (set.size === 0) {
          const events = eventsMap.get(this);
          events.delete(eventName);
        }
      }
      this.logIfDebugEnabled("unsubscribe", eventName, void 0);
      if (!isMetaEvent(eventName)) {
        emitMetaEvent(this, listenerRemoved, { eventName, listener });
      }
    }
  }
  once(eventNames, predicate) {
    if (predicate !== void 0 && typeof predicate !== "function") {
      throw new TypeError("predicate must be a function");
    }
    let off_;
    const promise = new Promise((resolve) => {
      off_ = this.on(eventNames, (data) => {
        if (predicate && !predicate(data)) {
          return;
        }
        off_();
        resolve(data);
      });
    });
    promise.off = off_;
    return promise;
  }
  events(eventNames) {
    eventNames = Array.isArray(eventNames) ? eventNames : [eventNames];
    for (const eventName of eventNames) {
      assertEventName(eventName);
    }
    return iterator(this, eventNames);
  }
  async emit(eventName, eventData) {
    assertEventName(eventName);
    if (isMetaEvent(eventName) && !canEmitMetaEvents) {
      throw new TypeError("`eventName` cannot be meta event `listenerAdded` or `listenerRemoved`");
    }
    this.logIfDebugEnabled("emit", eventName, eventData);
    enqueueProducers(this, eventName, eventData);
    const listeners = getListeners(this, eventName) ?? /* @__PURE__ */ new Set();
    const anyListeners = anyMap.get(this);
    const staticListeners = [...listeners];
    const staticAnyListeners = isMetaEvent(eventName) ? [] : [...anyListeners];
    await resolvedPromise;
    await Promise.all([
      ...staticListeners.map(async (listener) => {
        if (listeners.has(listener)) {
          return listener(eventData);
        }
      }),
      ...staticAnyListeners.map(async (listener) => {
        if (anyListeners.has(listener)) {
          return listener(eventName, eventData);
        }
      })
    ]);
  }
  async emitSerial(eventName, eventData) {
    assertEventName(eventName);
    if (isMetaEvent(eventName) && !canEmitMetaEvents) {
      throw new TypeError("`eventName` cannot be meta event `listenerAdded` or `listenerRemoved`");
    }
    this.logIfDebugEnabled("emitSerial", eventName, eventData);
    const listeners = getListeners(this, eventName) ?? /* @__PURE__ */ new Set();
    const anyListeners = anyMap.get(this);
    const staticListeners = [...listeners];
    const staticAnyListeners = [...anyListeners];
    await resolvedPromise;
    for (const listener of staticListeners) {
      if (listeners.has(listener)) {
        await listener(eventData);
      }
    }
    for (const listener of staticAnyListeners) {
      if (anyListeners.has(listener)) {
        await listener(eventName, eventData);
      }
    }
  }
  onAny(listener, { signal } = {}) {
    assertListener(listener);
    this.logIfDebugEnabled("subscribeAny", void 0, void 0);
    anyMap.get(this).add(listener);
    emitMetaEvent(this, listenerAdded, { listener });
    const offAny = () => {
      this.offAny(listener);
      signal?.removeEventListener("abort", offAny);
    };
    signal?.addEventListener("abort", offAny, { once: true });
    if (signal?.aborted) {
      offAny();
    }
    return offAny;
  }
  anyEvent() {
    return iterator(this);
  }
  offAny(listener) {
    assertListener(listener);
    this.logIfDebugEnabled("unsubscribeAny", void 0, void 0);
    emitMetaEvent(this, listenerRemoved, { listener });
    anyMap.get(this).delete(listener);
  }
  clearListeners(eventNames) {
    eventNames = Array.isArray(eventNames) ? eventNames : [eventNames];
    for (const eventName of eventNames) {
      this.logIfDebugEnabled("clear", eventName, void 0);
      if (isEventKeyType(eventName)) {
        const set = getListeners(this, eventName);
        if (set) {
          set.clear();
        }
        const producers = getEventProducers(this, eventName);
        if (producers) {
          for (const producer of producers) {
            producer.finish();
          }
          producers.clear();
        }
      } else {
        anyMap.get(this).clear();
        for (const [eventName2, listeners] of eventsMap.get(this).entries()) {
          listeners.clear();
          eventsMap.get(this).delete(eventName2);
        }
        for (const [eventName2, producers] of producersMap.get(this).entries()) {
          for (const producer of producers) {
            producer.finish();
          }
          producers.clear();
          producersMap.get(this).delete(eventName2);
        }
      }
    }
  }
  listenerCount(eventNames) {
    eventNames = Array.isArray(eventNames) ? eventNames : [eventNames];
    let count2 = 0;
    for (const eventName of eventNames) {
      if (isEventKeyType(eventName)) {
        count2 += anyMap.get(this).size + (getListeners(this, eventName)?.size ?? 0) + (getEventProducers(this, eventName)?.size ?? 0) + (getEventProducers(this)?.size ?? 0);
        continue;
      }
      if (eventName !== void 0) {
        assertEventName(eventName);
      }
      count2 += anyMap.get(this).size;
      for (const value of eventsMap.get(this).values()) {
        count2 += value.size;
      }
      for (const value of producersMap.get(this).values()) {
        count2 += value.size;
      }
    }
    return count2;
  }
  bindMethods(target, methodNames) {
    if (typeof target !== "object" || target === null) {
      throw new TypeError("`target` must be an object");
    }
    methodNames = defaultMethodNamesOrAssert(methodNames);
    for (const methodName of methodNames) {
      if (target[methodName] !== void 0) {
        throw new Error(`The property \`${methodName}\` already exists on \`target\``);
      }
      Object.defineProperty(target, methodName, {
        enumerable: false,
        value: this[methodName].bind(this)
      });
    }
  }
}
const allEmitteryMethods = Object.getOwnPropertyNames(Emittery.prototype).filter((v2) => v2 !== "constructor");
Object.defineProperty(Emittery, "listenerAdded", {
  value: listenerAdded,
  writable: false,
  enumerable: true,
  configurable: false
});
Object.defineProperty(Emittery, "listenerRemoved", {
  value: listenerRemoved,
  writable: false,
  enumerable: true,
  configurable: false
});
class IndexingService extends Emittery {
  app;
  workerManager;
  maxConcurrentFiles;
  isParsing;
  fileQueue;
  filesInFlight;
  parsingSessionId = null;
  filesProcessed = 0;
  errorsEncountered = 0;
  totalFiles = 0;
  /**
   * Create a new IndexingService instance.
   *
   * @param app - The Obsidian app instance
   * @param workerManager - The WorkerManager instance for RPC communication
   * @param maxConcurrentFiles - Maximum number of files to process concurrently
   */
  constructor(app, workerManager, maxConcurrentFiles = 25) {
    super();
    this.app = app;
    this.workerManager = workerManager;
    this.maxConcurrentFiles = maxConcurrentFiles;
    this.isParsing = false;
    this.fileQueue = [];
    this.filesInFlight = /* @__PURE__ */ new Map();
  }
  /**
   * Start the incremental parsing process.
   * This method gets all Markdown files and begins processing them using a queue.
   */
  async startIndexing() {
    if (this.isParsing) {
      Logger.log("[TaskTrack][IndexingService.ts:36]", "Parsing already in progress");
      return;
    }
    await this.workerManager.RPC("health-check", { id: 0, appId: this.app.appId }).then((result) => {
      Logger.log("[TaskTrack][IndexingService.ts:40]", "[Worker health check]", result);
    });
    this.isParsing = true;
    this.fileQueue = [];
    this.filesInFlight.clear();
    this.filesProcessed = 0;
    this.errorsEncountered = 0;
    this.totalFiles = 0;
    try {
      Logger.log("[TaskTrack][IndexingService.ts:49]", "Starting incremental Markdown parsing...");
      const allFiles = this.app.vault.getMarkdownFiles();
      this.fileQueue = allFiles;
      this.totalFiles = allFiles.length;
      await this.emit("progress", {
        indexedCount: 0,
        totalCount: this.totalFiles
      });
      if (this.fileQueue.length === 0) {
        Logger.log("[TaskTrack][IndexingService.ts:58]", "No Markdown files found in the vault");
        this.isParsing = false;
        this.completeParsingSession();
        return;
      }
      Logger.log("[TaskTrack][IndexingService.ts:63]", `Found ${this.fileQueue.length} Markdown files to parse`);
      await this.processQueue();
    } catch (error) {
      Logger.error("[TaskTrack][IndexingService.ts:66]", "Error during incremental parsing:", error);
      this.isParsing = false;
      throw error;
    }
  }
  /**
   * Process files from the queue, maintaining no more than maxConcurrentFiles in flight.
   */
  async processQueue() {
    while (this.fileQueue.length > 0) {
      if (this.filesInFlight.size < this.maxConcurrentFiles && this.fileQueue.length > 0) {
        const file = this.fileQueue.shift();
        await this.processFile(file);
      }
      if (this.fileQueue.length > 0) {
        await this.waitForAvailableSlot();
      }
    }
    await Promise.all([...this.filesInFlight.values()]);
    Logger.log("[TaskTrack][IndexingService.ts:85]", "All Markdown files have been processed");
    this.completeParsingSession();
    this.isParsing = false;
  }
  /**
   * Process a single file by reading its content and sending to worker.
   *
   * @param file - The Markdown file to process
   */
  async processFile(file) {
    await this.emit("progress", {
      indexedCount: this.filesProcessed,
      totalCount: this.totalFiles
    });
    const filePromise = this.sendFileToWorker(file).finally(async () => {
      this.filesInFlight.delete(file.path);
      await this.emit("progress", {
        indexedCount: this.filesProcessed,
        totalCount: this.totalFiles
      });
    });
    this.filesInFlight.set(file.path, filePromise);
  }
  /**
   * Wait for at least one slot to become available in the concurrent processing.
   */
  async waitForAvailableSlot() {
    if (this.filesInFlight.size < this.maxConcurrentFiles) {
      return;
    }
    await Promise.race([...this.filesInFlight.values()]);
  }
  /**
   * Send a single Markdown file to the worker via RPC.
   *
   * @param file - The Markdown file to process
   * @returns Promise that resolves when processing is complete
   */
  async sendFileToWorker(file) {
    try {
      const content = await this.app.vault.cachedRead(file);
      try {
        await this.workerManager.RPC(
          "parse-markdown",
          {
            id: 0,
            path: file.path,
            content: null,
            timestamp: (/* @__PURE__ */ new Date()).toISOString()
          },
          content
        );
        this.filesProcessed++;
      } catch (error) {
        Logger.error("[TaskTrack][IndexingService.ts:139]", `Error processing file ${file.path}:`, error);
        this.errorsEncountered++;
        throw error;
      }
    } catch (error) {
      Logger.error("[TaskTrack][IndexingService.ts:144]", `Error processing file ${file.path}:`, error);
      throw error;
    }
  }
  /**
   * Complete the current parsing session
   */
  completeParsingSession() {
    if (this.parsingSessionId) {
      try {
        Logger.log(
          "[TaskTrack][IndexingService.ts:154]",
          `Completed parsing session ${this.parsingSessionId} - Processed: ${this.filesProcessed}, Errors: ${this.errorsEncountered}`
        );
      } catch (error) {
        Logger.error(
          "[TaskTrack][IndexingService.ts:158]",
          `Error completing parsing session ${this.parsingSessionId}:`,
          error
        );
      }
    }
  }
  /**
  
  
    /**
     * Check if parsing is currently in progress.
     *
     * @returns True if parsing is in progress, false otherwise
     */
  isCurrentlyParsing() {
    return this.isParsing;
  }
  /**
   * Get the current processing status.
   *
   * @returns Object with queue size, files in flight, and total files
   */
  getStatus() {
    return {
      queueSize: this.fileQueue.length,
      filesInFlight: this.filesInFlight.size,
      totalFiles: this.totalFiles,
      filesProcessed: this.filesProcessed,
      errorsEncountered: this.errorsEncountered
    };
  }
}
class TaskDatabase extends Emittery {
  db;
  isInitialized = false;
  /**
   * Create a new database service instance
   */
  constructor(appId) {
    super();
    this.db = new Dexie("TaskTrackDB:" + appId, {});
    this.db.version(1).stores({
      tasks: "&id,path,status,priority,createdAt,updatedAt,dueDate"
    });
    this.initialize().catch((err) => {
      Logger.error("[TaskTrack][TaskDatabase.ts:17]", "Error initializing database:", err);
    });
  }
  /**
   * Initialize the database and set up observers
   */
  async initialize() {
    try {
      await this.db.open();
      this.isInitialized = true;
      Logger.log("[TaskTrack][TaskDatabase.ts:27]", `TaskDatabase ${this.db.name} initialized successfully`);
    } catch (error) {
      Logger.error("[TaskTrack][TaskDatabase.ts:29]", "Failed to initialize DexieTaskDatabase:", error);
      this.isInitialized = false;
    }
  }
  /**
   * Clear database
   */
  async clearDatabase() {
    await this.db.delete();
    await this.db.open();
  }
  /**
   * Get task count from the database
   */
  async getAllTaskCount() {
    if (!this.isInitialized) {
      await this.initialize();
    }
    try {
      return await this.db.table("tasks").count();
    } catch (error) {
      Logger.error("[TaskTrack][TaskDatabase.ts:50]", "Error getting all tasks:", error);
      return 0;
    }
  }
  /**
   * Get all tasks from the database
   */
  async getAllTasks(filters = { statuses: [], keywords: [], files: [] }) {
    if (!this.isInitialized) {
      await this.initialize();
    }
    try {
      let query = this.db.table("tasks");
      if (filters.statuses?.length) {
        query = query.where("status").anyOf(filters.statuses);
      }
      let results = await query.toArray();
      if (filters.keywords?.length) {
        const matchers = filters.keywords.map(
          (kw) => new RegExp(kw.replace(/[.*+?^${}()|[\]\\]/g, "\\$&"), "i")
        );
        results = results.filter(
          (row) => matchers.every((regex) => regex.test(row.title))
        );
      }
      if (filters.files?.length) {
        const matchers = filters.files.map(
          (kw) => new RegExp(kw.replace(/[.*+?^${}()|[\]\\]/g, "\\$&"), "i")
        );
        results = results.filter(
          (row) => matchers.every((regex) => regex.test(row.path))
        );
      }
      return results;
    } catch (error) {
      Logger.error("[TaskTrack][TaskDatabase.ts:85]", "Error getting all tasks:", error);
      return [];
    }
  }
  /**
   * Add a new task to the database
   */
  async addTask(task) {
    if (!this.isInitialized) {
      await this.initialize();
    }
    try {
      await this.db.table("tasks").put(task);
      await this.emit("task-created", task);
      return task;
    } catch (error) {
      Logger.error("[TaskTrack][TaskDatabase.ts:101]", "Error adding task:", error);
      throw error;
    }
  }
  /**
   * Add multiple tasks to the database
   */
  async addTasks(tasks) {
    if (!this.isInitialized) {
      await this.initialize();
    }
    try {
      await this.db.table("tasks").bulkPut(tasks);
      for (const task of tasks) {
        await this.emit("task-created", task);
      }
      return tasks;
    } catch (error) {
      Logger.error("[TaskTrack][TaskDatabase.ts:119]", "Error adding task:", error);
      throw error;
    }
  }
  /**
   * Add multiple tasks to the database
   */
  async clearTasksByPath(path) {
    if (!this.isInitialized) {
      await this.initialize();
    }
    try {
      await this.db.table("tasks").where("path").equals(path).delete();
    } catch (error) {
      Logger.error("[TaskTrack][TaskDatabase.ts:133]", "Error adding task:", error);
      throw error;
    }
  }
  /**
   * Update an existing task
   */
  async updateTask(task) {
    if (!this.isInitialized) {
      await this.initialize();
    }
    try {
      await this.db.table("tasks").put(task);
      await this.emit("task-updated", task);
      return task;
    } catch (error) {
      Logger.error("[TaskTrack][TaskDatabase.ts:149]", "Error updating task:", error);
      throw error;
    }
  }
  /**
   * Delete a task from the database
   */
  async deleteTask(taskId) {
    if (!this.isInitialized) {
      await this.initialize();
    }
    try {
      const task = await this.db.table("tasks").get(taskId);
      if (!task) return false;
      await this.db.table("tasks").delete(taskId);
      await this.emit("task-deleted", taskId);
      return true;
    } catch (error) {
      Logger.error("[TaskTrack][TaskDatabase.ts:167]", "Error deleting task:", error);
      return false;
    }
  }
  /**
   * Close the database connection
   */
  close() {
    if (this.db.isOpen()) {
      this.db.close();
    }
  }
}
require$$0$1.addIcon(
  "tasktrack",
  `
  <svg
      xmlns="http://www.w3.org/2000/svg"
      viewBox="0 0 24 24"
      fill="none"
      stroke="currentColor"
      stroke-width="2"
      stroke-linecap="round"
      stroke-linejoin="round"
      class="lucide lucide-circle-check-icon lucide-circle-check lucide-crosshair"
  >
      <circle cx="12" cy="12" r="8" />
      <line x1="23" x2="19" y1="12" y2="12" />
      <line x1="5" x2="1" y1="12" y2="12" />
      <line x1="12" x2="12" y1="5" y2="1" />
      <line x1="12" x2="12" y1="23" y2="19" />
      <path d="m9 12 2 2 4-4" />
  </svg>
  `
);
require$$0$1.addIcon(
  "tasktrack-search-clear",
  `
  <svg
      xmlns="http://www.w3.org/2000/svg"
      viewBox="0 0 24 24"
      fill="none"
      stroke="currentColor"
      stroke-width="2"
      stroke-linecap="round"
      stroke-linejoin="round"
      class="lucide lucide-circle-x-icon lucide-circle-x"
  >
    <mask id="circleMask">
    <circle cx="12" cy="12" r="10" fill="white" />
      <path d="m15 9-6 6" stroke="black" />
      <path d="m9 9 6 6" stroke="black" />
    </mask>
    <circle cx="12" cy="12" r="8" fill="currentColor" mask="url(#circleMask)" />
  </svg>
  `
);
class TaskTrackPlugin extends require$$0$1.Plugin {
  settings = DEFAULT_SETTINGS;
  taskCreateModal = null;
  markdownParsingService;
  taskDatabase;
  /** @override */
  async onload() {
    const worker = new WorkerManager();
    this.markdownParsingService = new IndexingService(this.app, worker);
    this.taskDatabase = new TaskDatabase(this.app.appId);
    this.app.workspace.onLayoutReady(() => {
      this.markdownParsingService.startIndexing().catch((err) => {
        Logger.error("[TaskTrack][main.tsx:73]", "Error starting indexer:", err);
      });
      this.registerEvent(
        this.app.vault.on("create", (file) => {
          if (file instanceof require$$0$1.TFile) {
            this.markdownParsingService.sendFileToWorker(file).catch((err) => {
              Logger.error("[TaskTrack][main.tsx:79]", "Error sending file to Worker on 'create':", err);
            });
          }
        })
      );
      this.registerEvent(
        this.app.vault.on("modify", (file) => {
          if (file instanceof require$$0$1.TFile) {
            this.markdownParsingService.sendFileToWorker(file).catch((err) => {
              Logger.error("[TaskTrack][main.tsx:88]", "Error sending file to Worker on 'modify':", err);
            });
          }
        })
      );
      this.registerEvent(
        this.app.vault.on("delete", (file) => {
          if (file instanceof require$$0$1.TFile) {
            this.taskDatabase.clearTasksByPath(file.path).catch((err) => {
              Logger.error("[TaskTrack][main.tsx:97]", "Error clearing database entry on 'delete:", err);
            });
          }
        })
      );
    });
    const item = this.addStatusBarItem();
    item.classList.add("mod-clickable");
    item.innerText = STATUS_LOADING;
    item.onclick = () => {
      this.showTaskTrackModal();
    };
    const updateStatusBar = () => {
      if (!this.markdownParsingService) {
        item.innerText = STATUS_LOADING;
        return;
      }
      const status = this.markdownParsingService.getStatus();
      const totalFiles = status.totalFiles;
      const processedFiles = status.filesProcessed;
      if (this.markdownParsingService.isCurrentlyParsing()) {
        item.innerText = `TaskTrack (${processedFiles}/${totalFiles})`;
      } else {
        item.innerText = STATUS_OK;
      }
    };
    updateStatusBar();
    const progressListener = (status) => {
      item.innerText = `TaskTrack (${status.indexedCount}/${status.totalCount})`;
    };
    this.markdownParsingService.on("progress", progressListener);
    const repositionStatusBar = () => {
      if (!item.nextElementSibling) {
        item.parentNode?.insertBefore(item, item.previousElementSibling);
      }
    };
    repositionStatusBar();
    const observer = new MutationObserver(repositionStatusBar);
    observer.observe(item.parentNode, {
      childList: true,
      subtree: false
    });
    this.addRibbonIcon("tasktrack", RIBBON_TOOLTIP, () => {
      this.showTaskTrackModal();
    });
    await this.taskDatabase.clearDatabase();
    this.addCommand({
      id: "open-main-modal",
      name: COMMAND_OPEN_TASKTRACK_MODAL,
      icon: "tasktrack",
      callback: () => this.showTaskTrackModal()
    });
    this.addCommand({
      id: "create-new-task",
      name: COMMAND_CREATE_NEW_TASK,
      callback: () => this.showCreateTaskModal()
    });
    this.addSettingTab(new TaskTrackSettingsTab(this.app, this));
  }
  /** @override */
  onunload() {
    this.taskCreateModal?.close();
    if (this.markdownParsingService?.isCurrentlyParsing()) {
      Logger.debug("[TaskTrack][main.tsx:160]", "Parsing was in progress, stopping...");
    }
  }
  showTaskTrackModal() {
    const modal = new TaskTrackModal(this.app, this);
    modal.open();
  }
  showCreateTaskModal() {
    this.taskCreateModal = new TaskCreateModal(this.app, this);
    this.taskCreateModal.open();
  }
}
module.exports = TaskTrackPlugin;
//# sourceMappingURL=main.js.map
